<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ChatterBox</title>
    <style>
    :root{
      --bg:#0f1115;
      --panel:#111216;
      --muted:#9aa0a6;
      --accent:#4f9fff;
      --text:#f6f7f9;
      --subtle:#2a2d31;
      --composer-height:84px;
    }

    html,body {
      height:100%;
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:var(--text);
      /* IMPORTANT: force outer document not to scroll so only .chat-wrapper scrolls */
      overflow: hidden;
    }
    h1 { margin:12px; color:var(--text); font-size:20px; }

    /* Header pinned top */
    .app-header {
      position:sticky;
      top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding:8px 12px;
      background: var(--panel);
      border-bottom:1px solid rgba(255,255,255,0.03);
      z-index:30;
    }
    .header-left { display:flex; align-items:center; gap:8px; }
    .header-username { font-weight:600; color:var(--text); }
    .header-right { display:flex; align-items:center; gap:8px; }

    /* Buttons */
    .btn-small { background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; cursor:pointer; }
    .btn-primary { background:var(--accent); color:#041427; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }

    /* chat area (same) */
    .chat-wrapper {
      padding:12px;
      padding-bottom: calc(var(--composer-height) + 24px);
      /* full area uses internal scrolling only */
      height: calc(100vh - var(--composer-height) - 80px); /* explicit usable height */
      overflow:auto;
    }
    .status-line { font-size:13px; color:var(--muted); margin-bottom:6px; }

    .messages { display:flex; flex-direction:column; gap:8px; }

    /* Message */
    .message {
      display:flex;
      gap:10px;
      align-items:flex-start;
      background: linear-gradient(180deg, rgba(255,255,255,0.005), rgba(255,255,255,0.002));
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      position:relative;
    }
    .avatar { width:40px; height:40px; border-radius:50%; background:var(--subtle); color:var(--text); display:flex; align-items:center; justify-content:center; font-weight:700; }
    .avatar.small { width:32px; height:32px; font-size:12px; }

    .message-body { flex:1; min-width:0; }
    .meta { display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted); margin-bottom:6px; }
    .meta .name { color:var(--text); font-weight:600; }
    .meta .time { color:var(--muted); font-size:12px; }

    .edited { color:var(--muted); font-size:12px; margin-left:6px; font-style:italic; }

    .content { color:var(--text); line-height:1.35; word-break:break-word; }

    .quote { background:#0c0d0f; padding:6px; border-left:3px solid #222; margin-bottom:6px; color:var(--muted); border-radius:6px; }

    /* Reactions stay visible â€” actions hide into menu */
    .reactions { margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
    .reactions button { color:var(--text); border:1px solid rgba(255,255,255,0.03); padding:4px 6px; border-radius:6px; cursor:pointer; background:transparent; }

    /* Actions under message are hidden (moved into contextual menu) */
    .message .msg-actions { display:none; }

    /* ellipsis button appears on hover */
    .msg-menu-btn {
      display:none;
      position:absolute;
      right:8px;
      top:8px;
      background:transparent;
      border:none;
      color:var(--muted);
      font-size:18px;
      cursor:pointer;
    }
    .message:hover .msg-menu-btn { display:inline-block; }

    /* lighten message slightly on hover so cursor movement is visible */
    .message:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
      transition: filter 120ms ease, transform 120ms ease;
      cursor: default;
    }

    /* Context menu styling */
    .context-menu {
      position:absolute;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.04);
      padding:6px;
      border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,0.6);
      z-index:60;
      min-width:160px;
    }
    .context-menu button {
      display:block;
      width:100%;
      text-align:left;
      background:transparent;
      border:none;
      color:var(--text);
      padding:8px;
      cursor:pointer;
      border-radius:6px;
    }
    .context-menu button:hover { background:rgba(255,255,255,0.02); }

    /* Composer pinned */
    .composer {
      position:fixed;
      left:12px;
      right:12px;
      bottom:12px;
      height:var(--composer-height);
      display:flex;
      gap:8px;
      padding:10px;
      align-items:center;
      background: var(--panel);           /* solid panel */
      border:1px solid rgba(255,255,255,0.02);
      border-radius:10px;
      z-index:40;
    }
    .composer-left, .composer-right { display:flex; gap:8px; align-items:center; }
    .composer-middle { flex:1; }
    #inputText { width:100%; height:100%; resize:none; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:var(--text); outline:none; background:transparent; }

    /* pinned reply box just above composer */
    .reply-box, #replyBox {
      position:fixed;
      left:12px;
      right:12px;
      bottom: calc(var(--composer-height) + 18px);
      background: var(--panel);
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      color:var(--text);
      z-index:42;
      display:flex;
      align-items:center;
      gap:12px;
    }

    /* highlight referenced message so user sees context */
    .message.referenced {
      outline: 2px solid rgba(79,159,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.008));
      transition: background 180ms ease, outline 180ms ease;
    }

    input[type="file"] { color:var(--text); }

    /* Pins panel */
    .pins-panel { position:fixed; right:12px; bottom:calc(var(--composer-height) + 24px); width:360px; max-height:50vh; overflow:auto; background:var(--panel); border:1px solid rgba(255,255,255,0.03); padding:8px; border-radius:8px; z-index:45; }

    /* GIF picker layout & pinned header */
    #gifPicker {
      background: var(--panel);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.03);
      padding: 0;                /* header supplies padding */
      border-radius:8px;
      box-shadow:0 12px 36px rgba(0,0,0,0.6);
      z-index: 9999;
      overflow: hidden;         /* inner grid scrolls */
      max-width: 560px;
      width: min(46vw, 540px);
    }

    /* header pinned to the top of the picker (stays visible) */
    #gifPicker .picker-header {
      position: sticky;
      top: 0;
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.02);
      z-index: 3;
    }

    /* the grid area scrolls independently */
    #gifPicker #gifGrid {
      padding: 8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      overflow:auto;
      max-height: 52vh; /* will be dynamically clamped by JS too */
    }

    /* small tweak so picker right edge lines up visually with button */
    #gifPicker.align-right { transform-origin: top right; }

    .message .msg-actions {display:none; }

    /* small helpers */
    .btn-small:active, .btn-primary:active { transform:translateY(1px); }
    a { color:var(--accent); }
    .messages-end-spacer { height: calc(var(--composer-height) + 5px); flex-shrink:0; }
    </style>
</head>

<body>
  <h1>ChatterBox</h1>

  <div id="authBox" style="margin-bottom:12px;">
    <input id="authUser" placeholder="username" />
    <input id="authPass" type="password" placeholder="password" />
    <button id="authRegister">Register</button>
    <button id="authLogin">Login</button>
    <span id="authStatus" style="margin-left:8px;color:#666;"></span>
  </div>

  <div id="chatUI" style="display:none;">
    <!-- Header (pinned top after login) -->
    <header id="appHeader" class="app-header" style="display:none;">
      <div class="header-left">
        <div id="headerAvatar" class="avatar small">?</div>
        <div id="headerUsername" class="header-username"></div>
      </div>
      <div class="header-right">
        <button id="viewPinsBtn" class="btn-small">Pins</button>
        <button id="connectBtn" class="btn-small">Connect</button>
        <button id="logoutBtn" class="btn-small">Logout</button>
      </div>
    </header>

    <!-- Main chat area -->
    <main class="chat-wrapper">
      <div id="status" class="status-line"></div>
      <div id="container" class="messages"></div>
    </main>

    <!-- Pins panel toggled via View Pins -->
    <div id="pinsPanel" class="pins-panel" style="display:none;">
      <button id="closePins" class="btn-small">Close</button>
      <div id="pinsContainer" class="pinsContainer"></div>
    </div>

    <!-- Reply preview small area above composer -->
    <div id="replyBox" class="reply-box" style="display:none;">
      Replying to: <span id="replyPreview"></span>
      <button id="cancelReply">Cancel</button>
    </div>

    <!-- Composer (pinned to bottom) -->
    <div id="composer" class="composer">
      <div class="composer-left">
        <input id="fileInput" type="file" accept="image/*" title="Attach file" />
        
      </div>
      <div class="composer-middle">
        <textarea id="inputText" placeholder="Type a message..." rows="2"></textarea>
      </div>
      <div class="composer-right">
        <button id="gifBtn" title="GIF">GIF</button>
        <button id="submitButton" class="btn-primary">Send</button>
      </div>
    </div>

    <!-- GIF picker (positioning unchanged) -->
    <div id="gifPicker" style="display:none; position:absolute; background:#424549; border:1px solid #2cff05; max-width:450px; max-height:360px; overflow:auto;"></div>
  </div>


<script>
  let socket = null;
  let myId = null;
  let replyTo = null;
  const msgIndex = {}; //id

  // global saves
  let EMOJI_LIST = [];
  let EMOJI_ALIASES = {};

  async function loadFavoriteMap() {
  favoriteMap = {};
  const token = localStorage.getItem('access_token');
  if (!token) return;
  try {
    const res = await fetch('/gif/favorites', { headers: { 'token': token }});
    if (!res.ok) return;
    const j = await res.json();
    (j.results || []).forEach(f => {
      favoriteMap[String(f.gif_id)] = f.id;
    });
    console.log('[favorites] loaded', Object.keys(favoriteMap).length);
  } catch (e) {
    console.warn('[favorites] load failed', e);
  }
  }

  function getGifProviderKeyFromResult(g) {
    return String(g.id || g.gif_id || g.url || '');
  }
  function getGifProviderKeyFromUrl(url) {
    return String(url || '');
  }

  function updateGifFavUI(gifKey) {
    // update gif picker thumbs
    document.querySelectorAll('[data-gif-id]').forEach(el => {
      if (el.dataset.gifId !== gifKey) return;
      const btn = el.querySelector('.fav-btn');
      if (!btn) return;
      const favId = favoriteMap[gifKey];
      btn.textContent = favId ? 'â™¥' : 'â™¡';
      btn.title = favId ? 'Unfavorite' : 'Favorite';
    });

    // update chat messages that show this gif
    Object.values(msgIndex).forEach(m => {
      const content = (m.content || '').toString();
      const key = getGifProviderKeyFromUrl(content);
      if (key !== gifKey) return;
      const el = document.getElementById('msg-' + m.id);
      if (!el) return;
      const favBtn = el.querySelector('.gif-fav-btn');
      if (!favBtn) return;
      const favId = favoriteMap[gifKey];
      favBtn.textContent = favId ? 'â™¥' : 'â™¡';
      favBtn.title = favId ? 'Unfavorite' : 'Favorite';
    });
  } 

  // load emoji definitions from server static file
  fetch('/static/emojis.json')
  .then(res => {
    if (!res.ok) throw new Error('Failed to fetch emojis.json: ' + res.status);
    return res.json();
  })
  .then(data => {
    EMOJI_LIST = data.map(item => item.char).filter(Boolean);
    EMOJI_ALIASES = {};
    data.forEach(item => {
      const ch = item.char;
      (item.aliases || []).forEach(a => {
        EMOJI_ALIASES[a.toLowerCase()] = ch;
      });
    });
    console.log('[emoji] loaded', EMOJI_LIST.length, 'items');
  })
  .catch(err => {
    console.warn('Could not load emojis.json:', err);
  });

  let favoriteMap = {}; // gif_provider_id -> favorite_row_id

  window._referencedMsgId = null;

  function clearReferencedHighlight() {
    if (window._referencedMsgId) {
      const prev = document.getElementById('msg-' + window._referencedMsgId);
      if (prev) prev.classList.remove('referenced');
      window._referencedMsgId = null;
    }
  }
  function highlightReferencedMsg(id) {
    clearReferencedHighlight();
    const el = document.getElementById('msg-' + id);
    if (el) {
      el.classList.add('referenced');
      window._referencedMsgId = id;
    }
  }

  async function loadFavMap() {
    favoriteMap = {};
    const token = localStorage.getItem('access_token');
    if (!token) return;
    try {
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) return;
      const j = await res.json();
      (j.results || []).forEach(f => {
        favoriteMap[f.gif_id] = f.id;
      });
    } catch (e) {
      console.warn('Failed to load favorites map', e);
    }
  }
  
  function isContainerNearBottom(wrapperEl, threshold = 60) {
    // threshold in px
    return (wrapperEl.scrollHeight - wrapperEl.scrollTop - wrapperEl.clientHeight) <= threshold;
  }

  function scrollWrapperToBottom(wrapperEl) {
    wrapperEl.scrollTop = wrapperEl.scrollHeight;
  }

  function ensureEndSpacer(container){
  // ensure there is a spacer as last child so the composer doesn't cover last message
  if (!container) return;
  const last = container.lastElementChild;
  if (!last || !last.classList || !last.classList.contains('messages-end-spacer')) {
    const spacer = document.createElement('div');
    spacer.className = 'messages-end-spacer';
    container.appendChild(spacer);
  }
}

  function showMessageElement(el) {
    const container = document.getElementById('container');
    if (!container) {
      document.body.appendChild(el);
      return;
    }

    const wrapper = container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper') || container;
    const wasNearBottom = isContainerNearBottom(wrapper, 50);

    // remove previous spacer before appending so we always append messages before spacer
    const existingSpacer = container.querySelector('.messages-end-spacer');
    if (existingSpacer) existingSpacer.remove();

    container.appendChild(el);
    // re-add spacer at the end
    ensureEndSpacer(container);

    if (wasNearBottom) {
      setTimeout(() => scrollWrapperToBottom(wrapper), 8);
    }
  }

  function renderMessage(msg, isLocalEcho=false) {
  // if message flagged deleted, skip rendering (safety)
  if (msg.deleted) return document.createElement('div');

  msgIndex[msg.id] = msg;

  const wrapper = document.createElement('div');
  wrapper.className = 'message';
  wrapper.id = 'msg-' + msg.id;

  // avatar
  const avatar = document.createElement('div');
  avatar.className = 'avatar';
  avatar.textContent = (msg.author && msg.author[0]) ? msg.author[0].toUpperCase() : '?';

  // body (meta + content)
  const body = document.createElement('div');
  body.className = 'message-body';

  const meta = document.createElement('div');
  meta.className = 'meta';
  const nameSpan = document.createElement('span');
  nameSpan.className = 'name';
  nameSpan.textContent = msg.author;
  const timeSpan = document.createElement('span');
  timeSpan.className = 'time';
  try { timeSpan.textContent = new Date(msg.timestamp).toLocaleString(); } catch(e){ timeSpan.textContent = ''; }
  meta.appendChild(nameSpan);
  meta.appendChild(timeSpan);
  if (msg.edited_at) {
    const editedSpan = document.createElement('span');
    editedSpan.className = 'edited';
    editedSpan.textContent = '(edited)';
    meta.appendChild(editedSpan);
  }
  body.appendChild(meta);

  // --- inline reply preview (clickable) ---
  if (msg.reply_to) {
    const qr = document.createElement('div');
    qr.className = 'inline-reply-preview';
    qr.style.background = '#0b0c0e';
    qr.style.padding = '6px';
    qr.style.borderLeft = '3px solid rgba(255,255,255,0.03)';
    qr.style.borderRadius = '6px';
    qr.style.marginBottom = '6px';
    qr.style.color = 'var(--muted)';
    qr.style.fontSize = '13px';
    qr.style.cursor = 'pointer';
    // show short preview from local cache if available, else placeholder
    const quoted = msgIndex[msg.reply_to];
    qr.textContent = quoted ? ((quoted.deleted ? '(original deleted)' : (String(quoted.content || '').slice(0,120)))) : '(quoted message)';
    // click -> scroll to referenced message
    qr.onclick = (ev) => {
      ev.stopPropagation();
      const target = document.getElementById('msg-' + msg.reply_to);
      const wrapper = document.querySelector('.chat-wrapper');
      if (target && wrapper) {
        // smooth scroll target into center of wrapper
        const targetTop = target.offsetTop;
        const centerOffset = Math.round((wrapper.clientHeight / 2) - (target.clientHeight / 2));
        wrapper.scrollTo({ top: Math.max(0, targetTop - centerOffset), behavior: 'smooth' });
        // briefly highlight to give feedback
        target.classList.add('referenced');
        setTimeout(()=> target.classList.remove('referenced'), 1400);
      }
    };
    body.appendChild(qr);
  }


  const content = document.createElement('div');
  content.className = 'content';

  const text = (msg.content || "").toString();
  if (isImageUrl(text)) {
    const img = document.createElement('img');
    img.src = text;
    img.style.maxWidth = '300px';
    img.style.borderRadius = '6px';
    content.appendChild(img);

    // GIF favorite button (if you have favorites)
    const gifKey = getGifKeyFromUrl(text);
    const favBtn = document.createElement('button');
    favBtn.className = 'gif-fav-btn';
    const favId = favoriteMap[gifKey];
    favBtn.textContent = favId ? 'â™¥' : 'â™¡';
    favBtn.title = favId ? 'Unfavorite' : 'Favorite';
    favBtn.style.marginLeft = '8px';
    favBtn.onclick = async (e) => {
      e.stopPropagation();
      const token = localStorage.getItem('access_token');
      if (!token) { alert('Log in to favorite GIFs'); return; }
      if (favoriteMap[gifKey]) {
        const fid = favoriteMap[gifKey];
        const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), { method: 'DELETE', headers: { token }});
        if (res.ok) { delete favoriteMap[gifKey]; updateGifFavUI(gifKey); favBtn.textContent='â™¡'; }
      } else {
        const payload = { gif_id: text, url: text, preview: text, title: '' };
        const res = await fetch('/gif/favorite', { method:'POST', headers: {'Content-Type':'application/json', token}, body: JSON.stringify(payload) });
        if (res.ok) {
          const j = await res.json().catch(()=>({}));
          if (j.id) favoriteMap[gifKey] = j.id;
          favBtn.textContent='â™¥';
          updateGifFavUI(gifKey);
        }
      }
    };
    content.appendChild(favBtn);

  } else if (isVideoUrl(text)) {
    const vid = document.createElement('video');
    vid.src = text;
    vid.controls = true;
    vid.style.maxWidth = '400px';
    content.appendChild(vid);
  } else {
    content.innerHTML = marked.parse(text);
  }

  body.appendChild(content);

  // reactions area
  const reactionsBar = document.createElement('div');
  reactionsBar.className = 'reactions';
  if (msg.reactions && typeof msg.reactions === 'object') {
    Object.entries(msg.reactions).forEach(([emoji, users]) => {
      const rbtn = document.createElement('button');
      rbtn.textContent = `${emoji} ${Array.isArray(users) ? users.length : 0}`;
      rbtn.onclick = () => { if (!socket || socket.readyState !== WebSocket.OPEN) return; socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji })); };
      reactionsBar.appendChild(rbtn);
    });
  }

  const addReactBtn = document.createElement('button');
  addReactBtn.textContent = '+';
  addReactBtn.title = 'Add reaction';
  addReactBtn.onclick = (ev) => {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    openEmojiPicker(addReactBtn, (emoji) => { socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji })); });
    ev.stopPropagation?.();
    };
    reactionsBar.appendChild(addReactBtn);
    body.appendChild(reactionsBar);

    // actions (pin/copy/reply/delete/edit) - keep small and unobtrusive
    const actions = document.createElement('div');
    actions.className = 'msg-actions';
    actions.style.marginTop = '6px';

    const pinBtn = document.createElement('button');
    pinBtn.textContent = msg.pinned ? 'Unpin' : 'Pin';
    pinBtn.onclick = () => {
      if (!socket || socket.readyState !== WebSocket.OPEN) return;
      const pinFlag = !msg.pinned;
      socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: pinFlag }));
    };
    actions.appendChild(pinBtn);

    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(msg.content || ''); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',900); } catch(e){ alert('Copy failed: '+e); }
    };
    actions.appendChild(copyBtn);

    const replyBtn = document.createElement('button');
    replyBtn.textContent = 'Reply';
    replyBtn.onclick = () => startReply(msg.id);
    actions.appendChild(replyBtn);

    if (msg.author === myId) {
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.onclick = () => { socket.send(JSON.stringify({ type: 'delete', id: msg.id })); };
      actions.appendChild(delBtn);

      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditUI(msg.id);
      actions.appendChild(editBtn);
    }

    body.appendChild(actions);

    // --- contextual menu (ellipsis button + menu on click / right-click) ---
    // create ellipsis button (will be visible because of CSS)
    const menuBtn = document.createElement('button');
    menuBtn.className = 'msg-menu-btn';
    menuBtn.textContent = 'â‹¯';
    menuBtn.title = 'Actions';

    // helper to close existing menu
    function closeContextMenu() {
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();
      document.removeEventListener('click', closeContextMenu);
    }

    // make the menu DOM and attach actions
    function openContextMenuAt(x, y) {
      closeContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';

      const addItem = (label, fn) => {
        const b = document.createElement('button');
        b.textContent = label;
        b.onclick = (ev) => { ev.stopPropagation(); fn(); closeContextMenu(); };
        menu.appendChild(b);
      };

      addItem(msg.pinned ? 'Unpin' : 'Pin', () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: !msg.pinned }));
      });

      addItem('Copy', () => {
        try { navigator.clipboard.writeText(msg.content || ''); } catch(e){ console.warn('copy failed', e); }
      });

      addItem('Reply', () => startReply(msg.id) );

      if (msg.author === myId) {
        addItem('Edit', () => openEditUI(msg.id));
        addItem('Delete', () => { if (!socket) return; socket.send(JSON.stringify({ type:'delete', id: msg.id })); });
      }

      // quick react row
      const reactRow = document.createElement('div');
      reactRow.style.display = 'flex';
      reactRow.style.gap = '6px';
      reactRow.style.marginTop = '6px';
      ['ðŸ‘','â¤ï¸','ðŸ˜‚','ðŸ”¥','ðŸ˜®'].forEach(ch => {
        const rb = document.createElement('button');
        rb.textContent = ch;
        rb.onclick = (ev) => { ev.stopPropagation(); if (!socket) return; socket.send(JSON.stringify({ type:'react', id: msg.id, emoji: ch })); closeContextMenu(); };
        reactRow.appendChild(rb);
      });
      menu.appendChild(reactRow);

      document.body.appendChild(menu);

      // clamp position so menu stays on-screen
      const rect = menu.getBoundingClientRect();
      let left = Math.max(8, Math.min(window.innerWidth - rect.width - 8, x));
      let top = Math.max(8, Math.min(window.innerHeight - rect.height - 8, y));
      menu.style.left = left + 'px';
      menu.style.top = top + 'px';

      setTimeout(()=> document.addEventListener('click', closeContextMenu));
    }

    // show menu on ellipsis click
    menuBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const r = menuBtn.getBoundingClientRect();
      openContextMenuAt(r.left, r.bottom + 6);
    });

    // show menu on right-click
    wrapper.addEventListener('contextmenu', (ev) => {
      ev.preventDefault();
      openContextMenuAt(ev.clientX, ev.clientY);
    });

    // attach the ellipsis button to wrapper (CSS shows it on hover)
    wrapper.appendChild(menuBtn);


    wrapper.appendChild(avatar);
    wrapper.appendChild(body);
    return wrapper;
  }


  // delegated handler for edit buttons (works even if messages are rendered later)
  document.getElementById('container').addEventListener('click', (ev) => {
    const target = ev.target;
    if (!target) return;
    if (target.classList && target.classList.contains('edit-btn')) {
      const msgId = target.dataset.msgId;
      if (msgId) openEditUI(msgId);
    }
  });

  // openEditUI: top-level (global) edit UI â€” supports replacing content (text or media URL).
  function openEditUI(messageId) {
    const el = document.getElementById('msg-' + messageId);
    if (!el) return;
    const contentEl = el.querySelector('.content');
    if (!contentEl) return;

    // create editor UI (textarea + optional file input + Save/Cancel)
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.rows = 3;
    textarea.value = (msgIndex[messageId] && msgIndex[messageId].content) || '';

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'block';
    fileInput.style.marginTop = '6px';

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.marginLeft = '6px';

    // replace content element with editor
    contentEl.innerHTML = '';
    contentEl.appendChild(textarea);
    contentEl.appendChild(fileInput);
    contentEl.appendChild(saveBtn);
    contentEl.appendChild(cancelBtn);

    saveBtn.onclick = async () => {
      const newText = textarea.value.trim();

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert('Not connected');
        return;
      }

      // if a file is attached, upload it and use resulting URL as the new content
      const file = fileInput.files && fileInput.files[0];
      let finalContent = newText;
      if (file) {
        const fd = new FormData();
        fd.append('file', file);
        const up = await fetch('/upload', { method: 'POST', body: fd });
        if (!up.ok) {
          alert('File upload failed');
          return;
        }
        const upj = await up.json().catch(()=>({}));
        finalContent = upj.url || finalContent;
      }

      // send edit request over websocket
      socket.send(JSON.stringify({ type: 'edit', id: messageId, content: finalContent }));

      // optimistic update
      msgIndex[messageId].content = finalContent;
      msgIndex[messageId].edited_at = new Date().toISOString();
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };

    cancelBtn.onclick = () => {
      // restore original view
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };
  }


  function startReply(messageId) {
    replyTo = messageId;

    const preview = document.getElementById('replyPreview');
    const msg = msgIndex[messageId];

    // set preview text (shortened)
    let previewText = '';
    if (msg) {
      if (msg.deleted) previewText = '(original deleted)';
      else previewText = (msg.content || '').toString().slice(0, 140);
    } else {
      previewText = '(loading...)';
    }
    if (preview) preview.textContent = previewText;

    // show pinned reply box above composer
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'flex';

    // highlight the referenced message visually
    highlightReferencedMsg(messageId);
  }


  //Gif Render

  document.getElementById('gifBtn').onclick = async function openGifPicker() {
    const gifPicker = document.getElementById('gifPicker');
    const gifBtn = document.getElementById('gifBtn');
    if (!gifPicker || !gifBtn) return;

    // toggle
    if (gifPicker.style.display === 'block') { gifPicker.style.display = 'none'; return; }

    // build the picker content (same as before)
    gifPicker.innerHTML = `
      <div class="picker-header">
        <button id="gifTrendingBtn" class="btn-small">Trending</button>
        <button id="gifSearchBtn" class="btn-small">Search</button>
        <button id="gifFavsBtn" class="btn-small">Favorites</button>
        <input id="gifSearchInput" placeholder="Search GIFs..." style="flex:1; min-width:120px;" />
      </div>
      <div id="gifGrid"></div>
    `;
    

    // position above the gifBtn, anchored to composer
    // position above the gifBtn, anchored to the composer and fixed to viewport
    gifPicker.style.position = 'fixed'; // important â€” keeps it visible and not extending page
    gifPicker.style.display = 'block';
    setTimeout(() => {
      const btnRect = gifBtn.getBoundingClientRect();
      const pickerRect = gifPicker.getBoundingClientRect();

      // prefer above the button, centered horizontally over the button
      let left = Math.round(btnRect.left + (btnRect.width / 2) - (pickerRect.width / 2));
      // clamp to screen edges
      left = Math.max(8, Math.min(window.innerWidth - pickerRect.width - 8, left));

      // try to place above the composer/button; if not enough room, place above top area
      let top = Math.round(btnRect.top - pickerRect.height - 10);
      if (top < 8) {
        // place it above composer area (safe fallback)
        top = Math.max(8, btnRect.top - pickerRect.height - 10);
      }

      gifPicker.style.left = `${left}px`;
      gifPicker.style.top = `${top}px`;
      //gifPicker.style.left = `813.797px`
      //gifPicker.style.top = `496px`
    }, 40);


    // wire the buttons (same behavior as your existing handlers)
    const grid = document.getElementById('gifGrid');
    const searchInp = document.getElementById('gifSearchInput');

    async function ensureFavs(){ await loadFavoriteMap(); }

    document.getElementById('gifTrendingBtn').onclick = async () => {
      grid.innerHTML = 'Loading...';
      await ensureFavs();
      const res = await fetch('/gif/trending?limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifSearchBtn').onclick = async () => {
      const q = (searchInp && searchInp.value || '').trim();
      grid.innerHTML = 'Searching...';
      await ensureFavs();
      const res = await fetch('/gif/search?q=' + encodeURIComponent(q || '') + '&limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifFavsBtn').onclick = async () => {
      grid.innerHTML = 'Loading favorites...';
      const token = localStorage.getItem('access_token');
      if (!token) { grid.innerHTML = 'Log in to view favorites.'; return; }
      await ensureFavs();
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) { grid.innerHTML = 'Failed to load favorites'; return; }
      const j = await res.json();
      const arr = (j.results || []).map(f => ({ id: f.gif_id, url: f.url, preview: f.preview, title: f.title }));
      renderGifGrid(arr, grid);
    };

    // debounce typing
    let t;
    searchInp.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(()=> document.getElementById('gifSearchBtn').click(), 300);
    });

    // initial load trending
    document.getElementById('gifTrendingBtn').click();

    // hide if user clicks anywhere else
    setTimeout(()=> window.addEventListener('click', function outside(e){
      if (!gifPicker.contains(e.target) && e.target !== gifBtn) {
        gifPicker.style.display = 'none';
        window.removeEventListener('click', outside);
      }
    }));
  };


    async function render(results) {
      grid.innerHTML = '';
      // refresh favorite map
      await loadFavoriteMap();
      for (const g of results) {
        const url = g.url;
        const idKey = String(g.id || g.url || g.gif_id || url);
        const thumb = document.createElement('img');
        thumb.src = g.preview || g.url;
        thumb.style.width = '120px';
        thumb.style.cursor = 'pointer';
        thumb.onclick = () => {
          if (!socket || socket.readyState !== WebSocket.OPEN) { alert('Not connected'); return; }
          socket.send(JSON.stringify({ type: 'message', content: url }));
          gifPicker.style.display = 'none';
        };

        const favBtn = document.createElement('button');
        favBtn.textContent = favoriteMap[idKey] ? 'â™¥' : 'â™¡';
        favBtn.onclick = async (e) => {
          e.stopPropagation();
          if (!token) { alert('Log in to favorite'); return; }
          if (favoriteMap[idKey]) {
            // unfav
            const fid = favoriteMap[idKey];
            const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), { method: 'DELETE', headers: { token }});
            if (res.ok) { delete favoriteMap[idKey]; favBtn.textContent = 'â™¡'; updateGifFavUI(idKey); }
          } else {
            const payload = { gif_id: g.id || idKey, url: url, preview: g.preview, title: g.title || '' };
            const res = await fetch('/gif/favorite', { method:'POST', headers: {'Content-Type':'application/json', token}, body: JSON.stringify(payload) });
            if (res.ok) {
              const j = await res.json().catch(()=>({}));
              if (j.id) favoriteMap[idKey] = j.id;
              favBtn.textContent = 'â™¥';
              updateGifFavUI(idKey);
            }
          }
        };

        const box = document.createElement('div');
        box.style.position = 'relative';
        box.style.display = 'inline-block';
        box.style.width = '120px';
        box.appendChild(thumb);
        favBtn.style.position = 'absolute';
        favBtn.style.right = '4px';
        favBtn.style.top = '4px';
        favBtn.style.padding = '2px 6px';
        box.appendChild(favBtn);
        grid.appendChild(box);
      }
    }

  function getGifKeyFromResult(g) {
    return String(g.id || g.gif_id ||  g.gifId || g.url || '');
  }

  function getGifKeyFromUrl(url) {
    return String(url || '')
  }

  function renderGifGrid(results, grid){
    grid.innerHTML = '';
    const token = localStorage.getItem('access_token');

    results.forEach(g => {
      const url = g.url;
      const gifKey = getGifKeyFromResult(g);

      const wrapper = document.createElement('div');
      wrapper.style.position = 'relative';
      wrapper.style.margin = '6px';
      wrapper.dataset.gifId = gifKey;

      const thumb = document.createElement('img');
      thumb.src = g.preview || g.url;
      thumb.style.width = '120px';
      thumb.style.cursor = 'pointer';
      thumb.title = g.title || '';
      thumb.onclick = () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) { alert('Not connected'); return; }
        socket.send(JSON.stringify({ type:"message", content: g.url }));
        document.getElementById('gifPicker').style.display = 'none';
      };
      wrapper.appendChild(thumb);

      // favorite button (top-right)
      const favBtn = document.createElement('button');
      favBtn.className = 'fav-btn';
      const favRowId = favoriteMap[gifKey];
      favBtn.textContent = favRowId ? 'â™¥' : 'â™¡';
      favBtn.title = favRowId ? 'Unfavorite' : 'Favorite';
      favBtn.style.position = 'absolute';
      favBtn.style.top = '4px';
      favBtn.style.right = '4px';
      favBtn.style.padding = '4px';
      favBtn.style.fontSize = '12px';

      favBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!token) { alert('Log in to favorite GIFs'); return; }

        if (favoriteMap[gifKey]) {
          // unfavorite
          const fid = favoriteMap[gifKey];
          const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), {
            method: 'DELETE',
            headers: {'token': token}
          });
          if (res.ok) {
            delete favoriteMap[gifKey];
            favBtn.textContent = 'â™¡';
            favBtn.title = 'Favorite';
            updateGifFavUI(gifKey);
          } else {
            alert('Failed to remove favorite');
          }
        } else {
          // add favorite
          const payload = {
            gif_id: g.id || gifKey,
            url: g.url,
            preview: g.preview,
            title: g.title,
            metadata: g.metadata || {}
          };
          const res = await fetch('/gif/favorite', {
            method: 'POST',
            headers: {'Content-Type':'application/json', 'token': token},
            body: JSON.stringify(payload)
          });
          if (res.ok) {
            const j = await res.json().catch(()=>({}));
            // server returns {"ok": True, "id": <fav_row_id>}
            if (j.id) {
              favoriteMap[gifKey] = j.id;
            } else {
              favBtn.textContent = 'â™¥';
              favoriteMap[gifKey] = null;
              updateGifFavUI(gifKey);
            }
          } else {
            const j = await res.json().catch(()=>({}));
            alert('Favorite failed: ' + (j.detail || JSON.stringify(j)));
          }
        }
      };

      wrapper.appendChild(favBtn);
      grid.appendChild(wrapper);
    });
  }


  //Debounce Helper
  function debounce(fn, wait){
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), wait); };
  }

  //Favorite Gifs
  function getLocalFavs(){ try{return JSON.parse(localStorage.getItem('gif_favs')||'[]');}catch(e){return []}}
  function addLocalFav(g){ const arr=getLocalFavs(); if(!arr.find(x=>x.id===g.id)) arr.push(g); localStorage.setItem('gif_favs', JSON.stringify(arr)); }
  function removeLocalFav(id){ let arr=getLocalFavs(); arr=arr.filter(x=>x.id!==id); localStorage.setItem('gif_favs', JSON.stringify(arr)); }

  //Reactions
  function openEmojiPicker(anchorEl, onChoose) {
    closeEmojiPicker();
    if (!anchorEl) return;

    const picker = document.createElement('div');
    picker.id = 'emoji-picker';
    picker.style.position = 'absolute';
    picker.style.background = '#fff';
    picker.style.border = '1px solid #ccc';
    picker.style.padding = '6px';
    picker.style.boxShadow = '0 6px 12px rgba(0,0,0,0.12)';
    picker.style.zIndex = 9999;
    picker.style.maxWidth = '360px';
    picker.style.maxHeight = '260px';
    picker.style.overflow = 'auto';

    const input = document.createElement('input');
    input.placeholder = 'Search emoji...';
    input.style.width = '100%';
    input.style.boxSizing = 'border-box';
    input.style.marginBottom = '6px';
    picker.appendChild(input);

    const grid = document.createElement('div');
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '6px';
    picker.appendChild(grid);

    function renderGrid(filter='') {
      grid.innerHTML = '';
      const q = (filter || '').toLowerCase().trim();
      const candidates = EMOJI_LIST.filter(ch => {
        if (!q) return true;
        if (ch.includes(q)) return true;
        return Object.keys(EMOJI_ALIASES).some(a => (EMOJI_ALIASES[a] === ch) && a.includes(q));
      }).slice(0, 120);
      candidates.forEach(ch => {
        const b = document.createElement('button');
        b.textContent = ch;
        b.style.fontSize = '18px';
        b.style.padding = '4px';
        b.style.cursor = 'pointer';
        b.onclick = () => { 
          console.log('[emoji-picker] chosen', ch);
          onChoose(ch); 
          closeEmojiPicker(); 
        };
        grid.appendChild(b);
      });
    }

    // wire input
    input.addEventListener('input', e => renderGrid(e.target.value));
    renderGrid();

    document.body.appendChild(picker);

    // position relative to anchorEl (best-effort)
    try {
      const r = anchorEl.getBoundingClientRect();
      picker.style.left = `${Math.max(4, r.left)}px`;
      picker.style.top = `${r.bottom + window.scrollY + 6}px`;
    } catch (e) {
      /* ignore positioning errors */
    }

    // outside-click removal
    setTimeout(()=> window.addEventListener('click', outsideClick));
    function outsideClick(e) {
      if (!picker.contains(e.target) && e.target !== anchorEl) closeEmojiPicker();
    }
    picker._outsideFn = outsideClick;
  }

  function closeEmojiPicker() {
    const p = document.getElementById('emoji-picker');
    if (p) {
      window.removeEventListener('click', p._outsideFn);
      p.remove();
    }
  }

  function openEditUI(messageId) {
    const el = document.getElementById('msg-' + messageId);
    if (!el) return;
    const contentEl = el.querySelector('.content');
    if (!contentEl) return;

    // create textarea and Save/Cancel
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.rows = 3;
    textarea.value = (msgIndex[messageId] && msgIndex[messageId].content) || '';
    textarea.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' && !ev.shiftKey) {
        ev.preventDefault();
        saveBtn.click();
      }
    });

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';

    // replace content element with editor
    contentEl.innerHTML = '';
    contentEl.appendChild(textarea);
    contentEl.appendChild(saveBtn);
    contentEl.appendChild(cancelBtn);

    saveBtn.onclick = () => {
      const newText = textarea.value.trim();
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert('Not connected');
        return;
      }
      socket.send(JSON.stringify({ type: 'edit', id: messageId, content: newText }));
      // optimistically update UI (server will broadcast too)
      msgIndex[messageId].content = newText;
      msgIndex[messageId].edited_at = new Date().toISOString();
      // re-render node to restore normal view
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };

    cancelBtn.onclick = () => {
      // restore existing content display
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };
  }


  // position
//  const r = anchorEl.getBoundingClientRect();
//  picker.style.left = `${r.left}px`;
//  picker.style.top = `${r.bottom + window.scrollY + 6}px`;
//
//  setTimeout(()=> window.addEventListener('click', outsideClick));
//  function outsideClick(e) {
//    if (!picker.contains(e.target) && e.target !== anchorEl) closeEmojiPicker();
//  }
//  picker._outsideFn = outsideClick;
  

  function replaceAliasesInText(text) {
    return text.replace(/:([a-zA-Z0-9_+-]+):/g, (m, alias) => {
      const ch = EMOJI_ALIASES[alias.toLowerCase()];
    return ch || m;
  });
}

  function isImageUrl(url){
    return /\.(png|jpe?g|gif|webp)$/i.test(url);
  }

  function isVideoUrl(url) {
    if (!url) return false;
    return /\.(mp4|webm|ogg)$/i.test(url);
  }

  document.getElementById('cancelReply').onclick = () => {
    replyTo = null;
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'none';
    const preview = document.getElementById('replyPreview');
    if (preview) preview.textContent = '';
    clearReferencedHighlight();
  };


  // REGISTER: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authRegister').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/register', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({username: u, password: p})
      });
      const j = await res.json();
      console.log('register result', res.status, j);

      if (res.ok && j.access_token) {
        localStorage.setItem('access_token', j.access_token);
        localStorage.setItem('username', j.username);
        document.getElementById('authStatus').textContent = `Registered & logged in as ${j.username}`;
        // hide auth UI
        const authBox = document.getElementById('authBox');
        if (authBox) authBox.style.display = 'none';
        // auto-connect
        try { await connectSocket(); } catch(e){ console.error('auto-connect failed', e); }
      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Register failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Register error â€” check server logs');
    }
  };

  // LOGIN: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authLogin').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ username: u, password: p })
      });
      const j = await res.json();
      console.log('login response', res.status, j);

      if (res.ok && j.access_token) {
        localStorage.setItem('access_token', j.access_token);
        localStorage.setItem('username', j.username);
        document.getElementById('authStatus').textContent = `Logged in as ${j.username}`;

        // hide auth UI
        const authBox = document.getElementById('authBox');
        if (authBox) authBox.style.display = 'none';

        // auto-connect
        try { await connectSocket(); } catch(e){ console.error('auto-connect failed', e); }

      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Login failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Login error â€” check server logs');
    }
  };
  
function resetChatUI(){
  //Clear DOM
  document.getElementById('container').innerHTML = '';
  document.getElementById('pinsContainer').innerHTML = '';
  document.getElementById('pinsContainer').style.display = 'none';
  document.getElementById('viewPinsBtn').textContent = 'View Pins';

  // Clear client state
  for (const k in msgIndex) delete msgIndex[k];
  replyTo = null;

  // Clear input
  const input = document.getElementById('inputText');


  if (input) input.value = '';

  // Hide reply box
  document.getElementById('replyBox').style.display = 'none';
  document.getElementById('replyPreview').textContent = '';
}

// centralized connect function
async function connectSocket() {
  // if already connected, do nothing (or optionally re-open)
  if (socket && socket.readyState === WebSocket.OPEN) {
    console.log("WebSocket already open");
    return;
  }

  const token = localStorage.getItme('access_token')
  const storedUsername = localStorage.getItem('username');

  // create WS and install handlers
  if (!token || !myId) {
    document.getElementById('status').textContent = 'Not logged in';
    return;
  }

  // build ws url relative to current page so it works on Render / localhost / prod
  const isSecure = (window.location.protocol === 'https:');
  const wsProto = isSecure ? 'wss' : 'ws';
  const host = window.location.host; // includes port if any
  const wsUrl = `${wsProto}://${host}/ws?token=${encodeURIComponent(token)}`;

  console.log('[connectSocket] opening', wsUrl);
  document.getElementById('status').textContent = 'Connecting...';
  socket = new WebSocket(wsUrl);

  socket.addEventListener('open', () => {
    // Set header username + avatar
    const headerUserEl = document.getElementById('headerUsername');
    const headerAvatarEl = document.getElementById('headerAvatar');
    if (headerUserEl) headerUserEl.textContent = myId || '';
    if (headerAvatarEl) headerAvatarEl.textContent = (myId && myId[0]) ? myId[0].toUpperCase() : '?';
    document.getElementById('appHeader').style.display = 'flex';
    document.getElementById('headerAvatar').style.display = 'flex';


    document.getElementById('status').textContent = 'Connected as ' + myId;

    // load favorite gifs
    loadFavoriteMap().then(() => {
      Object.values(msgIndex).forEach(m => {
        const key = getGifProviderKeyFromUrl(m.content || '');
        if (key) updateGifFavUI(key);
      });
    });

    // Show chat UI
    document.getElementById('chatUI').style.display = 'block';

    // Hide auth UI
    document.getElementById('authBox').style.display = 'none';

    // Show logout
    document.getElementById('logoutBtn').style.display = 'none';

    // Disable connect
    document.getElementById('connectBtn').disabled = true;
  });

  socket.addEventListener('close', (ev) => {
    document.getElementById('status').textContent = 'Disconnected';
    console.log('WS closed', ev);
  });

  socket.addEventListener('error', (ev) => {
    console.error('WS error', ev);
  });

  window.addEventListener('DOMContentLoaded', () => {
  const token = localStorage.getItem('access_token');
  const user = localStorage.getItem('username');

  if (token && user) {
    connectSocket(); // will show chatUI
  } else {
    document.getElementById('chatUI').style.display = 'none';
    document.getElementById('authBox').style.display = 'block';
  }
});


  socket.addEventListener('message', (ev) => {
    // server sends JSON payloads
    console.log('WS incoming payload:', ev.data);

    let payload;
    try {
      payload = JSON.parse(ev.data);
    } catch (e) {
      console.warn('Non-JSON message', ev.data);
      return;
    }

    if (payload.type === 'history') {
      const msgs = payload.messages || [];
      const container = document.getElementById('container');
      container.innerHTML = ''; // clear
      msgs.forEach(m => {
        if (m.deleted) return; // skip deleted messages entirely
        const node = renderMessage(m);
        showMessageElement(node);
        ensureEndSpacer(container);
      });
      return;
    }


    if (payload.type === 'message') {
      const node = renderMessage(payload);
      showMessageElement(node);
      return;
    }

    if (payload.type === 'delete') {
      const id = payload.id;
      const el = document.getElementById('msg-' + id);
      if (el) el.remove();          // remove from DOM so text shifts up
      if (msgIndex[id]) delete msgIndex[id];  // remove from index
      return;
    }

    if (payload.type === 'pin') {
      const id = payload.id;
      const msg = msgIndex[id];
      if (msg) {
        msg.pinned = payload.pinned;
        msg.pinned_by = payload.pinned_by || null;
        msg.pinned_at = payload.pinned_at || null;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'edit') {
      const id = payload.id;
      const content = payload.content;
      const edited_at = payload.edited_at;
      const msg = msgIndex[id];
      if (msg) {
        msg.content = content;
        msg.edited_at = edited_at;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'react') {
      const id = payload.id;
      const emoji = payload.emoji;
      const users = payload.users || [];
      const msg = msgIndex[id];
      if (msg) {
        msg.reactions = msg.reactions || {};
        if (!Array.isArray(users) || users.length === 0) {
          delete msg.reactions[emoji];
        } else {
          msg.reactions[emoji] = users;
        }
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'error') {
      alert('Server error: ' + (payload.error || 'unknown'));
      return;
    }

    if (payload.type === 'notice') {
      const n = document.createElement('div');
      n.textContent = payload.text;
      showMessageElement(n);
    }
  });
}


  // send on Enter (Shift+Enter for newline) â€” attach once on initial load
  (function attachEnterSend() {
    const inputEl = document.getElementById('inputText');
    
    if (!inputEl) return;
    inputEl.addEventListener('keydown', (e) => {
      // Enter without Shift -> send
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('submitButton').click();
      }
    });
  })();



  // minimal connect button behavior now calls connectSocket()
  document.getElementById('connectBtn').onclick = () => {
    connectSocket();
  };


  document.getElementById('submitButton').onclick = () => {
    const input = document.getElementById('inputText');
    const text = input.value.trim();
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      alert('Not connected');
      return;
    }
    if (!text && !replyTo) return;
    const raw = input.value.trim();
    const contentToSend = replaceAliasesInText(raw);
    socket.send(JSON.stringify({ type: 'message', content: contentToSend, reply_to: replyTo || null }));

    //const payload = { type: 'message', content: text, reply_to: replyTo || null };
    //socket.send(JSON.stringify(payload));
    input.value = '';
    
    setTimeout(()=> {
      const container= document.getElementById('container');
      const wrapper = container ? (container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper')) : null;
      if (wrapper) wrapper.scrollTop = wrapper.scrollHeight;
    }, 50);

    // reset reply UI
    replyTo = null;
    document.getElementById('replyBox').style.display = 'none';
    document.getElementById('replyPreview').textContent = '';


  };

  document.getElementById('viewPinsBtn').onclick = () => {
    const pc = document.getElementById('pinsContainer');
    if (pc.style.display === 'none') {
      //show pinned messages
      pc.innerHTML = '';
      Object.values(msgIndex).filter(m => m.pinned).forEach(m => {
        const node = renderMessage(m);
        pc.appendChild(node);
      });
      pc.style.display = 'block';
      document.getElementById('viewPinsBtn').textContent = 'Hide Pins';
    } else {
      pc.style.display = 'none';
      document.getElementById('viewPinsBtn').textContent = 'View Pins'
    }
  };

  document.getElementById('fileInput').onchange = async (e) => {
    const file = e.target.files[0];
    if (!file || !socket) return;

    const formData = new FormData();
    formData.append("file", file);

    const res = await fetch("/upload", {
      method: "POST",
      body: formData
    });

    const data = await res.json();
    socket.send(JSON.stringify({
      type: "message",
      content: data.url
    }));
  };

document.getElementById('logoutBtn').onclick = () => {
  if (socket) {
    try { socket.close(); } catch(e){}
    socket = null;
  }

  localStorage.removeItem('access_token');
  localStorage.removeItem('username');

  // Reset UI + state
  resetChatUI();

  // Hide chat UI
  document.getElementById('chatUI').style.display = 'none';

  // Show auth UI
  document.getElementById('authBox').style.display = 'block';

  document.getElementById('status').textContent = 'Logged out';

  // Hide logout
  document.getElementById('logoutBtn').style.display = 'none';

  // Enable connect
  document.getElementById('connectBtn').disabled = false;
};

  // hide logout at initial load
  const lb = document.getElementById('logoutBtn');
  if (lb) lb.style.display = 'none';

</script>
</body>
</html>