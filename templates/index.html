<!DOCTYPE html>
<html lang="en">
<head>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
    :root{
      --bg:#0f1115;
      --panel:#111216;
      --muted:#9aa0a6;
      --accent:#4f9fff;
      --text:#f6f7f9;
      --subtle:#2a2d31;
      --composer-height:84px;
      --header-height:52px;
      --stage-height: 0px;
      --typing-height: 0px;
      --msg-font-size: 15px;
      --msg-gap: 12px;
      --group-gap: 2px;
    }

    html,body {
      height:100%;
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:var(--text);
      /* IMPORTANT: force outer document not to scroll so only .chat-wrapper scrolls */
      overflow: hidden;
    }
    h1 { margin:12px; color:var(--text); font-size:20px; }

    /* Header pinned top */
    .app-header {
      position:sticky;
      top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding:8px 12px;
      background: var(--panel);
      border-bottom:1px solid rgba(255,255,255,0.03);
      z-index:30;
    }
    .header-left { display:flex; align-items:center; gap:8px; }
    .header-username { font-weight:600; color:var(--text); }
    .header-right { display:flex; align-items:center; gap:8px; }

    /* Buttons */
    .btn-small { background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; cursor:pointer; }
    .btn-primary { background:var(--accent); color:#041427; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }

    /* chat area (same) */
    .chat-wrapper {
      position: fixed;
      left: 0;
      right: 260px;
      top: calc(var(--header-height) + var(--stage-height));
      bottom: calc(var(--composer-height) + var(--typing-height) + 12px);
      padding: 12px;
      overflow: auto;
    }

    .presenceLine { color:var(--muted); font-size:12px;}
    .typingLine { color:var(--muted); font-size:12px;}

    .status-line { font-size:13px; color:var(--muted); margin-bottom:6px; }

    .messages { display:flex; flex-direction:column; gap: 0; padding-right: 64px; }

    /* default spacing between messages */
    .message + .message{
      margin-top: var(--msg-gap);
    }

    /* grouped messages: basically a newline */
    .message.continuation{
      margin-top: var(--group-gap);  /* set this to 0px or 1px */
    }

    /* Messages */
    .message{
      display:flex;
      gap:10px;
      align-items:flex-start;

      background: transparent;
      border: none;
      border-radius: 0;

      padding: 4px 8px;        /* base row padding */
      position:relative;
    }

    /* subtle row highlight on hover */
    .message:hover{
      background: rgba(255,255,255,0.03);
      filter: none;
      transform: none;
      transition: background 120ms ease;
      cursor: default;
    }

    .avatar { width:36px; height:36px; border-radius:50%; background:var(--subtle); color:var(--text); display:flex; align-items:center; justify-content:center; font-weight:700; }
    .avatar.small { width:32px; height:32px; font-size:12px; }

    .message-body { flex:1; min-width:0; padding-right: 92px; }
    .meta { display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted); margin-bottom:6px; }
    .meta .name { color:var(--text); font-weight:600; }
    .meta .time { color:var(--muted); font-size:12px; }

    .edited { color:var(--muted); font-size:12px; margin-left:6px; font-style:italic; }

    .content { color:var(--text); line-height:1.35; word-break:break-word; font-size: var(--msg-font-size); }

    /* Marked/HTML defaults add margins (especially <p>) — remove them */
    .content p{
      margin: 0;
    }

    /* Keep block elements from injecting extra vertical space */
    .content > *{
      margin-top: 0;
      margin-bottom: 0;
    }

    /* If you want lists/quotes to still have a little spacing, add it back explicitly */
    .content ul,
    .content ol{
      margin: 2px 0 0 18px;
    }

    .content blockquote,
    .content pre{
      margin: 4px 0;
    }


    .quote { background:#0c0d0f; padding:6px; border-left:3px solid #222; margin-bottom:6px; color:var(--muted); border-radius:6px; }

    .inline-edit{
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 10px;
      display: grid;
      gap: 8px;
      max-width: var(--msg-max-ch);
    }

    .inline-edit textarea{
      width: 100%;
      min-height: 84px;
      resize: vertical;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--text);
      background: rgba(0,0,0,0.12);
      outline: none;
      font-family: inherit;
      font-size: var(--msg-font-size);
      line-height: 1.35;
    }

    .inline-edit .edit-actions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }


    /* Reactions stay visible — actions hide into menu */
    .reactions button { color:var(--text); border:1px solid rgba(255,255,255,0.03); padding:4px 6px; border-radius:6px; cursor:pointer; background:transparent; }
    
    /* --- Discord-like grouping --- */
    .message.continuation{
      background: transparent;
      border: none;
      padding: 2px 8px;
      padding-top: 0;
      padding-bottom: 0;
      padding-left: 54px
    }
    .message.continuation:hover{
      filter: brightness(1.06);
      transform: translateY(-1px);
      transition: filter 120ms ease, transform 120ms ease;
      background: rgba(255,255,255,0.03);
    }
    .message.continuation .avatar{
      display:none;
    }

    .avatar.ghost{
      visibility: hidden; /* keeps alignment */
    }
    .meta.hidden{
      display:none;
    }

    /* "+" only on hover unless message already has reactions */
    .add-react-btn{
      display:none;
    }
    .message:hover .add-react-btn{
      display:inline-block;
    }
    .message.has-reactions .add-react-btn{
      display:inline-block;
    }

    /* --- Reaction tooltip (who reacted) --- */
    .reaction-tooltip{
      position: fixed;
      z-index: 20001;
      max-width: 320px;
      background: var(--panel);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 6px 8px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.6);
      font-size: 12px;
      line-height: 1.35;
      pointer-events: none;
      white-space: normal;
    }
    .reaction-btn{
      color:var(--text);
      border:1px solid rgba(255,255,255,0.03);
      padding:4px 6px;
      border-radius:6px;
      cursor:pointer;
      background:transparent;
    }

    /* --- Top-right toolbar (reactions + ellipsis) --- */
    .msg-toolbar{
      position:absolute;
      top:6px;
      right:6px;
      display:flex;
      align-items:center;
      gap:6px;

      opacity:0;
      transform: translateY(-2px);
      pointer-events:none;
      transition: opacity 120ms ease, transform 120ms ease;
    }

    /* Show toolbar when hovering OR when message has reactions */
    .message:hover .msg-toolbar,
    .message.has-reactions .msg-toolbar{
      opacity:1;
      transform:none;
      pointer-events:auto;
    }

    .reactions-inline{
      display:flex;
      gap:6px;
      align-items:center;
    }

    /* Compact reaction pills */
    .reactions-inline .reaction-btn,
    .reactions-inline .add-react-btn{
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(17,18,22,0.75);
      color: var(--text);
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 12px;
      line-height: 1.2;
      cursor: pointer;
    }

    /* Hide + unless hover OR has reactions */
    .reactions-inline .add-react-btn{ display:none; }
    .message:hover .reactions-inline .add-react-btn{ display:inline-block; }
    .message.has-reactions .reactions-inline .add-react-btn{ display:inline-block; }

    /* Actions under message are hidden (moved into contextual menu) */
    .message .msg-actions { display:none; }

    /* ellipsis button appears on hover */
    .msg-menu-btn{
      display:inline-block;
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 6px;
    }
    .msg-menu-btn:hover{
      background: rgba(255,255,255,0.03);
    }

    /* Context menu styling */
    .context-menu {
      position:absolute;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.04);
      padding:6px;
      border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,0.6);
      z-index: 10000;
      min-width:160px;
    }
    .context-menu button {
      display:block;
      width:100%;
      text-align:left;
      background:transparent;
      border:none;
      color:var(--text);
      padding:8px;
      cursor:pointer;
      border-radius:6px;
    }
    .context-menu button:hover { background:rgba(255,255,255,0.02); }

    /* Composer pinned */
    .composer {
      position:fixed;
      left:12px;
      right:12px;
      bottom:6px;
      height:var(--composer-height);
      display:flex;
      gap:8px;
      padding:10px;
      align-items:center;
      background: var(--panel);           /* solid panel */
      border:1px solid rgba(255,255,255,0.02);
      border-radius:10px;
      z-index:40;
    }
    .composer-left, .composer-right { display:flex; gap:8px; align-items:center; }
    .composer-middle { flex:1; }
    #inputText { 
      width:100%; 
      height:100%; 
      resize:none; 
      padding:10px; 
      border-radius:8px; 
      border:1px solid rgba(255,255,255,0.03); 
      color:var(--text); 
      outline:none; 
      background:transparent; 

      font-family: inherit;
      font-size: var(--msg-font-size);
      line-height: 1.35;
    }

    #typingLine {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(var(--composer-height) + 8px);
      z-index: 41;
      color: var(--muted);
      font-size: 12px;
      pointer-events: none; /* don’t intercept clicks */
      background: rgba(17,18,22,0.65);
      padding: 4px 8px;
      border-radius: 8px;
      display: inline-block;
    }

    /* pinned reply box just above composer */
    .reply-box, #replyBox {
      position:fixed;
      left:12px;
      right:12px;
      bottom: calc(var(--composer-height) + var(--typing-height) + 10px);
      background: var(--panel);
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      color:var(--text);
      z-index:42;
      display:flex;
      align-items:center;
      gap:12px;
    }

    /* highlight referenced message so user sees context */
    .message.referenced {
      outline: 2px solid rgba(79,159,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.008));
      transition: background 180ms ease, outline 180ms ease;
    }

    input[type="file"] { color:var(--text); }

    /* Pins panel */
    .pins-panel { 
      position: fixed;                 /* will be positioned by JS */
      width: min(46vw, 540px);         /* match GIF picker width */
      max-height: 52vh;
      overflow: auto;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 8px;
      z-index: 9999;
      box-shadow: 0 12px 36px rgba(0,0,0,0.6);
      display:none;
    }
    .pins-panel .pins-header{
      position: sticky;
      top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.02);
      z-index: 3;
    }
    .pins-panel .pins-body{
      padding:8px;
    }

    /* --- Voice indicators in Members list --- */
    .member-badges {
      display:flex;
      align-items:center;
      gap:6px;
      flex: 0 0 auto;
    }

    .badge {
      font-size:11px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.06);
      color: var(--text);
      background: rgba(255,255,255,0.02);
      line-height: 1.4;
      user-select:none;
    }

    .badge-voice {
      border-color: rgba(79,159,255,0.25);
      background: rgba(79,159,255,0.08);
    }

    .badge-muted {
      border-color: rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
    }

    .badge-speaking {
      border-color: rgba(61,220,132,0.30);
      background: rgba(61,220,132,0.12);
      position: relative;
    }

    .badge-speaking::after {
      content:"";
      display:inline-block;
      width:6px;
      height:6px;
      margin-left:6px;
      border-radius:50%;
      background: rgba(61,220,132,0.95);
      box-shadow: 0 0 0 0 rgba(61,220,132,0.60);
      animation: voicePulse 1.1s ease-out infinite;
    }

    @keyframes voicePulse {
      0%   { box-shadow: 0 0 0 0 rgba(61,220,132,0.55); }
      70%  { box-shadow: 0 0 0 10px rgba(61,220,132,0.00); }
      100% { box-shadow: 0 0 0 0 rgba(61,220,132,0.00); }
    }

    /* GIF picker layout & pinned header */
    #gifPicker {
      background: var(--panel);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.03);
      border-radius:8px;
      box-shadow:0 12px 36px rgba(0,0,0,0.6);
      z-index: 9999;
      overflow: hidden;

      max-width: 560px;
      width: min(46vw, 540px);

      /* IMPORTANT: lock layout so only grid scrolls */
      display: flex;
      flex-direction: column;
    }

    /* header pinned to the top of the picker (stays visible) */
    #gifPicker .picker-header {
      position: sticky;
      top: 0;
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.02);
      z-index: 3;
      flex: 0 0 auto;
    }

    /* the grid area scrolls independently */
    #gifPicker #gifGrid {
      padding: 8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;

      overflow:auto;

      flex: 1 1 auto;
      max-height: 52vh; /* will be dynamically clamped by JS too */
    }

    /* small tweak so picker right edge lines up visually with button */
    #gifPicker.align-right { transform-origin: top right; }

    .message .msg-actions {display:none; }

    /* small helpers */
    .btn-small:active, .btn-primary:active { transform:translateY(1px); }
    a { color:var(--accent); }
    .messages-end-spacer { height: calc(var(--composer-height) - 12px); flex-shrink:0; }

    #audioModal .audio-footer{
      position: sticky;
      bottom: 0;
      background: var(--panel);
      padding-top: 10px;
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.04);
    }

    #videoStage {
      position: fixed;
      left: 0;
      right: 260px;
      top: var(--header-height);
      height: var(--stage-height);
      display: none;
      gap: 8px;
      padding: 8px;
      background: rgba(0,0,0,0.15);
      z-index: 34;
      overflow: auto;
    }

    #screenStage {
      position: fixed;
      left: 0;
      right: 260px;
      top: var(--header-height);
      display: none;
      height: var(--screen-stage-height, 280px);
      grid-template-columns: 2fr 1fr;
      gap: 10px;
      align-items: stretch;
      overflow: hidden;
      z-index: 20;
    }
    .tile-box video{
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    #screenStage.theatre {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 340px;
    }

    #screenStage .theatre-bar{
      position: absolute;
      left: 8px;
      top: 8px;
      z-index: 60;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #screenStage .theatre-bar .btn-small{
      background: rgba(15,17,21,0.55);
      border: 1px solid rgba(255,255,255,0.08);
    }

    .stage-col-primary { 
      min-width: 0;
      height: 100%;
    }

    .stage-col-side {
      display: grid;
      gap: 10px;
      align-content: start;
      overflow: auto;
      max-height: var(--screen-stage-height, 280px);
    }

    .stage-tile {
      user-select: none;
      width: 240px;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .tile-box {
      position: relative;
      height: 160px;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
    }

    .tile-controls {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 6px;
      z-index: 5;
    }

    .tile-controls button,
    .tile-controls input[type="range"] {
      background: rgba(15,17,21,0.55);
      border: 1px solid rgba(255,255,255,0.08);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
    }

    .tile-controls input[type="range"] {
      width: 110px;
      padding: 0 6px;
    }

    #screenPrimary{
      display: flex;
      justify-content: center;
      min-width: 0;
    }

    #screenPrimary .stage-tile{
      width: 100%;
      height: 100%;
    }

    #screenPrimary .stage-tile .tile-box {
      flex: 1 1 auto;
      height: auto;
      min-height: 0;
    }

    #screenSide .stage-tile{
      width: 240px;
    }

    #screenSide .stage-tile .tile-box {
      height: 160px;
      flex: 0 0 auto;
    }

    #incomingCallBanner{
      position: fixed;
      left: 12px;
      right: calc(260px + 12px); /* keep sidebar clear */
      top: calc(var(--header-height) + 10px);
      z-index: 20000;
      background: rgba(17,18,22,0.92);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
    }
    #incomingCallBanner .ic-title{ font-weight: 700; }
    #incomingCallBanner .ic-sub{ color: var(--muted); font-size: 12px; margin-top: 2px; }
    #incomingCallBanner .ic-right{ display:flex; gap:8px; align-items:center; }
    </style>
</head>

<body>
  <div id="authBox" style="margin-bottom:12px;">
    <input id="authUser" placeholder="username" />
    <input id="authPass" type="password" placeholder="password" />
    <button id="authRegister">Register</button>
    <button id="authLogin">Login</button>
    <span id="authStatus" style="margin-left:8px;color:#777;"></span>
  </div>

  <div id="chatUI" style="display:none;">
    <!-- Header (pinned top after login) -->
    <header id="appHeader" class="app-header" style="display:none;">
      <div class="header-left">
        <div id="headerAvatar" class="avatar small">?</div>
        <div id="headerUsername" class="header-username"></div>
      </div>

      <div id="membersSidebar" style="
        position:fixed; top:var(--header-height); right:0; bottom:0;
        width:260px; background:var(--panel);
        border-left:1px solid rgba(255,255,255,0.03);
        padding:10px; overflow:auto; display:none; z-index:35;">
        <div style="font-weight:700; margin-bottom:8px;">Members</div>
        <div id="membersList" style="display:grid; gap:8px;"></div>
      </div>

      <div class="header-right">
        <button id="voiceBtn" class="btn-small">Voice</button>
        <button id="muteBtn" class="btn-small" style="display:none;">Mute</button>
        <button id="deafenBtn" class="btn-small" style="display:none;">Deafen</button>

        <button id="cameraBtn" class="btn-small" style="display:none;">Camera</button>
        <button id="camOffBtn" class="btn-small" style="display:none;">Stop Cam</button>

        <button id="shareBtn" class="btn-small" style="display:none;">Share Screen</button>
        <button id="stopShareBtn" class="btn-small" style="display:none;">Stop Share</button>

        <select id="shareQuality" class="btn-small" title="Share quality" style="display:none;">
          <option value="source">Source</option>
          <option value="1080p">1080p</option>
          <option value="720p" selected>720p</option>
          <option value="480p">480p</option>
        </select>

        <select id="shareFps" class="btn-small" title="Share FPS" style="display:none;">
          <option value="60">60</option>
          <option value="30" selected>30</option>
          <option value="15">15</option>
        </select>


        <button id="viewPinsBtn" class="btn-small">Pins</button>
        <button id="inviteBtn" class="btn-small">Invite</button>
        <button id="audioBtn" class="btn-small">Audio</button>
        <button id="roomsBtn" class="btn-small">Rooms</button>
        <button id="settingsBtn" class="btn-small">Settings</button>
        <button id="connectBtn" class="btn-small" style="display:none">Connect</button>
        <button id="logoutBtn" class="btn-small">Logout</button>
      </div>


      <div id="settingsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Profile</div>
            <button id="closeSettings" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:grid; gap:8px;">
            <input id="setDisplayName" placeholder="Display name" />
            <input id="setStatus" placeholder="Status (e.g. chilling)" maxlength="32" />
            <input id="setAvatarColor" placeholder="Avatar color (e.g. #4f9fff)" />
            <textarea id="setBio" placeholder="Bio" rows="3"></textarea>
            <button id="saveSettings" class="btn-primary">Save</button>
            <div id="settingsMsg" style="color:var(--muted); font-size:12px;"></div>
          </div>
        </div>
      </div>

      <div id="audioModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px; max-height: calc(100vh - 16vh); overflow:auto;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Audio Settings</div>
            <button id="closeAudio" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:grid; gap:10px;">
            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Microphone</span>
              <select id="micSelect"></select>
            </label>

            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Speaker / Output</span>
              <select id="spkSelect"></select>
              <div style="color:var(--muted); font-size:12px;">If this is empty, your browser may not support output device selection.</div>
            </label>

            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Mic Gain</span>
              <input id="micGain" type="range" min="0" max="2" step="0.05" value="1">
              <div id="micGainVal" style="color:var(--muted); font-size:12px;">1.00x</div>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optEcho" type="checkbox" checked>
              <span>Echo cancellation</span>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optNoise" type="checkbox" checked>
              <span>Noise suppression</span>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optAgc" type="checkbox" checked>
              <span>Auto gain control</span>
            </label>

            <!-- Master output -->
            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Master Output Volume</span>
              <input id="masterVol" type="range" min="0" max="1" step="0.01" value="1">
              <div id="masterVolVal" style="color:var(--muted); font-size:12px;">100%</div>
            </label>

            <!-- Voice bitrate / quality -->
            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Voice Quality (bitrate)</span>
              <select id="voiceKbps">
                <option value="32">Low (32 kbps)</option>
                <option value="64">Standard (64 kbps)</option>
                <option value="96" selected>High (96 kbps)</option>
              </select>
              <div style="color:var(--muted); font-size:12px;">Higher improves clarity but uses more bandwidth.</div>
            </label>

            <!-- Speaking sensitivity -->
            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Speaking Sensitivity</span>
              <input id="speakThresh" type="range" min="0.005" max="0.080" step="0.001" value="0.030">
              <div id="speakThreshVal" style="color:var(--muted); font-size:12px;">0.030</div>
            </label>

            <!-- Mic processing -->
            <div style="margin-top:6px; display:grid; gap:8px;">
              <div style="font-weight:600;">Mic Processing</div>

              <label style="display:flex; gap:10px; align-items:center;">
                <input id="optHPF" type="checkbox" checked>
                <span>High-pass filter (reduce rumble)</span>
              </label>

              <label style="display:flex; gap:10px; align-items:center;">
                <input id="optComp" type="checkbox" checked>
                <span>Compressor/limiter (more consistent volume)</span>
              </label>

              <label style="display:flex; gap:10px; align-items:center;">
                <input id="optGate" type="checkbox" checked>
                <span>Noise gate (reduce background)</span>
              </label>

              <label id="gateRow" style="display:grid; gap:6px;">
                <span style="color:var(--muted); font-size:12px;">Noise Gate Threshold</span>
                <input id="gateThresh" type="range" min="0.005" max="0.080" step="0.001" value="0.025">
                <div id="gateThreshVal" style="color:var(--muted); font-size:12px;">0.025</div>
              </label>
            </div>

            <!-- Mic test + meter -->
            <div style="margin-top:8px; display:flex; gap:10px; align-items:center;">
              <button id="testMicBtn" class="btn-small">Mic Test</button>

              <div style="flex:1; height:10px; background:rgba(255,255,255,0.06); border-radius:999px; overflow:hidden;">
                <div id="micMeterFill" style="height:100%; width:0%; background: var(--accent);"></div>
              </div>

              <button id="testSpkBtn" class="btn-small" title="Plays ringtone through selected output">Test Output</button>
            </div>

            <!-- Centralized mixer for remote users -->
            <div style="margin-top:12px; display:grid; gap:8px;">
              <div style="font-weight:600;">Call Mixer</div>
              <div id="remoteMixer" style="display:grid; gap:8px;"></div>
              <div style="color:var(--muted); font-size:12px;">
              </div>
            </div>

            <div class="audio-footer">
              <button id="applyAudio" class="btn-primary">Apply</button>
              <div id="audioMsg" style="color:var(--muted); font-size:12px;"></div>
            </div>

          </div>
        </div>
      </div>

      <div id="roomsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Rooms</div>
            <button id="closeRooms" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:flex; gap:8px;">
            <input id="newRoomName" placeholder="new room name" style="flex:1;" />
            <button id="createRoomBtn" class="btn-primary">Create</button>
          </div>

          <div id="roomsList" style="margin-top:12px; display:grid; gap:8px;"></div>
          <div id="roomsMsg" style="color:var(--muted); font-size:12px; margin-top:8px;"></div>
        </div>
      </div>
    </header>

    <!-- Main chat area -->
    <main class="chat-wrapper">
      <div id="status" class="status-line"></div>
      <div id="presenceLine" class="presenceLine"></div>
      <div id="container" class="messages"></div>
    </main>

    <div id="screenStage" style="
      position:fixed; left:0; right:260px;
      top:var(--header-height); height:280px;
      gap:8px; padding:8px;
      background:rgba(0,0,0,0.18);
      z-index:20; overflow:hidden;">
      <div class="stage-col-primary" id="screenPrimary"></div>
      <div class="stage-col-side" id="screenSide"></div>
    </div>

    <div id="videoStage" style="
      position:fixed; left:0; right:260px;
      top:var(--header-height); height:220px;
      display:none; gap:8px; padding:8px;
      background:rgba(0,0,0,0.15);
      z-index:20; overflow:auto;">
    </div>

    <!-- Pins panel toggled via View Pins -->
    <div id="pinsPanel" class="pins-panel" style="display:none;">
      <div class="pins-header">
        <div style="font-weight:600;">Pinned</div>
        <button id="closePins" class="btn-small">Close</button>
      </div>
      <div id="pinsContainer" class="pins-body"></div>
    </div>

    <div id="typingLine" class="typingLine"></div>

    <!-- Reply preview small area above composer -->
    <div id="replyBox" class="reply-box" style="display:none;">
      Replying to: <span id="replyPreview"></span>
      <button id="cancelReply">Cancel</button>
    </div>

    <!-- Composer (pinned to bottom) -->
    <div id="composer" class="composer">
      <div class="composer-left">
        <input id="fileInput" type="file" accept="image/*" title="Attach file" />
        
      </div>
      <div class="composer-middle">
        <textarea id="inputText" placeholder="Type a message..." rows="2"></textarea>
      </div>
      <div class="composer-right">
        <button id="gifBtn" title="GIF">GIF</button>
        <button id="submitButton" class="btn-primary">Send</button>
      </div>
    </div>

    <!-- GIF picker (positioning unchanged) -->
    <div id="gifPicker" style="display:none; position:fixed;"></div>

    <div id="voiceAudioSinks" style="display:none;"></div>

    <!-- Ringtone (put a real file at this path, or change the src) -->
    <audio id="ringTone" src="/static/sounds/ring.mp3" preload="auto" loop></audio>

    <!-- Incoming call banner -->
    <div id="incomingCallBanner" style="display:none;">
      <div class="ic-left">
        <div class="ic-title">Incoming call</div>
        <div class="ic-sub" id="incomingCallFrom">Someone is calling…</div>
      </div>
      <div class="ic-right">
        <button id="icAccept" class="btn-primary">Join</button>
        <button id="icDismiss" class="btn-small">Dismiss</button>
      </div>
    </div>

  </div>
<script>

  let socket = null;
  let myId = null;
  let replyTo = null;
  const msgIndex = {}; //id

  let EMOJI_LIST = [];
  let EMOJI_ALIASES = {};

  const userDirectory = {}; //username -> profile
  
  let unreadCount = 0;
  let windowFocused = true;

  let hasMoreHistory = true;
  let nextCursor = null;
  let loadingOlder = false;

  let micAudioCtx = null;
  let micAnalyser = null;
  let micData = null;
  let micLoopHandle = null;

  let lastSentSpeaking = null;
  let lastSpeakingFlipAt = 0;

  let soundUnlocked = false;
  let incomingFromUser = null;

  let GATE_WORKLET_URL = null;

  let micTestRAF = null;
  let micTestCtx = null;
  let micTestAnalyser = null;
  let micTestData = null;
  let micTestStream = null;

  const voice = {
    enabled: false,
    muted: false,
    localStream: null,
    pcs: new Map(),          // username -> RTCPeerConnection
    sinks: new Map(),        // username -> HTMLAudioElement
    users: new Set(),        // usernames currently in voice (from server snapshot + join/leave)
  };

  // --- Client-side audio controls (viewer-side) ---
  const audioPrefs = {
    deafened: false,
    mutedUsers: new Set(),
    userVolumes: new Map(),          // username -> volume (0..1)
    masterVolume: 1.0,
  };

  function unlockSoundsOnce() {
    if (soundUnlocked) return;
    soundUnlocked = true;

    // Try to “warm up” the audio element to satisfy autoplay policies after a user gesture.
    const a = document.getElementById('ringTone');
    if (a) {
      a.volume = 0.7;
      a.play().then(() => {
        a.pause();
        a.currentTime = 0;
      }).catch(() => {});
    }
  }

  function loadAudioPrefs() {
    try {
      const j = JSON.parse(localStorage.getItem('audio_prefs') || '{}');
      audioPrefs.deafened = !!j.deafened;
      audioPrefs.mutedUsers = new Set(Array.isArray(j.mutedUsers) ? j.mutedUsers : []);
      audioPrefs.userVolumes = new Map(Object.entries(j.userVolumes || {}).map(([k,v]) => [k, Number(v)]));
      audioPrefs.masterVolume = (typeof j.masterVolume === 'number') ? j.masterVolume : 1.0;
    } catch(e) {}
  }

  function saveAudioPrefs() {
    try {
      const obj = {
        deafened: audioPrefs.deafened,
        mutedUsers: Array.from(audioPrefs.mutedUsers),
        userVolumes: Object.fromEntries(audioPrefs.userVolumes.entries()),
        masterVolume: audioPrefs.masterVolume,
      };
      localStorage.setItem('audio_prefs', JSON.stringify(obj));
    } catch(e) {}
  }

  function applyAudioPrefsToSink(username) {
    const el = voice.sinks.get(username);
    const userMuted = audioPrefs.mutedUsers.has(username);
    const perUser = audioPrefs.userVolumes.has(username) ? audioPrefs.userVolumes.get(username) : 1;
    const master = (typeof audioPrefs.masterVolume === 'number') ? audioPrefs.masterVolume : 1;

    if (el) {
      el.muted = audioPrefs.deafened || userMuted;
      el.volume = clamp(perUser * master, 0, 1);
    }

    syncVideoTileControls(username);
  }

  function applyAudioPrefsToAllSinks() {
    for (const u of voice.sinks.keys()) applyAudioPrefsToSink(u);
  }

  function ensureGateWorkletUrl() {
    if (GATE_WORKLET_URL) return GATE_WORKLET_URL;

    const code = `
    class NoiseGateProcessor extends AudioWorkletProcessor {
      static get parameterDescriptors() {
        return [
          { name: 'threshold', defaultValue: 0.025, minValue: 0, maxValue: 1 },
          { name: 'attack', defaultValue: 0.010, minValue: 0.001, maxValue: 0.2 },
          { name: 'release', defaultValue: 0.120, minValue: 0.01, maxValue: 1.0 },
        ];
      }
      constructor() { super(); this._g = 1; }
      process(inputs, outputs, params) {
        const input = inputs[0];
        const output = outputs[0];
        if (!input || !input[0] || !output || !output[0]) return true;

        const x = input[0];
        const y = output[0];

        let sum = 0;
        for (let i = 0; i < x.length; i++) sum += x[i] * x[i];
        const rms = Math.sqrt(sum / Math.max(1, x.length));

        const thr = params.threshold[0];
        const target = (rms >= thr) ? 1 : 0;

        const attack = Math.max(0.001, params.attack[0]);
        const release = Math.max(0.01, params.release[0]);

        const tau = (target > this._g) ? attack : release;
        const coef = 1 - Math.exp(-1 / (sampleRate * tau));
        this._g += (target - this._g) * coef;

        for (let i = 0; i < x.length; i++) y[i] = x[i] * this._g;
        return true;
      }
    }
    registerProcessor('noise-gate', NoiseGateProcessor);
    `;

    GATE_WORKLET_URL = URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));
    return GATE_WORKLET_URL;
  }

  function syncVideoTileControls(username) {
    const ctrl = video.audioControls?.get(username);
    if (!ctrl) return;

    const isMuted = audioPrefs.mutedUsers.has(username);
    const vol = audioPrefs.userVolumes.has(username) ? audioPrefs.userVolumes.get(username) : 1;

    ctrl.muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    ctrl.vol.value = String(clamp(vol, 0, 1));

    const disabled = !!audioPrefs.deafened;
    ctrl.muteBtn.disabled = disabled;
    ctrl.vol.disabled = disabled;
  }

  // Toggle per-user mute (client-side)
  function toggleUserMute(username) {
    if (!username || username === myId) return;
    if (audioPrefs.mutedUsers.has(username)) audioPrefs.mutedUsers.delete(username);
    else audioPrefs.mutedUsers.add(username);

    saveAudioPrefs();
    applyAudioPrefsToSink(username);
    renderMembersSidebar();
    syncVideoTileControls(username);
  }

  // Set per-user volume (client-side)
  function setUserVolume(username, v) {
    audioPrefs.userVolumes.set(username, clamp(v, 0, 1));
    saveAudioPrefs();
    applyAudioPrefsToSink(username);
    syncVideoTileControls(username);
  }

  // Toggle global deafen
  function toggleDeafen() {
    audioPrefs.deafened = !audioPrefs.deafened;
    saveAudioPrefs();
    applyAudioPrefsToAllSinks();
    updateVoiceButtons();
    renderMembersSidebar();
  }


  window.addEventListener('focus', () => { windowFocused = true; unreadCount = 0; document.title = 'Chatterbox'});
  window.addEventListener('blur', () => { windowFocused = false; });

  window.addEventListener('pointerdown', unlockSoundsOnce, { once: true });
  window.addEventListener('keydown', unlockSoundsOnce, { once: true });

  async function fetchRoomMessagesPage(roomId, before=null, limit=50) {
    const token = getToken();
    const qs = new URLSearchParams();
    if (before) qs.set('before', before);
    qs.set('limit', String(limit));

    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/messages?` + qs.toString(), {
      headers: { token }
    });
    if (!res.ok) {
      const j = await res.json().catch(()=>({}));
      throw new Error(j.detail || `history fetch failed (${res.status})`);
    }
    return await res.json(); // {messages, has_more, next_cursor}
  }

  async function loadFavoriteMap() {
    favoriteMap = {};
    const token = getToken();
    if (!token) return;
    try {
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) return;
      const j = await res.json();
      (j.results || []).forEach(f => {
        const fid = f.id;

        if (f.gif_id) favoriteMap[String(f.gif_id)] = fid;

        if (f.url) favoriteMap[String(f.url)] = fid;

        const orig = f.metadata && f.metadata.original_gif_id;
        if (orig) favoriteMap[String(orig)] = fid;
      });
      console.log('[favorites] loaded', Object.keys(favoriteMap).length);
    } catch (e) {
      console.warn('[favorites] load failed', e);
    }
  }

  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  function uniqueNodes(arr){
    const out = [];
    const seen = new Set();
    (arr || []).forEach(n => {
      if (!n || seen.has(n)) return;
      seen.add(n);
      out.push(n);
    });
    return out;
  }

  function refreshTrayVisibility(){
    if (stageState.theatre) return;
    const tray = document.getElementById('videoStage');
    const hasAny = !!(tray && tray.children && tray.children.length > 0);
    setStageVisible(hasAny);
  }

  function handleTileSurfaceClick(wrap){
    if (!wrap) return;

    if (!stageState.theatre) {
      enterTheatre(wrap);
      return;
    }

    // theatre is on:
    if (stageState.primaryNode === wrap) {
      exitTheatre();                // clicking primary toggles OFF
    } else {
      stageState.primaryNode = wrap; // clicking any other tile promotes it
      relayoutTheatre();
    }
  }

  function appendRemoteAudioControls(username, wrap){
    if (!wrap || !username || username === myId) return;

    const controls = document.createElement('div');
    controls.style.display = 'flex';
    controls.style.gap = '8px';
    controls.style.alignItems = 'center';

    const muteBtn = document.createElement('button');
    muteBtn.className = 'btn-small';
    muteBtn.title = 'Client-side mute (you only)';
    muteBtn.onclick = (e) => { e.stopPropagation(); toggleUserMute(username); };

    const vol = document.createElement('input');
    vol.type = 'range';
    vol.min = '0';
    vol.max = '1';
    vol.step = '0.05';
    vol.title = 'Client-side volume';
    vol.oninput = (e) => { e.stopPropagation(); setUserVolume(username, parseFloat(vol.value)); };

    controls.appendChild(muteBtn);
    controls.appendChild(vol);

    // store refs so existing sync logic works
    video.audioControls.set(username, { muteBtn, vol });
    syncVideoTileControls(username);

    wrap.appendChild(controls);
  }


  function getToken() {
    const t = localStorage.getItem('access_token');
    if (!t || t === 'null' || t === 'undefined' || t.length < 20) return null;
    return t;
  }

  let ICE_CONFIG_PROMISE = null;

  async function getIceConfig() {
    if (ICE_CONFIG_PROMISE) return ICE_CONFIG_PROMISE;

    const token = getToken();
    ICE_CONFIG_PROMISE = fetch('/webrtc/ice', {
      headers: { token: token || '' }
    })
      .then(async (r) => {
        if (!r.ok) throw new Error('ICE fetch failed: ' + r.status);
        return await r.json();
      })
      .catch((e) => {
        console.warn('[webrtc] using STUN-only fallback (ICE fetch failed)', e);
        return { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] };
      });

    return ICE_CONFIG_PROMISE;
  }


  function getBottomSafeY() {
    const composer = document.getElementById('composer');
    const replyBox = document.getElementById('replyBox');
    const typingLine = document.getElementById('typingLine');

    let bottom = window.innerHeight - 8;

    if (composer) bottom = Math.min(bottom, composer.getBoundingClientRect().top - 10);
    if (typingLine && typingLine.innerHTML.trim()) bottom = Math.min(bottom, typingLine.getBoundingClientRect().top - 10);
    if (replyBox && replyBox.style.display !== 'none') bottom = Math.min(bottom, replyBox.getBoundingClientRect().top - 10);

    return bottom;
  }

  function getTopSafeY() {
    const header = document.getElementById('appHeader');
    const headerH = header && header.style.display !== 'none'
      ? header.getBoundingClientRect().height
      : 0;
    return Math.max(8, Math.round(headerH + 8));
  }

  function positionPanelUnderButton(panelEl, btnEl, preferredWidthEl=null) {
    if (!panelEl || !btnEl) return;

    panelEl.style.position = 'fixed';
    panelEl.style.display = 'block';

    // measure after display
    const btn = btnEl.getBoundingClientRect();
    const panelRect = panelEl.getBoundingClientRect();

    // width alignment: match GIF picker if desired
    if (preferredWidthEl) {
      const cs = window.getComputedStyle(preferredWidthEl);
      const w = preferredWidthEl.getBoundingClientRect().width;

      if (cs.display !== 'none' && w > 120) {
        panelEl.style.width = `${Math.round(w)}px`;
      } else {
        panelEl.style.width = '';
      }
    }

    // recompute after potential width change
    const rect = panelEl.getBoundingClientRect();

    // align right edge to button right edge (like dropdowns)
    let left = Math.round(btn.right - rect.width);
    left = clamp(left, 8, window.innerWidth - rect.width - 8);

    // place below button; if not enough room, flip above
    const belowTop = Math.round(btn.bottom + 8);
    const aboveTop = Math.round(btn.top - rect.height - 8);

    let top = belowTop;
    if (belowTop + rect.height > window.innerHeight - 8 && aboveTop >= 8) {
      top = aboveTop;
    }
    const bottomSafe = getBottomSafeY ? getBottomSafeY() : (window.innerHeight - 8);
    top = clamp(top, 8, bottomSafe - rect.height);

    panelEl.style.left = `${left}px`;
    panelEl.style.top = `${top}px`;
  }

  function prependMessages(container, wrapper, msgs) {
    if (!container || !wrapper || !msgs.length) return;

    // Record the current scroll offset from top-of-container content
    const prevScrollHeight = wrapper.scrollHeight;
    const prevScrollTop = wrapper.scrollTop;

    // Render in reverse so that final DOM order is oldest->newest at the top
    // IMPORTANT: API returns newest->oldest; we want older messages to appear above current ones
    const frag = document.createDocumentFragment();

    const toInsert = msgs.slice().reverse();
    toInsert.forEach(m => {
      if (m.deleted) return;
      msgIndex[m.id] = m;
      const node = renderMessage(m);
      frag.appendChild(node);
    });

    container.prepend(frag);

    // Keep the user at the same visible content position
    const newScrollHeight = wrapper.scrollHeight;
    wrapper.scrollTop = prevScrollTop + (newScrollHeight - prevScrollHeight);
  }

  function showIncomingBanner(fromUsername) {
    const b = document.getElementById('incomingCallBanner');
    const t = document.getElementById('incomingCallFrom');
    if (!b || !t) return;

    const display = displayNameForUser(fromUsername) || fromUsername || 'Someone';
    t.textContent = `${display} is calling…`;
    b.style.display = 'flex';
  }

  function hideIncomingBanner() {
    const b = document.getElementById('incomingCallBanner');
    if (b) b.style.display = 'none';
  }

  function startRingtone(fromUsername) {
    if (incomingFromUser) return; // already ringing
    incomingFromUser = fromUsername || 'someone';

    showIncomingBanner(incomingFromUser);

    // Optional: also use browser notifications when unfocused
    if (!windowFocused && 'Notification' in window && Notification.permission === 'granted') {
      const display = displayNameForUser(incomingFromUser) || incomingFromUser;
      new Notification('Incoming call', { body: `${display} started a voice call.` });
    }

    // Play ringtone (may require user gesture; that’s why we unlockSoundsOnce)
    const a = document.getElementById('ringTone');
    if (a) {
      a.currentTime = 0;
      a.play().catch(() => {
        // If blocked, the banner still shows; user can click Join which unlocks audio anyway.
      });
    }
  }

  function stopRingtone() {
    incomingFromUser = null;
    hideIncomingBanner();

    const a = document.getElementById('ringTone');
    if (a) {
      try { a.pause(); } catch(e) {}
      a.currentTime = 0;
    }
  }

  function getVS(username) {
    const cur = voiceState.get(username);
    if (cur) return cur;
    const init = { in_voice: false, muted: false, speaking: false };
    voiceState.set(username, init);
    return init;
  }

  function setVS(username, patch) {
    const cur = getVS(username);
    Object.assign(cur, patch);
    voiceState.set(username, cur);
  }

  function sendVoiceState(patch) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "voice_state", ...patch }));
  }

  function startMicActivityMonitor() {
    stopMicActivityMonitor();

    if (!voice.enabled || !voice.localStream) return;

    micAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = micAudioCtx.createMediaStreamSource(voice.localStream);

    micAnalyser = micAudioCtx.createAnalyser();
    micAnalyser.fftSize = 1024;
    micAnalyser.smoothingTimeConstant = 0.8;

    src.connect(micAnalyser);

    micData = new Uint8Array(micAnalyser.fftSize);

    const THRESHOLD = parseFloat(localStorage.getItem('speak_threshold') || 0.030);
    const MIN_FLIP_MS = 220;         // debounce flips
    const SEND_INTERVAL_MS = 250;    // throttle outbound state

    let lastSendAt = 0;

    function tick() {
      if (!micAnalyser || !micData) return;

      // If muted, force speaking false
      if (voice.muted) {
        maybeSend(false);
        micLoopHandle = requestAnimationFrame(tick);
        return;
      }

      micAnalyser.getByteTimeDomainData(micData);

      // Compute RMS in [0,1]
      let sum = 0;
      for (let i = 0; i < micData.length; i++) {
        const v = (micData[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / micData.length);

      const isSpeaking = rms >= THRESHOLD;
      maybeSend(isSpeaking);

      micLoopHandle = requestAnimationFrame(tick);
    }

    function maybeSend(isSpeaking) {
      const now = Date.now();

      // debounce flip
      if (lastSentSpeaking !== null && isSpeaking !== lastSentSpeaking) {
        if (now - lastSpeakingFlipAt < MIN_FLIP_MS) return;
        lastSpeakingFlipAt = now;
      }

      // throttle outbound sends
      if (now - lastSendAt < SEND_INTERVAL_MS) {
        // Still update local UI immediately (optional), but do not spam server
        setVS(myId, { speaking: isSpeaking });
        renderMembersSidebar();
        return;
      }

      if (lastSentSpeaking === null || isSpeaking !== lastSentSpeaking) {
        lastSendAt = now;
        lastSentSpeaking = isSpeaking;

        // update local immediately
        setVS(myId, { speaking: isSpeaking });
        renderMembersSidebar();

        // broadcast to room
        sendVoiceState({ speaking: isSpeaking });
      }
    }

    // mark initial state
    lastSentSpeaking = null;
    lastSpeakingFlipAt = 0;
    tick();
  }

  function stopMicActivityMonitor() {
    if (micLoopHandle) cancelAnimationFrame(micLoopHandle);
    micLoopHandle = null;

    try { micAnalyser?.disconnect(); } catch(e) {}
    micAnalyser = null;
    micData = null;

    try { micAudioCtx?.close(); } catch(e) {}
    micAudioCtx = null;

    lastSentSpeaking = null;
    lastSpeakingFlipAt = 0;
  }

  function supportsSetSinkId(el) {
    return !!(el && typeof el.setSinkId === 'function');
  }

  function activeUserId() {
    // Works even before myId is set, as long as username is in localStorage.
    return myId || localStorage.getItem('username') || '';
  }

  function ukey(k) {
    const u = activeUserId();
    return u ? `u:${u}:${k}` : `u:anon:${k}`;
  }

  function lsGet(k, fallback = null) {
    const v = localStorage.getItem(ukey(k));
    return (v === null || v === undefined) ? fallback : v;
  }

  function lsSet(k, v) {
    localStorage.setItem(ukey(k), v);
  }

  function lsDel(k) {
    localStorage.removeItem(ukey(k));
  }

  function stopMicTest() {
    if (micTestRAF) cancelAnimationFrame(micTestRAF);
    micTestRAF = null;
    try { micTestCtx?.close(); } catch(e) {}
    micTestCtx = null;
    micTestAnalyser = null;
    micTestData = null;
    if (micTestStream) {
      micTestStream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
      micTestStream = null;
    }
    const fill = document.getElementById('micMeterFill');
    if (fill) fill.style.width = '0%';
  }

  async function startMicTest() {
    stopMicTest();

    // Prefer analyzing the current outgoing stream if already in voice
    let streamToAnalyze = null;

    if (voice.enabled && voice.localStream) {
      streamToAnalyze = voice.localStream;
    } else {
      const micDeviceId = localStorage.getItem('mic_device_id') || '';
      try {
        micTestStream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: micDeviceId ? { exact: micDeviceId } : undefined }
        });
        streamToAnalyze = micTestStream;
      } catch (e) {
        alert('Mic test failed. Check microphone permissions.');
        return;
      }
    }

    micTestCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    const src = micTestCtx.createMediaStreamSource(streamToAnalyze);
    micTestAnalyser = micTestCtx.createAnalyser();
    micTestAnalyser.fftSize = 512;
    micTestAnalyser.smoothingTimeConstant = 0.8;

    src.connect(micTestAnalyser);
    micTestData = new Uint8Array(micTestAnalyser.fftSize);

    const fill = document.getElementById('micMeterFill');

    function tick() {
      if (!micTestAnalyser || !micTestData) return;
      micTestAnalyser.getByteTimeDomainData(micTestData);

      let sum = 0;
      for (let i = 0; i < micTestData.length; i++) {
        const v = (micTestData[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / micTestData.length); // ~0..1
      const pct = clamp(rms * 260, 0, 100); // scaled for visibility

      if (fill) fill.style.width = `${pct}%`;
      micTestRAF = requestAnimationFrame(tick);
    }

    tick();
  }

  async function openAudioModal() {
    const modal = document.getElementById('audioModal');
    if (!modal) return;
    modal.style.display = 'block';

    // Fill device lists
    try {
      const { mics, spks } = await listDevices();
      fillSelect(document.getElementById('micSelect'), mics, lsGet('mic_device_id', ''));
      fillSelect(document.getElementById('spkSelect'), spks, lsGet('spk_device_id', ''));
    } catch (e) {
      console.warn('[audio] enumerateDevices failed', e);
    }

    // Load values into modal
    const gain = parseFloat(lsGet('mic_gain', '1'));
    document.getElementById('micGain').value = String(gain);
    setText('micGainVal', `${gain.toFixed(2)}x`);

    document.getElementById('optEcho').checked = lsGet('opt_echo', 'true') === 'true';
    document.getElementById('optNoise').checked = lsGet('opt_noise', 'true') === 'true';
    document.getElementById('optAgc').checked  = lsGet('opt_agc', 'true') === 'true';

    // New settings
    document.getElementById('voiceKbps').value = String(lsGet('voice_kbps', '96'));

    const speakT = parseFloat(lsGet('speak_threshold', '0.030'));
    document.getElementById('speakThresh').value = String(speakT);
    setText('speakThreshVal', speakT.toFixed(3));

    const mv = (typeof audioPrefs.masterVolume === 'number') ? audioPrefs.masterVolume : 1.0;
    document.getElementById('masterVol').value = String(mv);
    setText('masterVolVal', `${Math.round(mv * 100)}%`);

    document.getElementById('optHPF').checked  = lsGet('opt_hpf', 'true') === 'true';
    document.getElementById('optComp').checked = lsGet('opt_comp', 'true') === 'true';
    document.getElementById('optGate').checked = lsGet('opt_gate', 'true') === 'true';

    const gt = parseFloat(lsGet('gate_threshold', '0.025'));
    document.getElementById('gateThresh').value = String(gt);
    setText('gateThreshVal', gt.toFixed(3));

    renderAudioMixer();
  }

  async function applyAudioSettings() {
    const micSelect = document.getElementById('micSelect');
    const spkSelect = document.getElementById('spkSelect');

    const gainEl = document.getElementById('micGain');
    const echoEl = document.getElementById('optEcho');
    const noiseEl = document.getElementById('optNoise');
    const agcEl = document.getElementById('optAgc');

    const kbpsEl = document.getElementById('voiceKbps');
    const speakEl = document.getElementById('speakThresh');

    const masterEl = document.getElementById('masterVol');

    const hpfEl = document.getElementById('optHPF');
    const compEl = document.getElementById('optComp');
    const gateEl = document.getElementById('optGate');
    const gateThrEl = document.getElementById('gateThresh');

    // Persist
    lsSet('mic_device_id', micSelect?.value || '');
    lsSet('spk_device_id', spkSelect?.value || '');

    lsSet('mic_gain', String(parseFloat(gainEl.value || '1')));
    lsSet('opt_echo', String(!!echoEl.checked));
    lsSet('opt_noise', String(!!noiseEl.checked));
    lsSet('opt_agc', String(!!agcEl.checked));

    lsSet('voice_kbps', String(parseInt(kbpsEl.value || '96', 10)));
    lsSet('speak_threshold', String(parseFloat(speakEl.value || '0.030')));

    lsSet('opt_hpf', String(!!hpfEl.checked));
    lsSet('opt_comp', String(!!compEl.checked));
    lsSet('opt_gate', String(!!gateEl.checked));
    lsSet('gate_threshold', String(parseFloat(gateThrEl.value || '0.025')));

    // Master output is viewer-side
    audioPrefs.masterVolume = clamp(parseFloat(masterEl.value || '1'), 0, 1);
    saveAudioPrefs();
    applyAudioPrefsToAllSinks();

    // Output device
    await applySpeakerSelectionToAllSinks();

    // If in a call, rebuild mic stream and replace outgoing track without tearing down the call
    if (voice.enabled) {
      try {
        const micDeviceId = lsGet('mic_device_id', '');
        const echo = lsGet('opt_echo', 'true') === 'true';
        const noise = lsGet('opt_noise', 'true') === 'true';
        const agc  = lsGet('opt_agc', 'true') === 'true';
        const gain = parseFloat(lsGet('mic_gain', '1'));

        const hpf  = lsGet('opt_hpf', 'true') === 'true';
        const comp = lsGet('opt_comp', 'true') === 'true';
        const gate = lsGet('opt_gate', 'true') === 'true';
        const gateThreshold = parseFloat(lsGet('gate_threshold', '0.025'));

        const out = await buildOutgoingAudioStream({ micDeviceId, echo, noise, agc, gain, hpf, comp, gate, gateThreshold });
        voice.localStream = out;

        const newTrack = out.getAudioTracks()[0];
        if (newTrack) await replaceOutgoingAudioTrackOnPeers(newTrack);

        await applyAudioParamsOnAllPeers();
        startMicActivityMonitor(); // picks up new speak_threshold

        document.getElementById('audioMsg').textContent = 'Applied (live).';
      } catch (e) {
        console.error('[audio] apply failed', e);
        document.getElementById('audioMsg').textContent = 'Apply failed. Check mic permissions.';
      }
    } else {
      document.getElementById('audioMsg').textContent = 'Saved.';
    }
  }

  function portalToBody(id) {
    const el = document.getElementById(id);
    if (el && el.parentElement !== document.body) {
      document.body.appendChild(el); // moves the node, preserves listeners
    }
  }

  async function listDevices() {
    // You generally only get full labels after permission is granted once.
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === 'audioinput');
    const spks = devices.filter(d => d.kind === 'audiooutput');
    return { mics, spks };
  }

  function fillSelect(selectEl, items, selectedId) {
    selectEl.innerHTML = '';
    items.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `${d.kind} (${d.deviceId.slice(0,6)}...)`;
      if (selectedId && d.deviceId === selectedId) opt.selected = true;
      selectEl.appendChild(opt);
    });
  }

  function setPinsButtonState(isOpen) {
    const btn = document.getElementById('viewPinsBtn');
    if (!btn) return;
    btn.textContent = isOpen ? 'Hide Pins' : 'Pins';
  }

  function getGifProviderKeyFromResult(g) {
    return String(g.id || g.gif_id || g.url || '');
  }
  function getGifProviderKeyFromUrl(url) {
    return String(url || '');
  }

  function updateGifFavUI(gifKey) {
    // update gif picker thumbs
    document.querySelectorAll('[data-gif-id]').forEach(el => {
      if (el.dataset.gifId !== gifKey) return;
      const btn = el.querySelector('.fav-btn');
      if (!btn) return;
      const favId = favoriteMap[gifKey];
      btn.textContent = favId ? '♥' : '♡';
      btn.title = favId ? 'Unfavorite' : 'Favorite';
    });

    // update chat messages that show this gif
    Object.values(msgIndex).forEach(m => {
      const content = (m.content || '').toString();
      const key = getGifProviderKeyFromUrl(content);
      if (key !== gifKey) return;
      const el = document.getElementById('msg-' + m.id);
      if (!el) return;
      const favBtn = el.querySelector('.gif-fav-btn');
      if (!favBtn) return;
      const favId = favoriteMap[gifKey];
      favBtn.textContent = favId ? '♥' : '♡';
      favBtn.title = favId ? 'Unfavorite' : 'Favorite';
    });
  } 

  function removeFavoriteEntriesById(fid) {
    const sid = String(fid);
    Object.keys(favoriteMap).forEach(k => {
      if (String(favoriteMap[k]) === sid) delete favoriteMap[k];
    });
  }


 // cache-busting + diagnostics
  fetch('/static/emojis.json?ts=' + Date.now(), {cache: 'no-store'})
    .then(async res => {
      console.log('[emoji] fetch status', res.status, res.headers.get('cache-control'));
      if (!res.ok) throw new Error('Failed to fetch emojis.json: ' + res.status);
      const data = await res.json();
      console.log('[emoji] raw data length', Array.isArray(data) ? data.length : 'not-array', data.slice ? data.slice(0,5) : null);
      EMOJI_LIST = data.map(item => item.char).filter(Boolean);
      EMOJI_ALIASES = {};
      data.forEach(item => {
        const ch = item.char;
        (item.aliases || []).forEach(a => {
          EMOJI_ALIASES[a.toLowerCase()] = ch;
        });
      });
      console.log('[emoji] processed', EMOJI_LIST.length, 'chars,', Object.keys(EMOJI_ALIASES).length, 'aliases');
    })
    .catch(err => {
      console.warn('Could not load emojis.json:', err);
    });


  let favoriteMap = {}; // gif_provider_id -> favorite_row_id

  window._referencedMsgId = null;

  function clearReferencedHighlight() {
    if (window._referencedMsgId) {
      const prev = document.getElementById('msg-' + window._referencedMsgId);
      if (prev) prev.classList.remove('referenced');
      window._referencedMsgId = null;
    }
  }

  function highlightReferencedMsg(id) {
    clearReferencedHighlight();
    const el = document.getElementById('msg-' + id);
    if (el) {
      el.classList.add('referenced');
      window._referencedMsgId = id;
    }
  }
  
  function isContainerNearBottom(wrapperEl, threshold = 60) {
    // threshold in px
    return (wrapperEl.scrollHeight - wrapperEl.scrollTop - wrapperEl.clientHeight) <= threshold;
  }

  function scrollWrapperToBottom(wrapperEl) {
    wrapperEl.scrollTop = wrapperEl.scrollHeight;
  }

  function ensureEndSpacer(container){

    if (!container) return;
    const last = container.lastElementChild;
    if (!last || !last.classList || !last.classList.contains('messages-end-spacer')) {
      const spacer = document.createElement('div');
      spacer.className = 'messages-end-spacer';
      container.appendChild(spacer);
    }
  }

  function showAppUI() {
    const authBox = document.getElementById('authBox');
    const chatUI = document.getElementById('chatUI');
    const header = document.getElementById('appHeader');
    const logoutBtn = document.getElementById('logoutBtn');

    if (authBox) authBox.style.display = 'none';
    if (chatUI) chatUI.style.display = 'block';
    if (header) header.style.display = 'flex';
    if (logoutBtn) logoutBtn.style.display = 'inline-block';
  }

  function showAuthUI() {
    const authBox = document.getElementById('authBox');
    const chatUI = document.getElementById('chatUI');
    const header = document.getElementById('appHeader');
    const logoutBtn = document.getElementById('logoutBtn')

    if (authBox) authBox.style.display = 'block';
    if (chatUI) chatUI.style.display = 'none';
    if (header) header.style.display = 'none';
    if (logoutBtn) logoutBtn.style.display = 'none';
  }

  function attachInfiniteScroll() {
    const wrapper = document.querySelector('.chat-wrapper');
    const container = document.getElementById('container');
    if (!wrapper || !container) return;

    wrapper.addEventListener('scroll', async () => {
      if (loadingOlder || !hasMoreHistory) return;
      if (wrapper.scrollTop > 60) return; // only when near top

      const roomId = localStorage.getItem('room_id');
      if (!roomId || !nextCursor) return;

      loadingOlder = true;
      try {
        const page = await fetchRoomMessagesPage(roomId, nextCursor, 50);
        const msgs = page.messages || [];
        hasMoreHistory = !!page.has_more;
        nextCursor = page.next_cursor || nextCursor;

        prependMessages(container, wrapper, msgs);
      } catch (e) {
        console.warn('load older failed', e);
      } finally {
        loadingOlder = false;
      }
    });
  }

  function showMessageElement(el) {
    const container = document.getElementById('container');
    if (!container) {
      document.body.appendChild(el);
      return;
    }

    const wrapper = container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper') || container;
    const wasNearBottom = isContainerNearBottom(wrapper, 50);

    // remove previous spacer before appending so we always append messages before spacer
    const existingSpacer = container.querySelector('.messages-end-spacer');
    if (existingSpacer) existingSpacer.remove();

    container.appendChild(el);
    // re-add spacer at the end
    ensureEndSpacer(container);

    if (wasNearBottom) {
      setTimeout(() => scrollWrapperToBottom(wrapper), 8);
    }
  }

  function shouldInitiateOffer(me, other) {
    // Deterministic rule prevents glare:
    // only the lexicographically smaller username creates the offer.
    return String(me) < String(other);
  }


  function ensureAudioSink(username) {
    const holder = document.getElementById("voiceAudioSinks");
    holder.style.display = "block";

    let el = voice.sinks.get(username);
    if (el) return el;

    el = document.createElement("audio");
    el.autoplay = true;
    el.playsInline = true;
    el.dataset.user = username;
    holder.appendChild(el);

    voice.sinks.set(username, el);

    applyAudioPrefsToSink(username);
    return el;
  }

  function removeAudioSink(username) {
    const el = voice.sinks.get(username);
    if (el) {
      try { el.remove(); } catch(e) {}
      voice.sinks.delete(username);
    }
  }

  function closePeer(username) {
    const pc = voice.pcs.get(username);
    if (pc) {
      try { pc.onicecandidate = null; pc.ontrack = null; } catch(e) {}
      try { pc.close(); } catch(e) {}
      voice.pcs.delete(username);
    }
    removeAudioSink(username);
  }

  function sendVoiceSignal(to, data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "voice_signal", to, data }));
  }

  function requestRenegotiate(peerUsername) {
    sendVoiceSignal(peerUsername, { kind: "renegotiate" });
  }

  async function applyAudioSenderParams(pc, maxKbps = 96) {
    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
    if (!sender || typeof sender.getParameters !== 'function') return;

    const params = sender.getParameters();
    if (!params.encodings || !params.encodings.length) params.encodings = [{}];

    params.encodings[0].maxBitrate = clamp(Number(maxKbps || 96), 24, 192) * 1000;

    try { await sender.setParameters(params); } catch (e) {
      console.warn('[webrtc] setParameters(audio) failed', e);
    }
  }

  async function applyAudioParamsOnAllPeers() {
    const kbps = Number(lsGet('voice_kbps', '96'));
    for (const [, pc] of voice.pcs.entries()) {
      await applyAudioSenderParams(pc, kbps);
    }
  }

  async function ensurePeerConnection(peerUsername) {
    if (voice.pcs.has(peerUsername)) return voice.pcs.get(peerUsername);

    const ice = await getIceConfig();
    const pc = new RTCPeerConnection({
      ...ice,
      iceCandidatePoolSize: 4,     // helps ICE start faster in many cases
    });

    // Add our mic tracks
    if (voice.localStream) {
      voice.localStream.getTracks().forEach(t => pc.addTrack(t, voice.localStream));
      await applyAudioSenderParams(pc, 64);
    }

    // If camera is already enabled, add the video track to this new peer connection too
    if (video.enabled && video.localStream) {
      video.localStream.getTracks().forEach(t => pc.addTrack(t, video.localStream));
    }

    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        sendVoiceSignal(peerUsername, { kind: "ice", candidate: ev.candidate });
      }
    };

    pc.ontrack = (ev) => {
      const [stream] = ev.streams;
      if (!stream) return;

      if (ev.track.kind === 'audio') {
        const sink = ensureAudioSink(peerUsername);

        // Maintain a single MediaStream per peer sink and append tracks into it.
        let ms = sink.srcObject instanceof MediaStream ? sink.srcObject : null;
        if (!ms) {
          ms = new MediaStream();
          sink.srcObject = ms;
        }
        if (!ms.getTracks().some(t => t.id === ev.track.id)) {
          ms.addTrack(ev.track);
        }

        const spkId = localStorage.getItem('spk_device_id') || '';
        if (spkId && supportsSetSinkId(sink)) {
          sink.setSinkId(spkId).catch(()=>{});
        }
      }

      if (ev.track.kind === 'video') {
        const vs = getVS(peerUsername);
        const isScreen = !!vs.screen; // new field

        if (isScreen) {
          const tile = ensureScreenTile(peerUsername, false);
          if (tile) {
            tile.srcObject = stream;
            showScreenOverlay(peerUsername, false);
          }
        } else {
          const tile = ensureVideoTile(peerUsername, false);
          if (tile) {
            tile.srcObject = stream;
            showVideoOverlay(peerUsername, false);
          }
        }

        ev.track.addEventListener('ended', () => {
          if (isScreen) {
            showScreenOverlay(peerUsername, true);
            removeScreenTile(peerUsername);
          } else {
            showVideoOverlay(peerUsername, true);
          }
        });
      }
    };

    pc.onconnectionstatechange = () => {
      const st = pc.connectionState;
      if (st === "failed" || st === "closed" || st === "disconnected") {
        // do not aggressively tear down on transient "disconnected" if you want resilience;
        // for MVP, tear down on failed/closed:
        if (st === "failed" || st === "closed") {
          closePeer(peerUsername);
        }
      }
    };

    pc.oniceconnectionstatechange = () => {
      const st = pc.iceConnectionState;
      if (st === 'failed') {
        iceRestart(peerUsername);
      }
    };

    pc.onnegotiationneeded = async () => {
      if (!shouldInitiateOffer(myId, peerUsername)) return;

      try {
        await createAndSendOffer(peerUsername);
      } catch (e) {
        console.warn("[webrtc] negotiationneeded offer failed", peerUsername, e);
      }
    };

    voice.pcs.set(peerUsername, pc);
    return pc;
  }

  async function renegotiateWithAllPeers() {
    if (!voice.enabled) return;

    for (const u of voice.users) {
      if (!u || u === myId) continue;

      // If I'm the deterministic offerer, I can create the offer directly.
      if (shouldInitiateOffer(myId, u)) {
        try { await createAndSendOffer(u); } catch (e) { console.warn('renegotiate offer failed', u, e); }
      } else {
        // I'm NOT the offerer for this pair; ask the offerer to renegotiate.
        requestRenegotiate(u);
      }
    }
  }

  async function startCamera() {
    if (video.enabled) return;
    if (!voice.enabled) {
      alert('Join Voice first (audio call). Then enable Camera.');
      return;
    }

    const attempts = [
      { video: { width: 640, height: 360, frameRate: 24 } },
      { video: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { ideal: 24 } } },
      { video: true }
    ];

    let stream = null;
    let lastErr = null;

    for (const constraints of attempts) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        break;
      } catch (e) {
        lastErr = e;
        console.warn('[camera] getUserMedia failed with', constraints, e.name, e.message);
      }
    }

    if (!stream) {
      const e = lastErr || new Error('Unknown camera error');
      alert(`Camera failed: ${e.name}\n${e.message}\n\nCommon fixes:\n- Close other apps using camera\n- Allow camera permission for this site\n- Try http://localhost:8000`);
      throw e;
    }

    video.localStream = stream;
    video.enabled = true;

    sendVoiceState({ video: true });

    const localTile = ensureVideoTile(myId, true);
    if (localTile) {
      localTile.srcObject = stream;
      showVideoOverlay(myId, false);
    }

    const vtrack = stream.getVideoTracks()[0];

    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) await sender.replaceTrack(vtrack);
      else pc.addTrack(vtrack, stream);
    }

    document.getElementById('cameraBtn').style.display = 'none';
    document.getElementById('camOffBtn').style.display = 'inline-block';

    await renegotiateWithAllPeers();
    updateCallControlsVisibility();
  }


  function setStageVisible(on) {
    if (stageState.theatre) return;

    const stage = document.getElementById('videoStage');
    if (!stage) return;

    if (on) {
      document.documentElement.style.setProperty('--stage-height', '220px');
      stage.style.display = 'flex';
    } else {
      document.documentElement.style.setProperty('--stage-height', '0px');
      stage.style.display = 'none';
    }
  }


  function stopCamera() {
    if (!video.enabled) return;

    // stop local track
    if (video.localStream) {
      video.localStream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
      video.localStream = null;
    }

    // remove video sender tracks from PCs
    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        try { pc.removeTrack(sender); } catch(e) {}
      }
    }

    const localTile = ensureVideoTile(myId, true);
    if (localTile) {
      try { localTile.srcObject = null; } catch(e){}
      showVideoOverlay(myId, true);
    }

    video.enabled = false;

    sendVoiceState({ video: false });

    document.getElementById('cameraBtn').style.display = 'inline-block';
    document.getElementById('camOffBtn').style.display = 'none';

    // Renegotiate to remove video from SDP
    renegotiateWithAllPeers().catch(()=>{});
    updateCallControlsVisibility();
  }


  async function createAndSendOffer(peerUsername) {
    const pc = await ensurePeerConnection(peerUsername);
    const offer = await pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: true
    });
    await pc.setLocalDescription(offer);
    sendVoiceSignal(peerUsername, { kind: "offer", sdp: pc.localDescription });
  }

  async function handleIncomingOffer(from, sdp) {
    const pc = await ensurePeerConnection(from);
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));

    // flush pending ICE
    const arr = pendingIce.get(from) || [];
    pendingIce.delete(from);
    for (const c of arr) {
      try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {}
    }

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendVoiceSignal(from, { kind: "answer", sdp: pc.localDescription });
    }

    async function handleIncomingAnswer(from, sdp) {
      const pc = await ensurePeerConnection(from);
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    }

    async function handleIncomingIce(from, candidate) {
      const pc = await ensurePeerConnection(from);

      if (!pc.remoteDescription) {
        const arr = pendingIce.get(from) || [];
        arr.push(candidate);
        pendingIce.set(from, arr);
        return;
      }
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    }

  function updateVoiceButtons() {
    const voiceBtn = document.getElementById("voiceBtn");
    const muteBtn = document.getElementById("muteBtn");
    const deafenBtn = document.getElementById("deafenBtn");
    if (!voiceBtn || !muteBtn || !deafenBtn) return;

    voiceBtn.textContent = voice.enabled ? "Leave Voice" : "Voice";
    muteBtn.style.display = voice.enabled ? "inline-block" : "none";
    deafenBtn.style.display = voice.enabled ? "inline-block" : "none";

    muteBtn.textContent = voice.muted ? "Unmute" : "Mute";
    deafenBtn.textContent = audioPrefs.deafened ? "Undeafen" : "Deafen";
    updateCallControlsVisibility();
  }

  function updateCallControlsVisibility() {
    const cameraBtn    = document.getElementById("cameraBtn");
    const camOffBtn    = document.getElementById("camOffBtn");
    const shareBtn     = document.getElementById("shareBtn");
    const stopShareBtn = document.getElementById("stopShareBtn");
    const shareQuality = document.getElementById("shareQuality");
    const shareFps     = document.getElementById("shareFps");

    if (!cameraBtn || !camOffBtn || !shareBtn || !stopShareBtn || !shareQuality || !shareFps) return;

    // Only show any of these while in voice
    if (!voice.enabled) {
      cameraBtn.style.display = "none";
      camOffBtn.style.display = "none";
      shareBtn.style.display = "none";
      stopShareBtn.style.display = "none";
      shareQuality.style.display = "none";
      shareFps.style.display = "none";
      return;
    }

    // In voice:
    // Camera controls
    if (video.enabled) {
      cameraBtn.style.display = "none";
      camOffBtn.style.display = "inline-block";
    } else {
      cameraBtn.style.display = "inline-block";
      camOffBtn.style.display = "none";
    }

    // Screen share controls (mutually exclusive with camera per your logic)
    if (screenShare.enabled) {
      shareBtn.style.display = "none";
      stopShareBtn.style.display = "inline-block";
    } else {
      shareBtn.style.display = "inline-block";
      stopShareBtn.style.display = "none";
    }

    // Only show quality/fps controls when user can act on them (in voice and not currently sharing)
    // (If you prefer, show these even while sharing; just remove the !screenShare.enabled condition.)
    const showShareSettings = voice.enabled && !screenShare.enabled;
    shareQuality.style.display = showShareSettings ? "inline-block" : "none";
    shareFps.style.display     = showShareSettings ? "inline-block" : "none";
  }

  async function joinVoice() {
    stopRingtone();
    if (voice.enabled) return;

    const micDeviceId = localStorage.getItem('mic_device_id') || '';
    const echo = (localStorage.getItem('opt_echo') ?? 'true') === 'true';
    const noise = (localStorage.getItem('opt_noise') ?? 'true') === 'true';
    const agc  = (localStorage.getItem('opt_agc') ?? 'true') === 'true';
    const gain = parseFloat(localStorage.getItem('mic_gain') || '1');
    const hpf  = (localStorage.getItem('opt_hpf') ?? 'true') === 'true';
    const comp = (localStorage.getItem('opt_comp') ?? 'true') === 'true';
    const gate = (localStorage.getItem('opt_gate') ?? 'true') === 'true';
    const gateThreshold = parseFloat(localStorage.getItem('gate_threshold') || '0.025');

    const outAudio = await buildOutgoingAudioStream({
      micDeviceId, echo, noise, agc, gain,
      hpf, comp, gate, gateThreshold
    });

    voice.localStream = outAudio;

    voice.enabled = true;
    voice.muted = false;
    updateVoiceButtons();

    const myTile = ensureVideoTile(myId, true);
    if (myTile) {
      try { myTile.srcObject = null; } catch(e) {}
      showVideoOverlay(myId, true); // show placeholder avatar
    }


    setVS(myId, { in_voice: true, muted: false, speaking: false });
    sendVoiceState({ muted: false, speaking: false });

    startMicActivityMonitor();
    renderMembersSidebar();

    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "voice_join" }));
    }
  }


  async function buildOutgoingAudioStream({
    micDeviceId,
    echo,
    noise,
    agc,
    gain,
    hpf,
    comp,
    gate,
    gateThreshold
  }) {
    if (audioGraph.rawStream) {
      audioGraph.rawStream.getTracks().forEach(t => { try{ t.stop(); } catch(e){} });
    }
    teardownAudioGraph();

    const base = {
      deviceId: micDeviceId ? { exact: micDeviceId } : undefined,
      echoCancellation: !!echo,
      noiseSuppression: !!noise,
      autoGainControl: !!agc,
    };

    const attempts = [
      { audio: { ...base, channelCount: 1, sampleRate: { ideal: 48000 }, sampleSize: 16 } },
      { audio: { ...base } },
      { audio: true }
    ];

    let raw = null;
    let lastErr = null;
    for (const c of attempts) {
      try {
        raw = await navigator.mediaDevices.getUserMedia(c);
        break;
      } catch (e) {
        lastErr = e;
        console.warn('[audio] getUserMedia failed with', c, e.name, e.message);
      }
    }
    if (!raw) throw (lastErr || new Error('getUserMedia(audio) failed'));

    const ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    const src = ctx.createMediaStreamSource(raw);

    let node = src;

    let hpfNode = null;
    if (hpf) {
      hpfNode = ctx.createBiquadFilter();
      hpfNode.type = 'highpass';
      hpfNode.frequency.value = 80;     // voice-friendly rumble cut
      hpfNode.Q.value = 0.707;
      node.connect(hpfNode);
      node = hpfNode;
    }

    let gateNode = null;
    if (gate && ctx.audioWorklet) {
      try {
        await ctx.audioWorklet.addModule(ensureGateWorkletUrl());
        gateNode = new AudioWorkletNode(ctx, 'noise-gate', {
          parameterData: {
            threshold: clamp(Number(gateThreshold || 0.025), 0.001, 1),
            attack: 0.010,
            release: 0.120,
          }
        });
        node.connect(gateNode);
        node = gateNode;
      } catch (e) {
        console.warn('[audio] gate worklet unavailable; continuing without gate', e);
      }
    }

    let compNode = null;
    if (comp) {
      compNode = ctx.createDynamicsCompressor();
      compNode.threshold.value = -18;
      compNode.knee.value = 12;
      compNode.ratio.value = 3;
      compNode.attack.value = 0.003;
      compNode.release.value = 0.250;

      node.connect(compNode);
      node = compNode;
    }

    const gainNode = ctx.createGain();
    gainNode.gain.value = (typeof gain === 'number' ? gain : 1);

    const dest = ctx.createMediaStreamDestination();
    node.connect(gainNode);
    gainNode.connect(dest);

    audioGraph = { ctx, src, gainNode, dest, rawStream: raw, outStream: dest.stream, hpfNode, gateNode, compNode };
    return dest.stream;
  }

  async function replaceOutgoingAudioTrackOnPeers(newAudioTrack) {
    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
      if (sender) {
        await sender.replaceTrack(newAudioTrack);
      } else {
        // if connection existed but had no sender yet
        pc.addTrack(newAudioTrack, voice.localStream);
      }
    }
  }

  async function iceRestart(peerUsername) {
    const pc = voice.pcs.get(peerUsername);
    if (!pc) return;

    // Only the deterministic offerer should initiate the ICE-restart offer
    if (!shouldInitiateOffer(myId, peerUsername)) {
      requestRenegotiate(peerUsername);
      return;
    }

    try {
      pc.restartIce?.();
      const offer = await pc.createOffer({ iceRestart: true, offerToReceiveAudio: true, offerToReceiveVideo: true });
      await pc.setLocalDescription(offer);
      sendVoiceSignal(peerUsername, { kind: "offer", sdp: pc.localDescription });
      console.log('[webrtc] ICE restart offer sent to', peerUsername);
    } catch (e) {
      console.warn('[webrtc] ICE restart failed for', peerUsername, e);
    }
  }

  function leaveVoice() {
    if (!voice.enabled) return;
    try { if (stageState.theatre) exitTheatre(); } catch(e) {}
    try { stopCamera(); } catch(e) {}

    // inform room
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "voice_leave" }));
    }

    // close peers
    Array.from(voice.pcs.keys()).forEach(u => closePeer(u));
    voice.users.clear();

    // stop mic
    if (voice.localStream) {
      voice.localStream.getTracks().forEach(t => { try { t.stop(); } catch(e) {} });
      voice.localStream = null;
    }

    // stop speaking monitor and clear local UI state
    stopMicActivityMonitor();
    setVS(myId, { in_voice: false, muted: false, speaking: false });
    sendVoiceState({ muted: false, speaking: false });
    renderMembersSidebar();


    voice.enabled = false;
    voice.muted = false;
    updateVoiceButtons();

    const holder = document.getElementById("voiceAudioSinks");
    if (holder) holder.style.display = "none";

    for (const u of Array.from(video.tiles.keys())) {
      removeVideoTile(u);
    }
    video.tiles.clear();
    video.overlays.clear();
    audioPrefs.deafened = false;
    saveAudioPrefs();

    setStageVisible(false);
  }

  function toggleMute() {
    if (!voice.enabled || !voice.localStream) return;
    voice.muted = !voice.muted;
    voice.localStream.getAudioTracks().forEach(t => t.enabled = !voice.muted);
    updateVoiceButtons();

    // update local and broadcast
    setVS(myId, { muted: voice.muted, speaking: false });
    sendVoiceState({ muted: voice.muted, speaking: false });
    renderMembersSidebar();
  }

  async function startScreenShare(){
    if (screenShare.enabled) return;
    if (!voice.enabled) {
      alert('Join Voice first. Then start screen share.');
      return;
    }

    // If camera is active, stop it (mutually exclusive for now).
    if (video.enabled) stopCamera();

    let stream = null;
    try {
      const { fps, w, h } = getSharePrefs();

      stream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          frameRate: fps ? { ideal: fps, max: fps } : 30,
          width:  w ? { ideal: w } : undefined,
          height: h ? { ideal: h } : undefined,
        },
        audio: true   // IMPORTANT: enables “share tab audio” where supported
      });
    } catch(e) {
      alert('Screen share was blocked or cancelled.\n\nNote: requires HTTPS or localhost.');
      return;
    }

    const { kbps } = getSharePrefs();
    const vtrack = stream.getVideoTracks()[0];
    if (vtrack) {
      try {
        const { fps, w, h } = getSharePrefs();
        await vtrack.applyConstraints({
          frameRate: fps ? { ideal: fps, max: fps } : undefined,
          width:  w ? { ideal: w } : undefined,
          height: h ? { ideal: h } : undefined,
        });
      } catch(e) {}
    }

    // Apply bitrate cap per peer sender
    for (const [, pc] of voice.pcs.entries()) {
      await applyVideoSenderParams(pc, kbps);
    }

    const track = stream.getVideoTracks()[0];
    if (!track) return;

    screenShare.localStream = stream;

    const screenAudio = stream.getAudioTracks()[0] || null;
    screenShare.audioTrack = screenAudio || null;

    // Add screenshare audio as an additional audio track (mic remains separate)
    if (screenAudio) {
      for (const [, pc] of voice.pcs.entries()) {
        try { pc.addTrack(screenAudio, stream); } catch(e) {}
      }
    }

    screenShare.enabled = true;

    // Notify server/UI state
    sendVoiceState({ screen: true, video: false });

    // Render local screen tile
    const localTile = ensureScreenTile(myId, true);
    if (localTile) {
      removeVideoTile(myId)
      localTile.srcObject = stream;
      showScreenOverlay(myId, false);
      
    }

    // If user stops sharing via browser UI, clean up
    track.onended = () => stopScreenShare();

    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) await sender.replaceTrack(track);
      else pc.addTrack(track, stream);

      // IMPORTANT: now the sender exists, so the cap actually applies
      await applyVideoSenderParams(pc, kbps);
    }

    document.getElementById('shareBtn').style.display = 'none';
    document.getElementById('stopShareBtn').style.display = 'inline-block';

    await renegotiateWithAllPeers();
    updateCallControlsVisibility();
  }

  function getSharePrefs() {
    const q = (document.getElementById('shareQuality')?.value || '720p');
    const fps = parseInt(document.getElementById('shareFps')?.value || '30', 10);

    // conservative bitrate caps for a mesh call
    const preset = {
      source: { w: null,  h: null,  kbps: 3500 },
      "1080p": { w: 1920, h: 1080, kbps: 3500 },
      "720p":  { w: 1280, h: 720,  kbps: 1800 },
      "480p":  { w: 854,  h: 480,  kbps: 900  },
    }[q] || { w: 1280, h: 720, kbps: 1800 };

    return { quality: q, fps, ...preset };
  }

  async function applyVideoSenderParams(pc, maxKbps) {
    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
    if (!sender || typeof sender.getParameters !== 'function') return;

    const params = sender.getParameters();
    if (!params.encodings || !params.encodings.length) params.encodings = [{}];

    // cap bitrate
    params.encodings[0].maxBitrate = Math.max(100, maxKbps) * 1000;

    // prioritize keeping audio stable by allowing video to degrade gracefully
    // (browser may ignore, but often helps)
    params.degradationPreference = 'balanced';

    try { await sender.setParameters(params); } catch (e) {
      console.warn('[webrtc] setParameters(video) failed', e);
    }
  }

  function stopScreenShare(){
    if (!screenShare.enabled) return;

    if (screenShare.audioTrack) {
      for (const [, pc] of voice.pcs.entries()) {
        const s = pc.getSenders().find(x => x.track && x.track.id === screenShare.audioTrack.id);
        if (s) { try { pc.removeTrack(s); } catch(e) {} }
      }
      screenShare.audioTrack = null;
    }

    if (screenShare.localStream) {
      screenShare.localStream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
      screenShare.localStream = null;
    }

    // Clear local tile
    const localTile = ensureScreenTile(myId, true);
    if (localTile) {
      try { localTile.srcObject = null; } catch(e){}
      showScreenOverlay(myId, true);
    }
    removeScreenTile(myId);

    screenShare.enabled = false;

    if (voice.enabled) {
      ensureVideoTile(myId, true);
      showVideoOverlay(myId, !video.enabled); // if camera isn't enabled, show overlay
    }

    sendVoiceState({ screen: false });

    document.getElementById('shareBtn').style.display = 'inline-block';
    document.getElementById('stopShareBtn').style.display = 'none';

    // Remove video sender track entirely; renegotiate.
    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        try { pc.removeTrack(sender); } catch(e){}
      }
    }

    renegotiateWithAllPeers().catch(()=>{});
    updateCallControlsVisibility();
  }


  function renderMessage(msg, isLocalEcho=false, prevMsg=null) {
    // if message flagged deleted, skip rendering (safety)
    if (msg.deleted) return document.createElement('div');

    msgIndex[msg.id] = msg;

    const wrapper = document.createElement('div');
    wrapper.className = 'message';
    wrapper.id = 'msg-' + msg.id;

    const toolbar = document.createElement('div');
    toolbar.className = 'msg-toolbar';

    const reactionsInline = document.createElement('div');
    reactionsInline.className = 'reactions-inline';

    toolbar.appendChild(reactionsInline);

    // --- grouping logic (discord-like) ---
    const grouped = isGroupedContinuation(prevMsg, msg);
    if (grouped) wrapper.classList.add('continuation');

    // avatar
    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.textContent = (msg.author && msg.author[0]) ? msg.author[0].toUpperCase() : '?';
    if (grouped) avatar.classList.add('ghost');

    // body (meta + content)
    const body = document.createElement('div');
    body.className = 'message-body';

    const meta = document.createElement('div');
    meta.className = 'meta';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'name';
    nameSpan.textContent = msg.author;

    const timeSpan = document.createElement('span');
    timeSpan.className = 'time';

    // Only show meta (name/time) on the first in a run
    if (grouped) {
      meta.classList.add('hidden');
    } else {
      meta.appendChild(nameSpan);

      // timestamp visibility using your existing rule
      const showTime = shouldShowTimestamp(prevMsg, msg, true);
      if (showTime) {
        try { timeSpan.textContent = new Date(msg.timestamp).toLocaleString(); } catch(e){ timeSpan.textContent=''; }
      } else {
        timeSpan.textContent = '';
      }
      meta.appendChild(timeSpan);

      if (msg.edited_at) {
        const editedSpan = document.createElement('span');
        editedSpan.className = 'edited';
        editedSpan.textContent = '(edited)';
        meta.appendChild(editedSpan);
      }
    }

    body.appendChild(meta);

    // --- inline reply preview (clickable) ---
    if (msg.reply_to) {
      const qr = document.createElement('div');
      qr.className = 'inline-reply-preview';
      qr.style.background = '#0b0c0e';
      qr.style.padding = '6px';
      qr.style.borderLeft = '3px solid rgba(255,255,255,0.03)';
      qr.style.borderRadius = '6px';
      qr.style.marginBottom = '6px';
      qr.style.color = 'var(--muted)';
      qr.style.fontSize = '13px';
      qr.style.cursor = 'pointer';
      // show short preview from local cache if available, else placeholder
      const quoted = msgIndex[msg.reply_to];
      qr.textContent = quoted ? ((quoted.deleted ? '(original deleted)' : (String(quoted.content || '').slice(0,120)))) : '(quoted message)';
      // click -> scroll to referenced message
      qr.onclick = (ev) => {
        ev.stopPropagation();
        const target = document.getElementById('msg-' + msg.reply_to);
        const wrapper = document.querySelector('.chat-wrapper');
        if (target && wrapper) {
          // smooth scroll target into center of wrapper
          const targetTop = target.offsetTop;
          const centerOffset = Math.round((wrapper.clientHeight / 2) - (target.clientHeight / 2));
          wrapper.scrollTo({ top: Math.max(0, targetTop - centerOffset), behavior: 'smooth' });
          // briefly highlight to give feedback
          target.classList.add('referenced');
          setTimeout(()=> target.classList.remove('referenced'), 1400);
        }
      };
      body.appendChild(qr);
    }


    const content = document.createElement('div');
    content.className = 'content';

    const text = (msg.content || "").toString();
    if (isImageUrl(text)) {
      const img = document.createElement('img');
      img.src = text;
      img.style.maxWidth = '300px';
      img.style.borderRadius = '6px';
      content.appendChild(img);

      // GIF favorite button (if you have favorites)
      const gifKey = getGifKeyFromUrl(text);
      const favBtn = document.createElement('button');
      favBtn.className = 'gif-fav-btn';
      const favId = favoriteMap[gifKey];
      favBtn.textContent = favId ? '♥' : '♡';
      favBtn.title = favId ? 'Unfavorite' : 'Favorite';
      favBtn.style.marginLeft = '8px';
      favBtn.onclick = async (e) => {
        e.stopPropagation();
        const token = getToken();
        if (!token) { alert('Log in to favorite GIFs'); return; }
        if (favoriteMap[gifKey]) {
          const fid = favoriteMap[gifKey];
          const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), { method: 'DELETE', headers: { token }});
          if (res.ok) { 
            removeFavoriteEntriesById(fid); 
            updateGifFavUI(gifKey); 
            favBtn.textContent='♡'; 
          }
        } else {
          const payload = { gif_id: gifKey, url: text, preview: text, title: '' };
          const res = await fetch('/gif/favorite', { method:'POST', headers: {'Content-Type':'application/json', token}, body: JSON.stringify(payload) });

          if (res.ok) {
            const j = await res.json().catch(()=>({}));
            if (j.id) {
              favoriteMap[String(gifKey)] = j.id;

              if (j.gif_id) favoriteMap[String(j.gif_id)] = j.id;

              if (j.original_gif_id) favoriteMap[String(j.original_gif_id)] = j.id;
            }
            favBtn.textContent='♥';
            updateGifFavUI(gifKey);
          }
        }
      };
      content.appendChild(favBtn);

    } else if (isVideoUrl(text)) {
      const vid = document.createElement('video');
      vid.src = text;
      vid.controls = true;
      vid.style.maxWidth = '400px';
      content.appendChild(vid);
    } else {
      const html = marked.parse(text);
      content.innerHTML = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
    }

    body.appendChild(content);

    // reactions area
    const reactionsBar = document.createElement('div');

    const reactionEntries = (msg.reactions && typeof msg.reactions === 'object')
      ? Object.entries(msg.reactions)
      : [];

    const hasReactions = reactionEntries.some(([emoji, users]) => Array.isArray(users) && users.length > 0);
    if (hasReactions) wrapper.classList.add('has-reactions');

    reactionEntries.forEach(([emoji, users]) => {
      const list = Array.isArray(users) ? users : [];
      if (!list.length) return;

      const rbtn = document.createElement('button');
      rbtn.className = 'reaction-btn';
      rbtn.textContent = `${emoji} ${list.length}`;

      // Hover tooltip: who reacted (display names)
      const names = list.map(u => displayNameForUser(u));
      const tipText = names.join(', ');
      rbtn.title = tipText; // fallback tooltip

      rbtn.addEventListener('mouseenter', (ev) => {
        showReactionTooltip(tipText, ev.clientX, ev.clientY);
      });
      rbtn.addEventListener('mousemove', (ev) => {
        showReactionTooltip(tipText, ev.clientX, ev.clientY);
      });
      rbtn.addEventListener('mouseleave', () => {
        hideReactionTooltip();
      });

      // Click toggles reaction (your existing behavior)
      rbtn.onclick = () => {
        hideReactionTooltip();
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji }));
      };

      reactionsBar.appendChild(rbtn);
    });

    // Add reaction "+" (only visible on hover unless message already has reactions)
    const addReactBtn = document.createElement('button');
    addReactBtn.className = 'add-react-btn';
    addReactBtn.textContent = '+';
    addReactBtn.title = 'Add reaction';
    addReactBtn.onclick = (ev) => {
      hideReactionTooltip();
      if (!socket || socket.readyState !== WebSocket.OPEN) return;
      openEmojiPicker(addReactBtn, (emoji) => {
        socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji }));
      });
      ev.stopPropagation?.();
    };

    reactionsInline.appendChild(addReactBtn);
    body.appendChild(reactionsBar);

    // actions (pin/copy/reply/delete/edit) - keep small and unobtrusive
    const actions = document.createElement('div');
    actions.className = 'msg-actions';
    actions.style.marginTop = '6px';

    const pinBtn = document.createElement('button');
    pinBtn.textContent = msg.pinned ? 'Unpin' : 'Pin';
    pinBtn.onclick = () => {
      if (!socket || socket.readyState !== WebSocket.OPEN) return;
      const pinFlag = !msg.pinned;
      socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: pinFlag }));
    };
    actions.appendChild(pinBtn);

    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(msg.content || ''); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',900); } catch(e){ alert('Copy failed: '+e); }
    };
    actions.appendChild(copyBtn);

    const replyBtn = document.createElement('button');
    replyBtn.textContent = 'Reply';
    replyBtn.onclick = () => startReply(msg.id);
    actions.appendChild(replyBtn);

    if (msg.author === myId) {
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.onclick = () => { socket.send(JSON.stringify({ type: 'delete', id: msg.id })); };
      actions.appendChild(delBtn);

      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditUI(msg.id);
      actions.appendChild(editBtn);
    }

    body.appendChild(actions);

    // --- contextual menu (ellipsis button + menu on click / right-click) ---
    // create ellipsis button (will be visible because of CSS)
    const menuBtn = document.createElement('button');
    menuBtn.className = 'msg-menu-btn';
    menuBtn.textContent = '⋯';
    menuBtn.title = 'Actions';

    // helper to close existing menu
    function closeContextMenu() {
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();
      document.removeEventListener('click', closeContextMenu);
    }

    // make the menu DOM and attach actions
    function openContextMenuAt(x, y) {
      closeContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';

      const addItem = (label, fn) => {
        const b = document.createElement('button');
        b.textContent = label;
        b.onclick = (ev) => { ev.stopPropagation(); fn(); closeContextMenu(); };
        menu.appendChild(b);
      };

      addItem(msg.pinned ? 'Unpin' : 'Pin', () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: !msg.pinned }));
      });

      addItem('Copy', () => {
        try { navigator.clipboard.writeText(msg.content || ''); } catch(e){ console.warn('copy failed', e); }
      });

      addItem('Reply', () => startReply(msg.id) );

      if (msg.author === myId) {
        addItem('Edit', () => openEditUI(msg.id));
        addItem('Delete', () => { if (!socket) return; socket.send(JSON.stringify({ type:'delete', id: msg.id })); });
      }

      // quick react row
      const reactRow = document.createElement('div');
      reactRow.style.display = 'flex';
      reactRow.style.gap = '6px';
      reactRow.style.marginTop = '6px';
      ['👍','❤️','😂','🔥','😮'].forEach(ch => {
        const rb = document.createElement('button');
        rb.textContent = ch;
        rb.onclick = (ev) => { ev.stopPropagation(); if (!socket) return; socket.send(JSON.stringify({ type:'react', id: msg.id, emoji: ch })); closeContextMenu(); };
        reactRow.appendChild(rb);
      });
      menu.appendChild(reactRow);

      document.body.appendChild(menu);

      // clamp position so menu stays on-screen
      const rect = menu.getBoundingClientRect();
      let left = Math.max(8, Math.min(window.innerWidth - rect.width - 8, x));
      let top = Math.max(8, Math.min(window.innerHeight - rect.height - 8, y));
      menu.style.left = left + 'px';
      menu.style.top = top + 'px';

      setTimeout(()=> document.addEventListener('click', closeContextMenu));
    }

    // show menu on ellipsis click
    menuBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const r = menuBtn.getBoundingClientRect();
      openContextMenuAt(r.left, r.bottom + 6);
    });

    // show menu on right-click
    wrapper.addEventListener('contextmenu', (ev) => {
      ev.preventDefault();
      openContextMenuAt(ev.clientX, ev.clientY);
    });

    // attach the ellipsis button to wrapper (CSS shows it on hover)
    toolbar.appendChild(menuBtn);

    wrapper.appendChild(toolbar);
    wrapper.appendChild(avatar);
    wrapper.appendChild(body);
    return wrapper;
  }

  function isGroupedContinuation(prevMsg, curMsg) {
    if (!prevMsg || !curMsg) return false;
    if (prevMsg.author !== curMsg.author) return false;

    const a = Date.parse(prevMsg.timestamp);
    const b = Date.parse(curMsg.timestamp);
    if (Number.isNaN(a) || Number.isNaN(b)) return false;

    // "Back to back" window: 5 minutes (tweak to taste)
    return (b - a) <= (5 * 60 * 1000);
  }

  function displayNameForUser(username){
    const profile = userDirectory[username] || {};
    return profile.display_name || username;
  }

  /* --- Reaction hover tooltip --- */
  let reactionTipEl = null;

  function showReactionTooltip(text, x, y) {
    if (!reactionTipEl) {
      reactionTipEl = document.createElement('div');
      reactionTipEl.className = 'reaction-tooltip';
      document.body.appendChild(reactionTipEl);
    }
    reactionTipEl.textContent = text;

    // clamp within viewport
    const pad = 10;
    reactionTipEl.style.left = `${Math.min(window.innerWidth - pad, Math.max(pad, x + 12))}px`;
    reactionTipEl.style.top  = `${Math.min(window.innerHeight - pad, Math.max(pad, y + 12))}px`;
    reactionTipEl.style.display = 'block';
  }

  let reactionTooltipGuardsWired = false;

  function wireReactionTooltipGuardsOnce(){
    if (reactionTooltipGuardsWired) return;
    reactionTooltipGuardsWired = true;
    document.addEventListener('scroll', hideReactionTooltip, true);
    window.addEventListener('blur', hideReactionTooltip);
    document.addEventListener('click', hideReactionTooltip, true);
  }

  function hideReactionTooltip() {
    if (reactionTipEl) reactionTipEl.style.display = 'none';
  }

  wireReactionTooltipGuardsOnce();



  let voiceUIWired = false;

  function setupVoiceUI() {
    if (voiceUIWired) return;
    voiceUIWired = true;

    const deafenBtn = document.getElementById("deafenBtn");
    const voiceBtn = document.getElementById("voiceBtn");
    const muteBtn  = document.getElementById("muteBtn");
    if (!voiceBtn || !muteBtn) return;

    voiceBtn.addEventListener("click", async () => {
      console.log("[voice] click; wsState=", socket?.readyState, "secure=", window.isSecureContext);

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert("Not connected yet. Click Connect first (or wait for connection).");
        return;
      }

      try {
        if (!voice.enabled) await joinVoice();
        else leaveVoice();
      } catch (e) {
        console.error("[voice] join/leave failed", e);
        alert("Voice failed to start. Check mic permissions and HTTPS/localhost.");
      }
    });
    deafenBtn.addEventListener("click", () => {
      if (!voice.enabled) return;
      toggleDeafen();
    });
    muteBtn.addEventListener("click", () => toggleMute());
  }

  let audioGraph = {
    ctx: null,
    gainNode: null,
    src: null,
    dest: null,
    rawStream: null,
    outStream: null
  };

  function teardownAudioGraph() {
    try { audioGraph.src?.disconnect(); } catch(e){}
    try { audioGraph.gainNode?.disconnect(); } catch(e){}
    try { audioGraph.ctx?.close(); } catch(e){}
    audioGraph = { ctx:null, gainNode:null, src:null, dest:null, rawStream:null, outStream:null };
  }

  const video = {
    enabled: false,
    localStream: null,   // just video stream (track)
    tiles: new Map(),     // username -> HTMLVideoElement
    overlays: new Map(),
    audioControls: new Map()
  };

  const screenShare = {
    enabled: false,
    localStream: null,
    tiles: new Map(),    // username -> HTMLVideoElement
    overlays: new Map()
  };

  const stageState = {
    primaryScreenUser: null,
    primaryNode: null,
    hiddenScreens: new Set(),
    savedTrayOrder: [],
    theatre: false
  };

  stageState.theatre = false;
  stageState.savedTrayOrder = [];

  function ensureVideoTile(username, isLocal=false) {
    if (!voice.enabled) return null;

    if (!stageState.theatre) setStageVisible(true);

    let el = video.tiles.get(username);
    if (el) return el;

    const wrap = document.createElement('div');
    wrap.className = 'stage-tile video-tile';
    wrap.dataset.user = username;
    wrap.dataset.type = 'video';

    const box = document.createElement('div');
    box.className = 'tile-box';

    box.addEventListener('click', (ev) => {
      if (ev.target.closest('.tile-controls')) return;
      handleTileSurfaceClick(wrap);
    });

    el = document.createElement('video');
    el.autoplay = true;
    el.playsInline = true;
    el.muted = !!isLocal;
    el.style.width = '100%';
    el.style.height = '100%';
    el.style.objectFit = 'cover';     // camera
    el.style.display = 'block';

    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.inset = '0';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.background = '#0b0c0e';

    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.style.width = '64px';
    avatar.style.height = '64px';
    avatar.style.fontSize = '22px';

    const prof = userDirectory[username] || {};
    const shownName = prof.display_name || username;
    avatar.textContent = shownName ? shownName[0].toUpperCase() : '?';
    if (prof.avatar_color) avatar.style.background = prof.avatar_color;

    overlay.appendChild(avatar);

    // Top-right controls (same ops as screen tiles)
    const controlsTop = document.createElement('div');
    controlsTop.className = 'tile-controls';

    const fsBtn = document.createElement('button');
    fsBtn.textContent = '⤢';
    fsBtn.title = 'Fullscreen';
    fsBtn.onclick = (e) => { e.stopPropagation(); toggleFullscreen(box); };
    controlsTop.appendChild(fsBtn);

    const hideBtn = document.createElement('button');
    hideBtn.textContent = 'Hide';
    hideBtn.title = 'Hide this tile';
    hideBtn.onclick = (e) => {
      e.stopPropagation();
      removeVideoTile(username);
      if (stageState.theatre) relayoutTheatre();
    };
    controlsTop.appendChild(hideBtn);

    box.appendChild(el);
    box.appendChild(overlay);
    box.appendChild(controlsTop);

    const label = document.createElement('div');
    label.textContent = shownName;
    label.style.color = 'var(--muted)';
    label.style.fontSize = '12px';

    wrap.appendChild(box);
    wrap.appendChild(label);

    // Remote audio controls for camera tiles
    if (!isLocal) appendRemoteAudioControls(username, wrap);

    const host = currentTrayHost();
    host.appendChild(wrap);
    rememberTrayNode(wrap);

    video.tiles.set(username, el);
    video.overlays.set(username, overlay);

    overlay.style.display = 'flex';

    // If we’re in theatre and nothing is primary yet, make this primary
    if (stageState.theatre && !stageState.primaryNode) {
      stageState.primaryNode = wrap;
      relayoutTheatre();
    }

    return el;
  }

  function showVideoOverlay(username, show) {
    const ov = video.overlays.get(username);
    if (!ov) return;
    ov.style.display = show ? 'flex' : 'none';
  }

  function removeVideoTile(username) {
    const el = video.tiles.get(username);
    if (!el) return;

    const wrap = el.closest('.video-tile') || el.closest('.stage-tile') || el.parentElement;
    try { wrap?.remove(); } catch(e){}

    video.tiles.delete(username);
    video.overlays.delete(username);
    video.audioControls?.delete(username);

    if (wrap) {
      stageState.savedTrayOrder = (stageState.savedTrayOrder || []).filter(n => n !== wrap);
      if (stageState.primaryNode === wrap) stageState.primaryNode = null;
    }

    if (stageState.theatre) relayoutTheatre();
    else refreshTrayVisibility();
  }

  function setScreenStageVisible(on){
    const st = document.getElementById('screenStage');
    const vs = document.getElementById('videoStage');
    if (!st) return;

    st.classList.toggle('theatre', !!on);
    st.style.display = on ? 'grid' : 'none';

    if (on) {
      // Screen stage owns the top area; push chat down accordingly
      document.documentElement.style.setProperty('--stage-height', '280px');

      // Prevent overlap/click stealing
      if (vs) vs.style.display = 'none';
    } else {
      // Restore video stage if needed
      if (vs && video.tiles.size > 0) {
        vs.style.display = 'flex';
        document.documentElement.style.setProperty('--stage-height', '220px');
      } else {
        document.documentElement.style.setProperty('--stage-height', '0px');
        if (vs) vs.style.display = 'none';
      }
    }
  }

  function setPrimaryScreen(username) {
    stageState.primaryScreenUser = username;
    relayoutScreenStage();
  }

  function relayoutScreenStage() {
    const primaryHost = document.getElementById('screenPrimary');
    const sideHost = document.getElementById('screenSide');
    if (!primaryHost || !sideHost) return;

    // Clear hosts (but keep tile DOM nodes alive by re-parenting)
    primaryHost.innerHTML = '';
    sideHost.innerHTML = '';

    // Choose a primary if none exists but screens exist
    const users = Array.from(screenShare.tiles.keys()).filter(u => !stageState.hiddenScreens.has(u));
    if (!users.length) {
      setScreenStageVisible(false);
      stageState.primaryScreenUser = null;
      return;
    }
    setScreenStageVisible(true);

    if (!stageState.primaryScreenUser || !users.includes(stageState.primaryScreenUser)) {
      stageState.primaryScreenUser = users[0];
    }

    users.forEach(u => {
      const wrap = screenShare.wraps.get(u);
      if (!wrap) return;
      if (u === stageState.primaryScreenUser) primaryHost.appendChild(wrap);
      else sideHost.appendChild(wrap);
    });
  }

  function toggleFullscreen(el) {
    if (!el) return;

    if (document.fullscreenElement) {
      document.exitFullscreen?.();
    } else {
      el.requestFullscreen?.({ navigationUI: "hide" }).catch(() => {});
    }
  }

  function computeScreenStageHeight() {
    // Max height so we don't collide with composer/reply/typing bars.
    const topSafe = getTopSafeY();
    const bottomSafe = getBottomSafeY();
    const maxAvail = Math.max(320, Math.floor(bottomSafe - topSafe - 12));
    const target = Math.floor(window.innerHeight * 0.65);
    return clamp(target, 320, maxAvail);
  }

  function currentTrayHost() {
    // While in theatre, we want new tiles to show in the theatre side rail.
    if (stageState.theatre) {
      return document.getElementById('screenSide') || document.getElementById('videoStage');
    }
    return document.getElementById('videoStage');
  }

  function rememberTrayNode(node) {
    if (!stageState.theatre) return;
    if (!stageState.savedTrayOrder.includes(node)) stageState.savedTrayOrder.push(node);
  }

  function enterTheatre(primaryWrap){
    const tray = document.getElementById('videoStage');
    const st   = document.getElementById('screenStage');
    if (!tray || !st) return;

    stageState.theatre = true;
    stageState.primaryNode = primaryWrap || null;

    // snapshot current tray order
    stageState.savedTrayOrder = Array.from(tray.children || []);
    if (primaryWrap && !stageState.savedTrayOrder.includes(primaryWrap)) {
      stageState.savedTrayOrder.unshift(primaryWrap);
    }

    const h = computeScreenStageHeight();
    document.documentElement.style.setProperty('--stage-height', `${h}px`);
    document.documentElement.style.setProperty('--screen-stage-height', `${h}px`);

    st.style.display = 'grid';
    st.style.height = `${h}px`;
    st.classList.add('theatre');

    tray.style.display = 'none';

    relayoutTheatre();
  }

  function relayoutTheatre(){
    if (!stageState.theatre) return;

    const primaryHost = document.getElementById('screenPrimary');
    const sideHost    = document.getElementById('screenSide');
    const st          = document.getElementById('screenStage');
    if (!primaryHost || !sideHost || !st) return;

    primaryHost.innerHTML = '';
    sideHost.innerHTML = '';

    const nodes = uniqueNodes(stageState.savedTrayOrder).filter(n => {
      const t = n?.dataset?.type || '';
      const u = n?.dataset?.user || '';
      if (t === 'screen' && stageState.hiddenScreens.has(u)) return false;
      return true;
    });

    if (!nodes.length) {
      exitTheatre();
      return;
    }

    if (!stageState.primaryNode || !nodes.includes(stageState.primaryNode)) {
      stageState.primaryNode = nodes[0];
    }

    primaryHost.appendChild(stageState.primaryNode);
    nodes.forEach(n => {
      if (n === stageState.primaryNode) return;
      sideHost.appendChild(n);
    });
  }

  function exitTheatre(){
    const tray = document.getElementById('videoStage');
    const st   = document.getElementById('screenStage');
    const primaryHost = document.getElementById('screenPrimary');
    const sideHost    = document.getElementById('screenSide');

    stageState.theatre = false;
    stageState.primaryNode = null;
    stageState.primaryScreenUser = null; // keep compatibility

    if (primaryHost) primaryHost.innerHTML = '';
    if (sideHost) sideHost.innerHTML = '';

    if (st) {
      st.style.display = 'none';
      st.classList.remove('theatre');
    }

    if (tray) {
      tray.innerHTML = '';
      uniqueNodes(stageState.savedTrayOrder).forEach(n => { if (n) tray.appendChild(n); });
      stageState.savedTrayOrder = [];
    }

    refreshTrayVisibility();
  }


  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && stageState.theatre && !document.fullscreenElement) exitTheatre();
  });
  window.addEventListener('resize', () => {
    if (stageState.theatre) {
      const h = computeScreenStageHeight();
      document.documentElement.style.setProperty('--stage-height', `${h}px`);
      document.documentElement.style.setProperty('--screen-stage-height', `${h}px`);
      const st = document.getElementById('screenStage');
      if (st) st.style.height = `${h}px`;
    }
  });


  function ensureScreenTile(username, isLocal=false){
    if (!voice.enabled) return null;

    screenShare.wraps = screenShare.wraps || new Map();

    let el = screenShare.tiles.get(username);
    if (el) return el;

    const wrap = document.createElement('div');
    wrap.className = 'stage-tile screen-tile';
    wrap.dataset.user = username;
    wrap.dataset.type = 'screen';

    const box = document.createElement('div');
    box.className = 'tile-box';

    box.addEventListener('click', (ev) => {
      if (ev.target.closest('.tile-controls')) return;
      handleTileSurfaceClick(wrap);
    });

    el = document.createElement('video');
    el.autoplay = true;
    el.playsInline = true;
    el.muted = !!isLocal;
    el.style.width = '100%';
    el.style.height = '100%';
    el.style.objectFit = 'contain';   // screen share
    el.style.display = 'block';

    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.inset = '0';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.background = '#0b0c0e';
    overlay.style.color = 'var(--muted)';
    overlay.style.fontSize = '13px';
    overlay.textContent = 'No screen stream';

    const controlsTop = document.createElement('div');
    controlsTop.className = 'tile-controls';

    const fsBtn = document.createElement('button');
    fsBtn.textContent = '⤢';
    fsBtn.title = 'Fullscreen';
    fsBtn.onclick = (e) => { e.stopPropagation(); toggleFullscreen(box); };
    controlsTop.appendChild(fsBtn);

    const hideBtn = document.createElement('button');
    hideBtn.textContent = 'Hide';
    hideBtn.title = 'Hide this stream';
    hideBtn.onclick = (e) => {
      e.stopPropagation();
      if (stageState.theatre) {
        stageState.hiddenScreens.add(username);
        relayoutTheatre();
      } else {
        removeScreenTile(username);
      }
    };
    controlsTop.appendChild(hideBtn);

    box.appendChild(el);
    box.appendChild(overlay);
    box.appendChild(controlsTop);

    const label = document.createElement('div');
    label.textContent = `${displayNameForUser(username)} (Screen)`;
    label.style.color = 'var(--muted)';
    label.style.fontSize = '12px';

    wrap.appendChild(box);
    wrap.appendChild(label);

    // Remote audio controls (mute/volume) for screen tiles too
    if (!isLocal) appendRemoteAudioControls(username, wrap);

    screenShare.tiles.set(username, el);
    screenShare.overlays.set(username, overlay);
    screenShare.wraps.set(username, wrap);

    overlay.style.display = 'flex';

    const host = currentTrayHost();
    if (!stageState.theatre) {
      setStageVisible(true);
      host.appendChild(wrap);
    } else {
      host.appendChild(wrap);
      rememberTrayNode(wrap);
      // if nothing is primary yet, make this one primary
      if (!stageState.primaryNode) stageState.primaryNode = wrap;
      relayoutTheatre();
    }

    return el;
  }

  function showScreenOverlay(username, show){
    const ov = screenShare.overlays.get(username);
    if (!ov) return;
    ov.style.display = show ? 'flex' : 'none';
  }

  function removeScreenTile(username){
    const wrap = screenShare.wraps?.get(username);
    if (wrap) {
      try { wrap.remove(); } catch(e){}
      stageState.savedTrayOrder = (stageState.savedTrayOrder || []).filter(n => n !== wrap);
      if (stageState.primaryNode === wrap) stageState.primaryNode = null;
    }

    screenShare.wraps?.delete(username);

    const el = screenShare.tiles.get(username);
    if (el) screenShare.tiles.delete(username);
    screenShare.overlays.delete(username);

    stageState.hiddenScreens.delete(username);

    if (stageState.theatre) relayoutTheatre();
    else refreshTrayVisibility();
  }

  const onlineUsers = new Set();

  const typingUsers = new Set();
  const typingTimeouts = new Map(); // username -> timer

  const pendingIce = new Map(); // peer -> [candidates]
  const voiceState = new Map();

  function renderPresence() {
    const el = document.getElementById("presenceLine");
    if (!el) return;
    const arr = Array.from(onlineUsers).sort();

    el.textContent = arr.length ? ("Online: " + arr.join(", ")) : "No one online";
  }

  function renderTyping() {
    const el = document.getElementById("typingLine");
    if (!el) return;

    const arr = Array.from(typingUsers).sort();
    el.textContent = "";
    if (!arr.length) { syncTypingHeightVar(); return; }

    for (const u of arr) {
      const name = displayNameForUser(u) || u;
      const row = document.createElement("div");
      row.textContent = `${name} is typing...`;
      el.appendChild(row);
    }

    syncTypingHeightVar();
  }


  function syncTypingHeightVar() {
    const el = document.getElementById("typingLine");
    if (!el) return;

    // If empty, collapse.
    if (!el.textContent.trim() && !el.innerHTML.trim()) {
      document.documentElement.style.setProperty('--typing-height', '0px');
      return;
    }

    // Measure after layout
    requestAnimationFrame(() => {
      const h = Math.ceil(el.getBoundingClientRect().height);
      document.documentElement.style.setProperty('--typing-height', `${Math.min(h, 72)}px`);
    });
  }


  function setUserTyping(user, isTyping) {
    if (!user) return;

    if (isTyping) {
      typingUsers.add(user);
      renderTyping();

      if (typingTimeouts.has(user)) clearTimeout(typingTimeouts.get(user));
      typingTimeouts.set(user, setTimeout(() => {
        typingUsers.delete(user);
        typingTimeouts.delete(user);
        renderTyping();
      }, 2500));
    } else {
      typingUsers.delete(user);
      if (typingTimeouts.has(user)) clearTimeout(typingTimeouts.get(user));
      typingTimeouts.delete(user);
      renderTyping();
    }
  }

  function getInviteCodeFromUrl() {
    const u = new URL(window.location.href);
    return u.searchParams.get('invite');
  }

  async function acceptInviteIfPresent() {
    const code = getInviteCodeFromUrl() || localStorage.getItem('pending_invite');
    if (!code) return null;

    const token = getToken();
    if (!token) {
      localStorage.setItem('pending_invite', code);
      return null;
    }

    const res = await fetch(`/invites/${encodeURIComponent(code)}/join`, {
      method: 'POST',
      headers: { token }
    });
    if (!res.ok) return null;

    const j = await res.json();
    if (j.room_id) {
      localStorage.setItem('room_id', j.room_id);
      localStorage.removeItem('pending_invite');

      // clean URL
      const url = new URL(window.location.href);
      url.searchParams.delete('invite');
      window.history.replaceState({}, '', url.toString());
      return j.room_id;
    }
    return null;
  }


  // on page load, try auto-login if token + username exist
  window.addEventListener('DOMContentLoaded', () => {
    loadAudioPrefs();
    setupVoiceUI();

    portalToBody('settingsModal');
    portalToBody('audioModal');
    portalToBody('roomsModal');

    const token = getToken();
    const user = localStorage.getItem('username');

    document.getElementById('audioBtn').onclick = openAudioModal;
    document.getElementById('closeAudio').onclick = () => { stopMicTest(); document.getElementById('audioModal').style.display = 'none'; };
    document.getElementById('applyAudio').onclick = applyAudioSettings;

    document.getElementById('micGain').oninput = (e) => setText('micGainVal', `${parseFloat(e.target.value).toFixed(2)}x`);
    document.getElementById('speakThresh').oninput = (e) => setText('speakThreshVal', `${parseFloat(e.target.value).toFixed(3)}`);
    document.getElementById('gateThresh').oninput = (e) => setText('gateThreshVal', `${parseFloat(e.target.value).toFixed(3)}`);

    document.getElementById('masterVol').oninput = (e) => {
      const v = clamp(parseFloat(e.target.value || '1'), 0, 1);
      setText('masterVolVal', `${Math.round(v * 100)}%`);
    };

    document.getElementById('testMicBtn').onclick = async () => {
      const btn = document.getElementById('testMicBtn');
      const running = !!micTestRAF;
      if (running) { stopMicTest(); btn.textContent = 'Mic Test'; return; }
      await startMicTest();
      btn.textContent = 'Stop Test';
    };

    document.getElementById('testSpkBtn').onclick = async () => {
      const a = document.getElementById('ringTone');
      if (!a) return;
      const spkId = localStorage.getItem('spk_device_id') || '';
      if (spkId && supportsSetSinkId(a)) await a.setSinkId(spkId).catch(()=>{});
      a.currentTime = 0;
      a.volume = 0.7;
      a.play().then(() => setTimeout(() => { try { a.pause(); a.currentTime = 0; } catch(e){} }, 900)).catch(()=>{});
    };

    if (token && user) {
      myId = user;
      showAppUI();
      connectSocket();
    } else {
      showAuthUI();
    }

    // Ringtone Handler
    const accept = document.getElementById('icAccept');
    const dismiss = document.getElementById('icDismiss');

    if (accept) {
      accept.onclick = async () => {
        unlockSoundsOnce();      // ensures audio is allowed
        stopRingtone();
        if (!voice.enabled) {
          try { await joinVoice(); } catch(e) { console.warn('joinVoice failed', e); }
        }
      };
    }

    if (dismiss) {
      dismiss.onclick = () => {
        unlockSoundsOnce();
        stopRingtone();
      };
    }
  });

  (function wireAudioModalDismiss(){
    const modal = document.getElementById('audioModal');
    if (!modal) return;

    // click outside content closes
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.style.display = 'none';
    });

    // ESC closes
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.style.display !== 'none') {
        modal.style.display = 'none';
      }
    });
  })();

  function setText(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
  }

  async function applySpeakerSelectionToAllSinks() {
    const spkId = localStorage.getItem('spk_device_id') || '';
    if (!spkId) return;

    for (const [, el] of voice.sinks.entries()) {
      if (supportsSetSinkId(el)) el.setSinkId(spkId).catch(()=>{});
    }
  }

  // Builds the centralized remote mixer UI inside the modal
  function renderAudioMixer() {
    const host = document.getElementById('remoteMixer');
    if (!host) return;

    host.innerHTML = '';

    if (!voice.enabled) {
      host.innerHTML = `<div style="color:var(--muted); font-size:12px;">Join Voice to adjust other users.</div>`;
      return;
    }

    const users = Array.from(voice.users).filter(u => u && u !== myId).sort();
    if (!users.length) {
      host.innerHTML = `<div style="color:var(--muted); font-size:12px;">No one else is in voice.</div>`;
      return;
    }

    users.forEach(u => {
      const row = document.createElement('div');
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr auto 140px';
      row.style.gap = '8px';
      row.style.alignItems = 'center';

      const name = document.createElement('div');
      name.style.overflow = 'hidden';
      name.style.textOverflow = 'ellipsis';
      name.style.whiteSpace = 'nowrap';
      name.textContent = displayNameForUser(u) || u;

      const muteBtn = document.createElement('button');
      muteBtn.className = 'btn-small';
      muteBtn.textContent = audioPrefs.mutedUsers.has(u) ? 'Unmute' : 'Mute';
      muteBtn.onclick = () => { toggleUserMute(u); renderAudioMixer(); };

      const vol = document.createElement('input');
      vol.type = 'range';
      vol.min = '0';
      vol.max = '1';
      vol.step = '0.05';
      vol.value = String(audioPrefs.userVolumes.has(u) ? audioPrefs.userVolumes.get(u) : 1);
      vol.oninput = () => setUserVolume(u, parseFloat(vol.value));

      row.appendChild(name);
      row.appendChild(muteBtn);
      row.appendChild(vol);

      host.appendChild(row);
    });
  }

  // delegated handler for edit buttons (works even if messages are rendered later)
  document.getElementById('container').addEventListener('click', (ev) => {
    const target = ev.target;
    if (!target) return;
    if (target.classList && target.classList.contains('edit-btn')) {
      const msgId = target.dataset.msgId;
      if (msgId) openEditUI(msgId);
    }
  });

  // openEditUI: top-level (global) edit UI — supports replacing content (text or media URL).
  function openEditUI(messageId) {
    const el = document.getElementById('msg-' + messageId);
    if (!el) return;
    const contentEl = el.querySelector('.content');
    if (!contentEl) return;

    // create editor UI (textarea + optional file input + Save/Cancel)
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.rows = 3;
    textarea.value = (msgIndex[messageId] && msgIndex[messageId].content) || '';

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'block';
    fileInput.style.marginTop = '6px';

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.marginLeft = '6px';

    // replace content element with editor
    const editWrap = document.createElement('div');
    editWrap.className = 'inline-edit';

    saveBtn.className = 'btn-primary';
    cancelBtn.className = 'btn-small';

    const actionsRow = document.createElement('div');
    actionsRow.className = 'edit-actions';
    actionsRow.appendChild(cancelBtn);
    actionsRow.appendChild(saveBtn);

    editWrap.appendChild(textarea);
    editWrap.appendChild(fileInput);
    editWrap.appendChild(actionsRow);

    contentEl.innerHTML = '';
    contentEl.appendChild(editWrap);


    saveBtn.onclick = async () => {
      const newText = textarea.value.trim();

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert('Not connected');
        return;
      }

      // if a file is attached, upload it and use resulting URL as the new content
      const file = fileInput.files && fileInput.files[0];
      let finalContent = newText;
      if (file) {
        const fd = new FormData();
        fd.append('file', file);
        const token = getToken();
        if (!token) { alert('Log in to upload files'); return; }

        const up = await fetch('/upload', {
          method: 'POST',
          headers: { token },
          body: fd
        });

        if (!up.ok) {
          const j = await up.json().catch(()=>({}));
          alert('File upload failed ' + (j.detail || up.status));
          return;
        }
        const upj = await up.json().catch(()=>({}));
        finalContent = upj.url || finalContent;
      }

      // send edit request over websocket
      socket.send(JSON.stringify({ type: 'edit', id: messageId, content: finalContent }));

      // optimistic update
      msgIndex[messageId].content = finalContent;
      msgIndex[messageId].edited_at = new Date().toISOString();
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };

    cancelBtn.onclick = () => {
      // restore original view
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };
  }


  function startReply(messageId) {
    replyTo = messageId;

    const preview = document.getElementById('replyPreview');
    const msg = msgIndex[messageId];

    // set preview text (shortened)
    let previewText = '';
    if (msg) {
      if (msg.deleted) previewText = '(original deleted)';
      else previewText = (msg.content || '').toString().slice(0, 140);
    } else {
      previewText = '(loading...)';
    }
    if (preview) preview.textContent = previewText;

    // show pinned reply box above composer
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'flex';

    // highlight the referenced message visually
    highlightReferencedMsg(messageId);
  }


  //Gif Render
  document.getElementById('gifBtn').onclick = async function openGifPicker() {
    const gifPicker = document.getElementById('gifPicker');
    const gifBtn = document.getElementById('gifBtn');
    if (!gifPicker || !gifBtn) return;

    // toggle
    if (gifPicker.style.display === 'block') { gifPicker.style.display = 'none'; return; }

    // build the picker content (same as before)
    gifPicker.innerHTML = `
      <div class="picker-header">
        <button id="gifTrendingBtn" class="btn-small">Trending</button>
        <button id="gifSearchBtn" class="btn-small">Search</button>
        <button id="gifFavsBtn" class="btn-small">Favorites</button>
        <input id="gifSearchInput" placeholder="Search GIFs..." style="flex:1; min-width:120px;" />
      </div>
      <div id="gifGrid"></div>
    `;
    

    // position above the gifBtn, anchored to composer
    // position above the gifBtn, anchored to the composer and fixed to viewport
    gifPicker.style.position = 'fixed'; // important — keeps it visible and not extending page
    gifPicker.style.display = 'block';
    
    requestAnimationFrame(() => {
      const btnRect = gifBtn.getBoundingClientRect();

      // match width to pins panel if available
      const pinsPanel = document.getElementById('pinsPanel');
      if (pinsPanel && pinsPanel.style.display === 'block') {
        const pw = pinsPanel.getBoundingClientRect().width;
        if (pw > 200) gifPicker.style.width = `${Math.round(pw)}px`;
      } else {
        gifPicker.style.width = ''; // fall back to CSS width
      }

      const header = gifPicker.querySelector('.picker-header');
      const headerH = header ? header.getBoundingClientRect().height : 44;

      const topSafe = getTopSafeY();
      const bottomSafe = getBottomSafeY();

      const spaceAbove = btnRect.top - topSafe - 10;
      const spaceBelow = bottomSafe - btnRect.bottom - 10;

      const placeAbove = spaceAbove >= 240 || spaceAbove >= spaceBelow;

      // Pick a hard height so it can't grow later as images load
      const available = placeAbove ? spaceAbove : spaceBelow;
      const pickerH = Math.max(240, Math.floor(Math.min(window.innerHeight * 0.60, available)));

      gifPicker.style.height = `${pickerH}px`;

      const grid = gifPicker.querySelector('#gifGrid');
      if (grid) {
        const gridH = Math.max(180, pickerH - headerH);
        grid.style.height = `${gridH}px`;   // <- height, not maxHeight
      }

      // measure AFTER setting height
      const rect = gifPicker.getBoundingClientRect();

      // RIGHT-ALIGN to button (dropdown style)
      let left = Math.round(btnRect.right - rect.width);
      left = clamp(left, 8, window.innerWidth - rect.width - 8);

      let top = placeAbove
        ? Math.round(btnRect.top - rect.height - 10)
        : Math.round(btnRect.bottom + 10);

      top = clamp(top, topSafe, bottomSafe - rect.height);

      gifPicker.style.left = `${left}px`;
      gifPicker.style.top = `${top}px`;
    });

    const grid = document.getElementById('gifGrid');
    const searchInp = document.getElementById('gifSearchInput');

    async function ensureFavs(){ await loadFavoriteMap(); }

    document.getElementById('gifTrendingBtn').onclick = async () => {
      grid.innerHTML = 'Loading...';
      await ensureFavs();
      const res = await fetch('/gif/trending?limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifSearchBtn').onclick = async () => {
      const q = (searchInp && searchInp.value || '').trim();
      grid.innerHTML = 'Searching...';
      await ensureFavs();
      const res = await fetch('/gif/search?q=' + encodeURIComponent(q || '') + '&limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifFavsBtn').onclick = async () => {
      grid.innerHTML = 'Loading favorites...';
      const token = getToken();
      if (!token) { grid.innerHTML = 'Log in to view favorites.'; return; }
      await ensureFavs();
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) { grid.innerHTML = 'Failed to load favorites'; return; }
      const j = await res.json();
      const arr = (j.results || []).map(f => ({ id: f.gif_id, url: f.url, preview: f.preview, title: f.title }));
      renderGifGrid(arr, grid);
    };

    // debounce typing
    let t;
    searchInp.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(()=> document.getElementById('gifSearchBtn').click(), 300);
    });

    // initial load trending
    document.getElementById('gifTrendingBtn').click();

    // hide if user clicks anywhere else
    setTimeout(()=> window.addEventListener('click', function outside(e){
      if (!gifPicker.contains(e.target) && e.target !== gifBtn) {
        gifPicker.style.display = 'none';
        window.removeEventListener('click', outside);
      }
    }));
  };

  
  document.getElementById('inviteBtn').onclick = async () => {
    const roomId = localStorage.getItem('room_id');
    const token = getToken();

    if (!token) { alert('Log in first'); return; }
    if (!roomId) { alert('No room selected'); return; }

    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/invite`, {
      method: 'POST',
      headers: { token }
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      alert(j.detail || `Invite failed (${res.status})`);
      return;
    }

    const link = `${window.location.origin}${j.invite_path}`;

    // Copy-to-clipboard best effort
    try { await navigator.clipboard.writeText(link); } catch (e) {}

    alert('Invite link copied:\n' + link);
  };


  function getGifKeyFromResult(g) {
    return String(g.id || g.gif_id ||  g.gifId || g.url || '');
  }

  function getGifKeyFromUrl(url) {
    return String(url || '')
  }

  function renderGifGrid(results, grid){
    grid.innerHTML = '';
    const token = getToken();

    results.forEach(g => {
      const url = g.url;
      const gifKey = String(g.url || '');

      const wrapper = document.createElement('div');
      wrapper.style.position = 'relative';
      wrapper.style.margin = '6px';
      wrapper.dataset.gifId = gifKey;

      const thumb = document.createElement('img');
      thumb.src = g.preview || g.url;
      thumb.style.width = '120px';
      thumb.style.cursor = 'pointer';
      thumb.title = g.title || '';
      thumb.onclick = () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) { alert('Not connected'); return; }
        socket.send(JSON.stringify({ 
          type:"message", 
          content: g.url, 
          gif: { provider: "giphy", id: g.id, url: g.url, preview: g.preview, title: g.title } 
        }));
        document.getElementById('gifPicker').style.display = 'none';
      };
      wrapper.appendChild(thumb);

      // favorite button (top-right)
      const favBtn = document.createElement('button');
      favBtn.className = 'fav-btn';
      const favRowId = favoriteMap[gifKey];
      favBtn.textContent = favRowId ? '♥' : '♡';
      favBtn.title = favRowId ? 'Unfavorite' : 'Favorite';
      favBtn.style.position = 'absolute';
      favBtn.style.top = '4px';
      favBtn.style.right = '4px';
      favBtn.style.padding = '4px';
      favBtn.style.fontSize = '12px';

      favBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!token) { alert('Log in to favorite GIFs'); return; }

        if (favoriteMap[gifKey]) {
          // unfavorite
          const fid = favoriteMap[gifKey];
          const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), {
            method: 'DELETE',
            headers: {'token': token}
          });
          if (res.ok) {
            removeFavoriteEntriesById(fid);
            favBtn.textContent = '♡';
            favBtn.title = 'Favorite';
            updateGifFavUI(gifKey);
          } else {
            alert('Failed to remove favorite');
          }
        } else {
          // add favorite
          const payload = {
            gif_id: g.id,
            url: g.url,
            preview: g.preview,
            title: g.title,
            metadata: { provider_id: g.id }
          };
          const res = await fetch('/gif/favorite', {
            method: 'POST',
            headers: {'Content-Type':'application/json', 'token': token},
            body: JSON.stringify(payload)
          });
          if (res.ok) {
            const j = await res.json().catch(()=>({}));
            if (j.id) {
              favoriteMap[String(gifKey)] = j.id;
              if (j.gif_id) favoriteMap[String(j.gif_id)] = j.id
              if (j.original_gif_id) favoriteMap[String(j.original_gif_id)] = j.id;
            }
              favBtn.textContent = '♥';
              favBtn.title = 'Unfavorite';
              updateGifFavUI(gifKey);
          } else {
            const j = await res.json().catch(()=>({}));
            alert('Favorite failed: ' + (j.detail || JSON.stringify(j)));
          }
        }
      };

      wrapper.appendChild(favBtn);
      grid.appendChild(wrapper);
    });
  }


  //Debounce Helper
  function debounce(fn, wait){
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), wait); };
  }

  //Favorite Gifs
  function getLocalFavs(){ try{return JSON.parse(localStorage.getItem('gif_favs')||'[]');}catch(e){return []}}
  function addLocalFav(g){ const arr=getLocalFavs(); if(!arr.find(x=>x.id===g.id)) arr.push(g); localStorage.setItem('gif_favs', JSON.stringify(arr)); }
  function removeLocalFav(id){ let arr=getLocalFavs(); arr=arr.filter(x=>x.id!==id); localStorage.setItem('gif_favs', JSON.stringify(arr)); }

  //Reactions
  function openEmojiPicker(anchorEl, onChoose) {
    closeEmojiPicker();
    if (!anchorEl) return;

    const picker = document.createElement('div');
    picker.id = 'emoji-picker';
    picker.style.position = 'absolute';
    picker.style.background = '#fff';
    picker.style.border = '1px solid #ccc';
    picker.style.padding = '6px';
    picker.style.boxShadow = '0 6px 12px rgba(0,0,0,0.12)';
    picker.style.zIndex = 9999;
    picker.style.maxWidth = '360px';
    picker.style.maxHeight = '260px';
    picker.style.overflow = 'auto';

    const input = document.createElement('input');
    input.placeholder = 'Search emoji...';
    input.style.width = '100%';
    input.style.boxSizing = 'border-box';
    input.style.marginBottom = '6px';
    picker.appendChild(input);

    const grid = document.createElement('div');
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '6px';
    picker.appendChild(grid);

    function renderGrid(filter='') {
      grid.innerHTML = '';
      const q = (filter || '').toLowerCase().trim();
      const candidates = EMOJI_LIST.filter(ch => {
        if (!q) return true;
        if (ch.includes(q)) return true;
        return Object.keys(EMOJI_ALIASES).some(a => (EMOJI_ALIASES[a] === ch) && a.includes(q));
      }).slice(0, 120);
      candidates.forEach(ch => {
        const b = document.createElement('button');
        b.textContent = ch;
        b.style.fontSize = '18px';
        b.style.padding = '4px';
        b.style.cursor = 'pointer';
        b.onclick = () => { 
          console.log('[emoji-picker] chosen', ch);
          onChoose(ch); 
          closeEmojiPicker(); 
        };
        grid.appendChild(b);
      });
    }

    // wire input
    input.addEventListener('input', e => renderGrid(e.target.value));
    renderGrid();

    document.body.appendChild(picker);

    // position relative to anchorEl (best-effort)
    try {
      const r = anchorEl.getBoundingClientRect();
      picker.style.left = `${Math.max(4, r.left)}px`;
      picker.style.top = `${r.bottom + window.scrollY + 6}px`;
    } catch (e) {
      /* ignore positioning errors */
    }

    // outside-click removal
    setTimeout(()=> window.addEventListener('click', outsideClick));
    function outsideClick(e) {
      if (!picker.contains(e.target) && e.target !== anchorEl) closeEmojiPicker();
    }
    picker._outsideFn = outsideClick;
  }

  function closeEmojiPicker() {
    const p = document.getElementById('emoji-picker');
    if (p) {
      window.removeEventListener('click', p._outsideFn);
      p.remove();
    }
  }

  function replaceAliasesInText(text) {
    return text.replace(/:([a-zA-Z0-9_+-]+):/g, (m, alias) => {
      const ch = EMOJI_ALIASES[alias.toLowerCase()];
      return ch || m;
    });
  }


  function isImageUrl(url){
    return /\.(png|jpe?g|gif|webp)$/i.test(url);
  }

  function isVideoUrl(url) {
    if (!url) return false;
    return /\.(mp4|webm|ogg)$/i.test(url);
  }

  document.getElementById('cancelReply').onclick = () => {
    replyTo = null;
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'none';
    const preview = document.getElementById('replyPreview');
    if (preview) preview.textContent = '';
    clearReferencedHighlight();
  };


  // REGISTER: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authRegister').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/register', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({username: u, password: p})
      });
      const j = await res.json();
      console.log('register result', res.status, j);

      if (res.ok && j.access_token) {
        localStorage.setItem('access_token', j.access_token);
        localStorage.setItem('username', j.username);
        document.getElementById('authStatus').textContent = `Registered & logged in as ${j.username}`;
        // hide auth UI
        const authBox = document.getElementById('authBox');
        if (authBox) authBox.style.display = 'none';
        // auto-connect
        try { await connectSocket(); } catch(e){ console.error('auto-connect failed', e); }
      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Register failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Register error — check server logs');
    }
  };

  // LOGIN: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authLogin').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ username: u, password: p })
      });
    const j = await res.json();
    console.log('login response', res.status, j);

    if (res.ok && j.access_token) {
      localStorage.setItem('access_token', j.access_token);
      localStorage.setItem('username', j.username);
      myId = j.username;
      showAppUI();

      document.getElementById('authStatus').textContent = `Logged in as ${j.username}`;

      // auto-connect
      try { 
        await connectSocket(); 
      } catch(e){ 
        console.error('auto-connect failed', e); 
        document.getElementById('authStatus').textContent = 'Login ok but failed to connect: ' + e;
        }

      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Login failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Login error — check server logs');
    }
  };
  
function resetChatUI(){
  //Clear DOM
  document.getElementById('container').innerHTML = '';
  document.getElementById('pinsContainer').innerHTML = '';
  closePinsPanel();
  document.getElementById('viewPinsBtn').textContent = 'Pins';

  // Clear client state
  for (const k in msgIndex) delete msgIndex[k];
  replyTo = null;

  // Clear input
  const input = document.getElementById('inputText');
  if (input) input.value = '';

  // Hide reply box
  document.getElementById('replyBox').style.display = 'none';
  document.getElementById('replyPreview').textContent = '';

  onlineUsers.clear();
  typingUsers.clear();
  renderPresence();
  renderTyping();
}

// centralized connect function
async function connectSocket() {
  const token = getToken()
  const storedUsername = localStorage.getItem('username');
  myId = storedUsername || myId;

  console.log('[connectSocket] token?', !!token, 'myId:', myId);
  console.log('[connectSocket] page protocol:', window.location.protocol, 'host:', window.location.host);

  if (!token || !myId) { showAuthUI(); return}

  const me = await fetchMe();
  if (!me) { showAuthUI(); return;}

  // if already connected, do nothing (or optionally re-open)
  if (socket && socket.readyState === WebSocket.OPEN) {
    showAppUI();
    document.getElementById('connectBtn').disabled = true;

    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) logoutBtn.style.display = 'inline-block';

    return;
  }


  document.getElementById('chatUI').style.display = 'block';
  document.getElementById('status').textContent = 'Connecting...'

  let roomId;

  try {
    const invitedRoom = await acceptInviteIfPresent();
    if (invitedRoom) {
      roomId = invitedRoom;
    } else {
      roomId = await ensureDefaultRoom();
    }
    roomMembers = await fetchRoomMembers(roomId);
    renderMembersSidebar();

  } catch (e) {
    console.error('[connectSocket] ensureDefaultRoom failed', e);
    document.getElementById('status').textContent = 'Failed to load rooms. See console.';
    // revert so user isn't stuck
    document.getElementById('chatUI').style.display = 'none';
    document.getElementById('authBox').style.display = 'block';
    throw e;
  }



  // build ws url relative to current page so it works on Render / localhost / prod
  const isSecure = (window.location.protocol === 'https:');
  const wsProto = isSecure ? 'wss' : 'ws';
  const host = window.location.host; // includes port if any

  const wsUrl = `${wsProto}://${host}/ws?token=${encodeURIComponent(token)}&room_id=${encodeURIComponent(roomId)}`;

  console.log('[connectSocket] opening', wsUrl);
  document.getElementById('status').textContent = 'Connecting...';
  socket = new WebSocket(wsUrl);

  // hydrate header from /me so display_name + avatar_color apply immediately
  try {
    if (me) {
      const shownName = me.display_name || me.username || myId;
      const headerUserEl = document.getElementById('headerUsername');
      const headerAvatarEl = document.getElementById('headerAvatar');

      if (headerUserEl) headerUserEl.textContent = shownName;
      if (headerAvatarEl) {
        headerAvatarEl.textContent = shownName ? shownName[0].toUpperCase() : '?';
        if (me.avatar_color) headerAvatarEl.style.background = me.avatar_color;
      }
    }
  } catch(e) {
    console.warn('fetchMe failed on connect', e);
  }

  setInterval(() => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "ping", t: Date.now() }));
    }
  }, 25000);

  socket.addEventListener('open', () => {

    ensureNotificationPermission();

    document.getElementById('appHeader').style.display = 'flex';
    document.getElementById('headerAvatar').style.display = 'flex';
    document.getElementById('status').textContent = 'Connected as ' + myId;

    // load favorite gifs
    loadFavoriteMap().then(() => {
      Object.values(msgIndex).forEach(m => {
        const key = getGifProviderKeyFromUrl(m.content || '');
        if (key) updateGifFavUI(key);
      });
    });

    // Show chat UI
    document.getElementById('chatUI').style.display = 'block';
    document.getElementById('status')

    // Hide auth UI
    document.getElementById('authBox').style.display = 'none';

    // Show logout
    document.getElementById('logoutBtn').style.display = 'inline-block';

    // Disable connect
    document.getElementById('connectBtn').disabled = true;

    // Voice UI
    setupVoiceUI();
    document.getElementById("voiceBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    updateVoiceButtons();


    attachInfiniteScroll();
  });

  socket.addEventListener('error', (ev) => {
    console.error('[WS] error', ev);
    document.getElementById('status').textContent = 'WS error (see console)';
  });

  socket.addEventListener('close', (ev) => {
    try { leaveVoice(); } catch(e) {}
    console.log('[WS] closed code=', ev.code, 'reason=', ev.reason, 'wasClean=', ev.wasClean);
    document.getElementById('status').textContent = `Disconnected (code ${ev.code})`;

    // if we never successfully connected, show auth UI again
    if (ev.code === 1008 || ev.code === 1006) {
      document.getElementById('chatUI').style.display = 'none';
      document.getElementById('authBox').style.display = 'block';
      document.getElementById('connectBtn').disabled = false;
    }

    if (ev.code === 1008) alert('Connection closed due to auth/policy (1008). Token may be invalid / expired.');
    document.getElementById("voiceBtn").disabled = true;
    document.getElementById("muteBtn").disabled = true;
  });

  socket.addEventListener('message', async (ev) => {
    // server sends JSON payloads
    console.log('WS incoming payload:', ev.data);

    let payload;
    try {
      payload = JSON.parse(ev.data);
    } catch (e) {
      console.warn('Non-JSON message', ev.data);
      return;
    }

    if (payload.type === 'history') {
      const msgs = payload.messages || [];
      const container = document.getElementById('container');
      const wrapper = document.querySelector('.chat-wrapper');

      container.innerHTML = ''; // clear
      msgs.forEach((m, i) => {
        const prev = i > 0 ? msgs[i-1] : null;
        const node = renderMessage(m, false, prev);
        showMessageElement(node);
      });

      const oldest = msgs.length ? msgs[0] : null;
      nextCursor = oldest ? oldest.timestamp : null;
      hasMoreHistory = true;

      ensureEndSpacer(container);
      return;
    }

    if (payload.type === "presence_snapshot") {
      onlineUsers.clear();
      (payload.online || []).forEach(u => onlineUsers.add(u));
      renderPresence();
      renderMembersSidebar();
      return;
    }

    if (payload.type === "presence") {
      if (payload.status === "online") onlineUsers.add(payload.user);
      else {
        onlineUsers.delete(payload.user);
        typingUsers.delete(payload.user);
      }
      renderPresence();
      renderTyping()
      renderMembersSidebar();
      return;
    }

    if (payload.type === "typing") {
      setUserTyping(payload.user, !!payload.is_typing);
      return;
    }



    if (payload.type === 'message') {

      if (!windowFocused) {
        unreadCount++;
        document.title = `(${unreadCount}) Chatterbox`;
      }

      if (!windowFocused && 'Notification' in window && Notification.permission === 'granted') {
        const profile = userDirectory[payload.author] || {};
        const name = profile.display_name || payload.author;
        new Notification(name, { body: (payload.content || '').toString().slice(0, 120) });
      }

      const container = document.getElementById('container');
      const lastMsgEl = container ? Array.from(container.children).reverse().find(x => x.id && x.id.startsWith('msg-')) : null;
      const lastId = lastMsgEl ? lastMsgEl.id.replace('msg-','') : null;
      const prev = lastId ? msgIndex[lastId] : null;

      const node = renderMessage(payload, false, prev);
      showMessageElement(node);
      return;
    }

    if (payload.type === 'delete') {
      const id = payload.id;
      const el = document.getElementById('msg-' + id);
      if (el) el.remove();          // remove from DOM so text shifts up
      if (msgIndex[id]) delete msgIndex[id];  // remove from index
      return;
    }

    if (payload.type === 'pin') {
      const id = payload.id;
      const msg = msgIndex[id];
      if (msg) {
        msg.pinned = payload.pinned;
        msg.pinned_by = payload.pinned_by || null;
        msg.pinned_at = payload.pinned_at || null;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      const pinsPanel = document.getElementById('pinsPanel');
      if (pinsPanel && pinsPanel.style.display === 'block') buildPinsUI();
      return;
    }

    if (payload.type === 'edit') {
      const id = payload.id;
      const content = payload.content;
      const edited_at = payload.edited_at;
      const msg = msgIndex[id];
      if (msg) {
        msg.content = content;
        msg.edited_at = edited_at;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'react') {
      hideReactionTooltip();

      const id = payload.id;
      const emoji = payload.emoji;
      const users = payload.users || [];
      const msg = msgIndex[id];
      if (msg) {
        msg.reactions = msg.reactions || {};
        if (!Array.isArray(users) || users.length === 0) {
          delete msg.reactions[emoji];
        } else {
          msg.reactions[emoji] = users;
        }
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'error') {
      alert('Server error: ' + (payload.error || 'unknown'));
      return;
    }

    if (payload.type === 'notice') {
      const n = document.createElement('div');
      n.textContent = payload.text;
      showMessageElement(n);
    }

    if (payload.type === "user_directory") {
      Object.assign(userDirectory, payload.users || {});
      renderPresence();
      renderTyping();
      renderMembersSidebar();
      return;
    }

    if (payload.type === "voice_snapshot") {
      // reset in_voice for everyone in this room
      // (keep muted/speaking as last known if you want; this resets in_voice accurately)
      roomMembers.forEach(m => {
        if (m.username) setVS(m.username, { in_voice: false });
      });

      voice.users.clear();
      (payload.users || []).forEach(u => {
        voice.users.add(u);
        setVS(u, { in_voice: true });
      });

      // If server includes states (recommended below), hydrate them:
      if (payload.states && typeof payload.states === 'object') {
        Object.entries(payload.states).forEach(([u, st]) => {
          if (!u || !st) return;
          setVS(u, {
            in_voice: true,
            muted: !!st.muted,
            speaking: !!st.speaking
          });
        });
      }

      renderMembersSidebar();

      // existing connect logic:
      if (voice.enabled) {
        ensureVideoTile(myId, true);
        showVideoOverlay(myId, !video.enabled);
        voice.users.forEach(async (u) => {
          if (!u || u === myId) return;
          ensureVideoTile(u, u === myId)
          if (shouldInitiateOffer(myId, u)) {
            try { await createAndSendOffer(u); } catch(e) { console.warn("[voice] offer failed", u, e); }
          } else {
            await ensurePeerConnection(u);
          }
        });
      }
      return;
    }

    if (payload.type === "voice_join") {
      const u = payload.user;
      if (u) {
        voice.users.add(u);
        setVS(u, { in_voice: true, muted: false, speaking: false });
      }
      renderMembersSidebar();

      if (!voice.enabled && u && u !== myId) {
        startRingtone(u);
      }

      if (voice.enabled && u && u !== myId) {
        ensureVideoTile(u, u === myId)
        if (shouldInitiateOffer(myId, u)) {
          try { await createAndSendOffer(u); } catch(e) { console.warn("[voice] offer failed", u, e); }
        } else {
          await ensurePeerConnection(u);
        }
      }
      return;
    }

    if (payload.type === "voice_leave") {
      const u = payload.user;
      if (u) {
        voice.users.delete(u);
        setVS(u, { in_voice: false, muted: false, speaking: false });
        closePeer(u);
        removeVideoTile(u);
      }
      renderMembersSidebar();

      if (incomingFromUser && u === incomingFromUser) {
        stopRingtone();
      }
      return;
    }


    if (payload.type === "voice_signal") {
      const from = payload.from;
      const data = payload.data || {};
      if (!voice.enabled) return;
      if (!from || from === myId) return;

      try {
        if (data.kind === "offer") await handleIncomingOffer(from, data.sdp);
        else if (data.kind === "answer") await handleIncomingAnswer(from, data.sdp);
        else if (data.kind === "ice") await handleIncomingIce(from, data.candidate);
        else if (data.kind === "renegotiate") {
          // Only the deterministic offerer should respond by making an offer
          if (shouldInitiateOffer(myId, from)) {
            await createAndSendOffer(from);
          }
        }
      } catch (e) {
        console.warn("[voice] signal handling failed", from, data.kind, e);
      }
      return;
    }

    if (payload.type === "voice_state") {
      const u = payload.user;
      if (!u) return;

      // speaking is ephemeral; optionally auto-expire after ~1s
      const patch = {};
      if (typeof payload.muted === 'boolean') patch.muted = payload.muted;
      if (typeof payload.speaking === 'boolean') patch.speaking = payload.speaking;

      if (typeof payload.screen === 'boolean') patch.screen = payload.screen;
      if (typeof payload.video === 'boolean') patch.video = payload.video;

      setVS(u, patch);
      renderMembersSidebar();

      if (patch.screen) {
      removeVideoTile(u);
      const t = ensureScreenTile(u, u === myId);

      if (stageState.theatre && !stageState.primaryNode) {
        const w = screenShare.wraps?.get(u);
        if (w) stageState.primaryNode = w;
        relayoutTheatre();
      }
    } else {
      removeScreenTile(u);

      if (getVS(u).in_voice) {
        const t = ensureVideoTile(u, u === myId);
        showVideoOverlay(u, true);

        if (stageState.theatre && !stageState.primaryNode) {
          // the newly created tile wrapper is in the DOM; grab it
          const tray = document.getElementById('videoStage');
          const w = document.querySelector(`.video-tile[data-user="${u}"]`);
          if (w) stageState.primaryNode = w;
          relayoutTheatre();
        }
      }

      // if theatre and nothing left, relayoutTheatre() will auto-exit
      if (stageState.theatre) relayoutTheatre();
    }

    // Optional: auto-expire speaking
    if (patch.speaking) {
      setTimeout(() => {
        const cur = getVS(u);
        if (cur.speaking) {
          setVS(u, { speaking: false });
          renderMembersSidebar();
        }
      }, 1200);
    }

      return;
    }
  });
}

  async function fetchMe() {
    const token = getToken();
    if (!token) {
      localStorage.removeItem('access_token');
      localStorage.removeItem('username');
      showAuthUI();
      throw new Error('Missing/invalid token; please log in again.');
    }
    const res = await fetch('/me', { headers: { token } });
    if (!res.ok) return null;
    return await res.json();
  }

  async function saveMe(patch) {
    const token = getToken();
    const res = await fetch('/me', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', token },
      body: JSON.stringify(patch)
    });
    const j = await res.json().catch(()=>({}));
    if (!res.ok) throw new Error(j.detail || 'save failed');
    return j;
  }

  async function ensureNotificationPermission() {
    if (!('Notification' in window)) return;
    if (Notification.permission === 'default') {
      try { await Notification.requestPermission(); } catch(e){}
    }
  }

  async function fetchRooms() {
    const token = getToken();
    const res = await fetch('/rooms', { headers: { token } });
    const j = await res.json().catch(() => ({}));

    if (res.status === 401) {
      // token invalid/stale — hard reset client auth state
      localStorage.removeItem('access_token');
      localStorage.removeItem('username');
      localStorage.removeItem('room_id');
      showAuthUI();
      throw new Error(j.detail || 'invalid token');
    }

    if (!res.ok) throw new Error(j.detail || `rooms fetch failed (${res.status})`);
    return j.results || [];
  }

  async function fetchRoomMembers(roomId) {
    const token = getToken();
    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/members`, { headers: { token }});
    if (!res.ok) return [];
    const j = await res.json();
    return j.results || [];
  }

  function renderMembersSidebar() {
    const sb = document.getElementById('membersSidebar');
    const list = document.getElementById('membersList');
    if (!sb || !list) return;
    if (document.getElementById('audioModal')?.style.display === 'block') renderAudioMixer();

    sb.style.display = 'block';
    list.innerHTML = '';

    const membersSorted = roomMembers.slice().sort((a,b) => (a.username||'').localeCompare(b.username||''));

    membersSorted.forEach(m => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '8px';

      const dot = document.createElement('div');
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.background = onlineUsers.has(m.username) ? '#3ddc84' : 'rgba(255,255,255,0.15)';

      const name = document.createElement('div');
      name.style.flex = '1';
      name.style.minWidth = '0';
      name.style.overflow = 'hidden';
      name.style.textOverflow = 'ellipsis';
      name.style.whiteSpace = 'nowrap';
      name.textContent = m.display_name || m.username;

      row.appendChild(dot);
      row.appendChild(name);

      // --- voice badges ---
      const badges = document.createElement('div');
      badges.className = 'member-badges';

      const vs = getVS(m.username);

      // in-voice badge (server-driven via snapshot/join/leave)
      if (vs.in_voice) {
        const b = document.createElement('span');
        b.className = 'badge badge-voice';
        b.textContent = 'Voice';
        badges.appendChild(b);
      }

      // muted badge
      if (vs.in_voice && vs.muted) {
        const b = document.createElement('span');
        b.className = 'badge badge-muted';
        b.textContent = 'Muted';
        badges.appendChild(b);
      }

      // speaking badge (only if in voice and not muted)
      if (vs.in_voice && !vs.muted && vs.speaking) {
        const b = document.createElement('span');
        b.className = 'badge badge-speaking';
        b.textContent = 'Speaking';
        badges.appendChild(b);
      }

      if (vs.in_voice && vs.screen) {
        const b = document.createElement('span');
        b.className = 'badge badge-voice';
        b.textContent = 'Screen';
        badges.appendChild(b);
      }

      if (vs.in_voice && audioPrefs.mutedUsers.has(m.username)) {
        const b = document.createElement('span');
        b.className = 'badge badge-muted';
        b.textContent = 'Muted (You)';
        badges.appendChild(b);
      }


      if (vs.in_voice && m.username && m.username !== myId) {
        const controls = document.createElement('div');
        controls.style.display = 'flex';
        controls.style.gap = '6px';
        controls.style.alignItems = 'center';

        const isUserMuted = audioPrefs.mutedUsers.has(m.username);

        const mu = document.createElement('button');
        mu.className = 'btn-small';
        mu.textContent = isUserMuted ? 'Unmute' : 'Mute';
        mu.title = 'Client-side mute (you only)';
        mu.onclick = (e) => { e.stopPropagation(); toggleUserMute(m.username); };
        controls.appendChild(mu);

        if (audioPrefs.deafened) {
          mu.disabled = true;
        }

        row.appendChild(controls);
      }
      row.appendChild(badges);
      list.appendChild(row);
    });
  }

  async function ensureDefaultRoom() {
    let rid = localStorage.getItem('room_id');

    const rooms = await fetchRooms();

        
    if (rid) {
      const ok = rooms.some(r => String(r.id) === String(rid));
      if (ok) return rid;

      localStorage.removeItem('room_id');
      rid = null;
    }

    // pick "general" if present, else first, else create it
    let general = rooms.find(r => (r.name || '').toLowerCase() === 'general');
    if (!general && rooms.length) general = rooms[0];

    if (!general) {
      const token = getToken();
      const cr = await fetch('/rooms', {
        method: 'POST',
        headers: { 'Content-Type':'application/json', token },
        body: JSON.stringify({ name: 'general' })
      });
      const cj = await cr.json();
      rid = cj.id;
    } else {
      rid = general.id;
    }

    localStorage.setItem('room_id', rid);
    return rid;
  }

  async function switchRoom(newRoomId) {
    if (!newRoomId) return;
    localStorage.setItem('room_id', newRoomId);

    // disconnect existing WS
    if (socket) { try { socket.close(); } catch(e){} socket = null; }

    // reset UI
    resetChatUI();

    // reconnect
    await connectSocket();

    roomMembers = await fetchRoomMembers(newRoomId);
    renderMembersSidebar();
  }

  function minuteKey(isoTs) {
    const d = new Date(isoTs);
    if (Number.isNaN(d.getTime())) return null;
    return `${d.getFullYear()}-${d.getMonth()}-${d.getDate()} ${d.getHours()}:${d.getMinutes()}`;
  }

  // Show time only if it differs from the previous rendered message.
  // If alsoSameAuthor=true, we only hide when both minute and author match.
  function shouldShowTimestamp(prevMsg, curMsg, alsoSameAuthor=true) {
    if (!prevMsg) return true;
    const a = minuteKey(prevMsg.timestamp);
    const b = minuteKey(curMsg.timestamp);
    if (!a || !b) return true;
    if (a !== b) return true;
    if (alsoSameAuthor && prevMsg.author !== curMsg.author) return true;
    return false;
  }



  // send on Enter (Shift+Enter for newline) — attach once on initial load
  (function attachEnterSend() {
    const inputEl = document.getElementById('inputText');
    
    if (!inputEl) return;
    inputEl.addEventListener('keydown', (e) => {
      // Enter without Shift -> send
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('submitButton').click();
      }
    });
  })();

  let typingTimer = null;
  let typingState = false;

  function sendTyping(isTyping) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "typing", is_typing: isTyping }))
  }

  const inputEl = document.getElementById('inputText');
  inputEl.addEventListener('input', () => {
    if (!typingState) {
      typingState = true;
      sendTyping(true);
    }
    clearTimeout(typingTimer);
    typingTimer = setTimeout(() => {
      typingState = false;
      sendTyping(false);
    }, 1200);
  });



  // minimal connect button behavior now calls connectSocket()
  document.getElementById('connectBtn').onclick = () => {
    connectSocket();
  };

  document.getElementById('roomsBtn').onclick = async () => {
    try {
      const rooms = await fetchRooms();
      const list = document.getElementById('roomsList');
      list.innerHTML = '';
      const current = localStorage.getItem('room_id');

      rooms.forEach(r => {
        const row = document.createElement('button');
        row.className = 'btn-small';
        row.textContent = (r.id === current) ? `✓ ${r.name}` : r.name;
        row.onclick = async () => {
          document.getElementById('roomsModal').style.display = 'none';
          await switchRoom(r.id);
        };
        list.appendChild(row);
      });

      document.getElementById('roomsModal').style.display = 'block';
    } catch (e) {
      alert('Failed to load rooms: ' + e);
    }
  };

  document.getElementById('closeRooms').onclick = () => {
    document.getElementById('roomsModal').style.display = 'none';
  };

  document.getElementById('createRoomBtn').onclick = async () => {
    const name = (document.getElementById('newRoomName').value || '').trim();
    if (!name) return;

    const token = getToken();
    const res = await fetch('/rooms', {
      method: 'POST',
      headers: { 'Content-Type':'application/json', token },
      body: JSON.stringify({ name })
    });
    const j = await res.json().catch(()=>({}));
    if (!res.ok) {
      document.getElementById('roomsMsg').textContent = 'Create failed: ' + (j.detail || res.status);
      return;
    }
    document.getElementById('roomsMsg').textContent = `Created: ${j.name}`;
    document.getElementById('newRoomName').value = '';
    // refresh list
    document.getElementById('roomsBtn').click();
  };


  document.getElementById('settingsBtn').onclick = async () => {
    const me = await fetchMe();
    if (!me) return alert('Failed to load profile');
    document.getElementById('setDisplayName').value = me.display_name || '';
    document.getElementById('setStatus').value = me.status || '';
    document.getElementById('setAvatarColor').value = me.avatar_color || '';
    document.getElementById('setBio').value = me.bio || '';
    document.getElementById('settingsModal').style.display = 'block';
  };

  document.getElementById('closeSettings').onclick = () => {
  document.getElementById('settingsModal').style.display = 'none';
  };

  document.getElementById('saveSettings').onclick = async () => {
    const patch = {
      display_name: document.getElementById('setDisplayName').value,
      status: document.getElementById('setStatus').value,
      avatar_color: document.getElementById('setAvatarColor').value,
      bio: document.getElementById('setBio').value
    };
    try {
      const me = await saveMe(patch);
      // update local cache so UI reflects immediately
      userDirectory[me.username] = {
        display_name: me.display_name,
        status: me.status,
        avatar_color: me.avatar_color
      };
      document.getElementById('settingsMsg').textContent = 'Saved.';
      // refresh header avatar/name instantly
      const headerUserEl = document.getElementById('headerUsername');
      if (headerUserEl) headerUserEl.textContent = (me.display_name || me.username);
      const headerAvatarEl = document.getElementById('headerAvatar');
      if (headerAvatarEl) {
        headerAvatarEl.textContent = (me.display_name || me.username)[0].toUpperCase();
        if (me.avatar_color) headerAvatarEl.style.background = me.avatar_color;
      }
    } catch (e) {
      document.getElementById('settingsMsg').textContent = String(e.message || e);
    }
  };

  document.getElementById('audioBtn').onclick = async () => {
    // Ensure we have permission at least once so labels appear.
    try {
      if (!voice.localStream) {
        await navigator.mediaDevices.getUserMedia({ audio: true });
      }
    } catch(e) {
      // user may decline; still show modal (device labels may be blank)
    }

    const savedMic = localStorage.getItem('mic_device_id') || '';
    const savedSpk = localStorage.getItem('spk_device_id') || '';
    const savedGain = parseFloat(localStorage.getItem('mic_gain') || '1');

    document.getElementById('micGain').value = String(savedGain);
    document.getElementById('micGainVal').textContent = `${savedGain.toFixed(2)}x`;

    const { mics, spks } = await listDevices();
    fillSelect(document.getElementById('micSelect'), mics, savedMic);
    fillSelect(document.getElementById('spkSelect'), spks, savedSpk);

    // Hide speaker select if unsupported
    const anySink = Array.from(voice.sinks.values())[0];
    if (!supportsSetSinkId(anySink)) {
      document.getElementById('spkSelect').innerHTML = '';
    }

    document.getElementById('audioModal').style.display = 'block';
  };

  document.getElementById('applyAudio').onclick = async () => {
    const micId = document.getElementById('micSelect').value || '';
    const spkId = document.getElementById('spkSelect').value || '';
    const gain  = parseFloat(document.getElementById('micGain').value || '1');
    const echo  = document.getElementById('optEcho').checked;
    const noise = document.getElementById('optNoise').checked;
    const agc   = document.getElementById('optAgc').checked;

    localStorage.setItem('mic_device_id', micId);
    localStorage.setItem('spk_device_id', spkId);
    localStorage.setItem('mic_gain', String(gain));
    localStorage.setItem('opt_echo', String(echo));
    localStorage.setItem('opt_noise', String(noise));
    localStorage.setItem('opt_agc', String(agc));

    try {
      // Rebuild outgoing audio stream and swap tracks live if in voice
      const out = await buildOutgoingAudioStream({ micDeviceId: micId, echo, noise, agc, gain });
      voice.localStream = out;

      if (voice.enabled) {
        const newTrack = out.getAudioTracks()[0];
        await replaceOutgoingAudioTrackOnPeers(newTrack);

        // honor mute state
        newTrack.enabled = !voice.muted;
      }

      // Apply speaker output selection to every remote audio element
      for (const el of voice.sinks.values()) {
        if (supportsSetSinkId(el) && spkId) {
          try { await el.setSinkId(spkId); } catch(e) {}
        }
      }

      applyAudioPrefsToAllSinks();

      document.getElementById('audioMsg').textContent = 'Applied.';
    } catch (e) {
      console.error(e);
      document.getElementById('audioMsg').textContent = 'Failed to apply audio settings. See console.';
    }
  };

  document.getElementById('closeAudio').onclick = () => {
    document.getElementById('audioModal').style.display = 'none';
  };

  document.getElementById('micGain').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('micGainVal').textContent = `${v.toFixed(2)}x`;
  });

  document.getElementById('cameraBtn').onclick = () => startCamera().catch(e => {
    console.error(e);
    alert('Camera failed. Check permissions and HTTPS.');
  });

  document.getElementById('camOffBtn').onclick = () => stopCamera();

  document.getElementById('shareBtn').onclick = () => startScreenShare().catch(console.error);
  document.getElementById('stopShareBtn').onclick = () => stopScreenShare();

  document.getElementById('submitButton').onclick = () => {
    const input = document.getElementById('inputText');
    const text = input.value.trim();
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      alert('Not connected');
      return;
    }
    if (!text && !replyTo) return;
    const raw = input.value.trim();
    const contentToSend = replaceAliasesInText(raw);
    socket.send(JSON.stringify({ type: 'message', content: contentToSend, reply_to: replyTo || null }));

    input.value = '';
    
    setTimeout(()=> {
      const container= document.getElementById('container');
      const wrapper = container ? (container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper')) : null;
      if (wrapper) wrapper.scrollTop = wrapper.scrollHeight;
    }, 50);

    // reset reply UI
    replyTo = null;
    document.getElementById('replyBox').style.display = 'none';
    document.getElementById('replyPreview').textContent = '';

    typingState = false;
    sendTyping(false);
  };

  function buildPinsUI() {
    const pinsContainer = document.getElementById('pinsContainer');
    pinsContainer.innerHTML = '';

    const pinned = Object.values(msgIndex)
      .filter(m => m && m.pinned && !m.deleted)
      .sort((a, b) => {
        // newest pinned first
        const at = a.pinned_at ? Date.parse(a.pinned_at) : 0;
        const bt = b.pinned_at ? Date.parse(b.pinned_at) : 0;
        return bt - at;
      });

    if (!pinned.length) {
      const empty = document.createElement('div');
      empty.style.color = 'var(--muted)';
      empty.style.padding = '8px';
      empty.textContent = 'No pinned messages yet.';
      pinsContainer.appendChild(empty);
      return;
    }

    pinned.forEach(m => {
      const node = renderMessage(m);

      // Make the whole pin entry clickable → jump to message in main chat
      node.style.cursor = 'pointer';
      node.addEventListener('click', (ev) => {
        // don’t steal clicks meant for buttons inside the pin (fav/reaction/etc)
        const tag = (ev.target && ev.target.tagName || '').toLowerCase();
        if (tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'a') return;

        closePinsPanel();
        scrollToMessageId(m.id);
      });

      pinsContainer.appendChild(node);
    });
  }


  function openPinsPanel() {
    const pinsPanel = document.getElementById('pinsPanel');
    const pinsBtn = document.getElementById('viewPinsBtn');
    const gifPicker = document.getElementById('gifPicker');

    buildPinsUI();
    // position under Pins button; make width match gif picker when it's present
    positionPanelUnderButton(pinsPanel, pinsBtn, gifPicker);
    setPinsButtonState(true);

    // close on outside click
    setTimeout(() => {
      function outside(e){
        if (!pinsPanel.contains(e.target) && e.target !== pinsBtn) {
          closePinsPanel();
          window.removeEventListener('click', outside);
        }
      }
      window.addEventListener('click', outside);
      pinsPanel._outside = outside;
    }, 0);
  }

  function closePinsPanel() {
    const pinsPanel = document.getElementById('pinsPanel');
    if (pinsPanel) {
      pinsPanel.style.display = 'none';
      if (pinsPanel._outside) window.removeEventListener('click', pinsPanel._outside);
    }
    setPinsButtonState(false);
  }

  document.getElementById('viewPinsBtn').onclick = () => {
    const pinsPanel = document.getElementById('pinsPanel');
    const open = pinsPanel.style.display === 'block';
    if (open) closePinsPanel();
    else openPinsPanel();
  };

  document.getElementById('closePins').onclick = () => closePinsPanel();


  document.getElementById('fileInput').onchange = async (e) => {
    const file = e.target.files[0];
    if (!file || !socket) return;

    const token = getToken();
    if (!token) { alert('Log in to upload files'); return; }

    const formData = new FormData();
    formData.append("file", file);

    const res = await fetch("/upload", {
      method: "POST",
      headers: { token },
      body: formData
    });

    if (!res.ok) {
      const j = await res.json().catch(()=>({}));
      alert('Upload failed: ' + (j.detail || res.status));
      return;
    }

    const data = await res.json();

    socket.send(JSON.stringify({
      type: "message",
      content: data.url
    }));

    e.target.value = '';
  };

document.getElementById('logoutBtn').onclick = () => {
  if (socket) {
    try { leaveVoice(); } catch(e){}
    try { socket.close(); } catch(e){}
    socket = null;
  }

  localStorage.removeItem('access_token');
  localStorage.removeItem('username');

  // Reset UI + state
  resetChatUI();

  showAuthUI();
};
</script>
</body>
</html>