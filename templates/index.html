<!DOCTYPE html>
<html lang="en">
<head>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
    :root{
      --bg:#0f1115;
      --panel:#111216;
      --muted:#9aa0a6;
      --accent:#4f9fff;
      --text:#f6f7f9;
      --subtle:#2a2d31;
      --composer-height:84px;
      --header-height:52px;
      --stage-height: 0px;
    }

    html,body {
      height:100%;
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:var(--text);
      /* IMPORTANT: force outer document not to scroll so only .chat-wrapper scrolls */
      overflow: hidden;
    }
    h1 { margin:12px; color:var(--text); font-size:20px; }

    /* Header pinned top */
    .app-header {
      position:sticky;
      top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding:8px 12px;
      background: var(--panel);
      border-bottom:1px solid rgba(255,255,255,0.03);
      z-index:30;
    }
    .header-left { display:flex; align-items:center; gap:8px; }
    .header-username { font-weight:600; color:var(--text); }
    .header-right { display:flex; align-items:center; gap:8px; }

    /* Buttons */
    .btn-small { background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; cursor:pointer; }
    .btn-primary { background:var(--accent); color:#041427; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }

    /* chat area (same) */
    .chat-wrapper {
      position: fixed;
      left: 0;
      right: 260px;
      top: calc(var(--header-height) + var(--stage-height));
      bottom: calc(var(--composer-height) + 12px);
      padding: 12px;
      overflow: auto;
    }

    .presenceLine { color:var(--muted); font-size:12px;}
    .typingLine { color:var(--muted); font-size:12px;}

    .status-line { font-size:13px; color:var(--muted); margin-bottom:6px; }

    .messages { display:flex; flex-direction:column; gap:8px; }

    /* Message */
    .message {
      display:flex;
      gap:10px;
      align-items:flex-start;
      background: linear-gradient(180deg, rgba(255,255,255,0.005), rgba(255,255,255,0.002));
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      position:relative;
    }
    .avatar { width:40px; height:40px; border-radius:50%; background:var(--subtle); color:var(--text); display:flex; align-items:center; justify-content:center; font-weight:700; }
    .avatar.small { width:32px; height:32px; font-size:12px; }

    .message-body { flex:1; min-width:0; }
    .meta { display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted); margin-bottom:6px; }
    .meta .name { color:var(--text); font-weight:600; }
    .meta .time { color:var(--muted); font-size:12px; }

    .edited { color:var(--muted); font-size:12px; margin-left:6px; font-style:italic; }

    .content { color:var(--text); line-height:1.35; word-break:break-word; }

    .quote { background:#0c0d0f; padding:6px; border-left:3px solid #222; margin-bottom:6px; color:var(--muted); border-radius:6px; }

    /* Reactions stay visible — actions hide into menu */
    .reactions { margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
    .reactions button { color:var(--text); border:1px solid rgba(255,255,255,0.03); padding:4px 6px; border-radius:6px; cursor:pointer; background:transparent; }


    /* Actions under message are hidden (moved into contextual menu) */
    .message .msg-actions { display:none; }

    /* ellipsis button appears on hover */
    .msg-menu-btn {
      display:none;
      position:absolute;
      right:8px;
      top:8px;
      background:transparent;
      border:none;
      color:var(--muted);
      font-size:18px;
      cursor:pointer;
    }
    .message:hover .msg-menu-btn { display:inline-block; }

    /* lighten message slightly on hover so cursor movement is visible */
    .message:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
      transition: filter 120ms ease, transform 120ms ease;
      cursor: default;
    }

    /* Context menu styling */
    .context-menu {
      position:absolute;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.04);
      padding:6px;
      border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,0.6);
      z-index: 10000;
      min-width:160px;
    }
    .context-menu button {
      display:block;
      width:100%;
      text-align:left;
      background:transparent;
      border:none;
      color:var(--text);
      padding:8px;
      cursor:pointer;
      border-radius:6px;
    }
    .context-menu button:hover { background:rgba(255,255,255,0.02); }

    /* Composer pinned */
    .composer {
      position:fixed;
      left:12px;
      right:12px;
      bottom:6px;
      height:var(--composer-height);
      display:flex;
      gap:8px;
      padding:10px;
      align-items:center;
      background: var(--panel);           /* solid panel */
      border:1px solid rgba(255,255,255,0.02);
      border-radius:10px;
      z-index:40;
    }
    .composer-left, .composer-right { display:flex; gap:8px; align-items:center; }
    .composer-middle { flex:1; }
    #inputText { width:100%; height:100%; resize:none; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:var(--text); outline:none; background:transparent; }

    /* pinned reply box just above composer */
    .reply-box, #replyBox {
      position:fixed;
      left:12px;
      right:12px;
      bottom: calc(var(--composer-height) + 10px);
      background: var(--panel);
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      color:var(--text);
      z-index:42;
      display:flex;
      align-items:center;
      gap:12px;
    }

    /* highlight referenced message so user sees context */
    .message.referenced {
      outline: 2px solid rgba(79,159,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.008));
      transition: background 180ms ease, outline 180ms ease;
    }

    input[type="file"] { color:var(--text); }

    /* Pins panel */
    .pins-panel { 
      position: fixed;                 /* will be positioned by JS */
      width: min(46vw, 540px);         /* match GIF picker width */
      max-height: 52vh;
      overflow: auto;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 8px;
      z-index: 9999;
      box-shadow: 0 12px 36px rgba(0,0,0,0.6);
      display:none;
    }
    .pins-panel .pins-header{
      position: sticky;
      top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.02);
      z-index: 3;
    }
    .pins-panel .pins-body{
      padding:8px;
    }

    /* --- Voice indicators in Members list --- */
    .member-badges {
      display:flex;
      align-items:center;
      gap:6px;
      flex: 0 0 auto;
    }

    .badge {
      font-size:11px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.06);
      color: var(--text);
      background: rgba(255,255,255,0.02);
      line-height: 1.4;
      user-select:none;
    }

    .badge-voice {
      border-color: rgba(79,159,255,0.25);
      background: rgba(79,159,255,0.08);
    }

    .badge-muted {
      border-color: rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
    }

    .badge-speaking {
      border-color: rgba(61,220,132,0.30);
      background: rgba(61,220,132,0.12);
      position: relative;
    }

    .badge-speaking::after {
      content:"";
      display:inline-block;
      width:6px;
      height:6px;
      margin-left:6px;
      border-radius:50%;
      background: rgba(61,220,132,0.95);
      box-shadow: 0 0 0 0 rgba(61,220,132,0.60);
      animation: voicePulse 1.1s ease-out infinite;
    }

    @keyframes voicePulse {
      0%   { box-shadow: 0 0 0 0 rgba(61,220,132,0.55); }
      70%  { box-shadow: 0 0 0 10px rgba(61,220,132,0.00); }
      100% { box-shadow: 0 0 0 0 rgba(61,220,132,0.00); }
    }

    /* GIF picker layout & pinned header */
    #gifPicker {
      background: var(--panel);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.03);
      border-radius:8px;
      box-shadow:0 12px 36px rgba(0,0,0,0.6);
      z-index: 9999;
      overflow: hidden;

      max-width: 560px;
      width: min(46vw, 540px);

      /* IMPORTANT: lock layout so only grid scrolls */
      display: flex;
      flex-direction: column;
    }

    /* header pinned to the top of the picker (stays visible) */
    #gifPicker .picker-header {
      position: sticky;
      top: 0;
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.02);
      z-index: 3;
      flex: 0 0 auto;
    }

    /* the grid area scrolls independently */
    #gifPicker #gifGrid {
      padding: 8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;

      overflow:auto;

      flex: 1 1 auto;
      max-height: 52vh; /* will be dynamically clamped by JS too */
    }

    /* small tweak so picker right edge lines up visually with button */
    #gifPicker.align-right { transform-origin: top right; }

    .message .msg-actions {display:none; }

    /* small helpers */
    .btn-small:active, .btn-primary:active { transform:translateY(1px); }
    a { color:var(--accent); }
    .messages-end-spacer { height: calc(var(--composer-height) - 12px); flex-shrink:0; }

    #videoStage {
      position: fixed;
      left: 0;
      right: 260px;
      top: var(--header-height);
      height: var(--stage-height);
      display: none;
      gap: 8px;
      padding: 8px;
      background: rgba(0,0,0,0.15);
      z-index: 34;
      overflow: auto;
    }

    </style>
</head>

<body>
  <div id="authBox" style="margin-bottom:12px;">
    <input id="authUser" placeholder="username" />
    <input id="authPass" type="password" placeholder="password" />
    <button id="authRegister">Register</button>
    <button id="authLogin">Login</button>
    <span id="authStatus" style="margin-left:8px;color:#777;"></span>
  </div>

  <div id="chatUI" style="display:none;">
    <!-- Header (pinned top after login) -->
    <header id="appHeader" class="app-header" style="display:none;">
      <div class="header-left">
        <div id="headerAvatar" class="avatar small">?</div>
        <div id="headerUsername" class="header-username"></div>
      </div>

      <div id="membersSidebar" style="
        position:fixed; top:var(--header-height); right:0; bottom:0;
        width:260px; background:var(--panel);
        border-left:1px solid rgba(255,255,255,0.03);
        padding:10px; overflow:auto; display:none; z-index:35;">
        <div style="font-weight:700; margin-bottom:8px;">Members</div>
        <div id="membersList" style="display:grid; gap:8px;"></div>
      </div>


      <div class="header-right">
        <button id="voiceBtn" class="btn-small">Voice</button>
        <button id="muteBtn" class="btn-small" style="display:none;">Mute</button>

        <button id="audioBtn" class="btn-small">Audio</button>

        <button id="cameraBtn" class="btn-small">Camera</button>
        <button id="camOffBtn" class="btn-small" style="display:none;">Stop Cam</button>

        <button id="viewPinsBtn" class="btn-small">Pins</button>
        <button id="roomsBtn" class="btn-small">Rooms</button>
        <button id="inviteBtn" class="btn-small">Invite</button>
        <button id="settingsBtn" class="btn-small">Settings</button>
        <button id="connectBtn" class="btn-small">Connect</button>
        <button id="logoutBtn" class="btn-small">Logout</button>
      </div>


      <div id="settingsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Profile</div>
            <button id="closeSettings" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:grid; gap:8px;">
            <input id="setDisplayName" placeholder="Display name" />
            <input id="setStatus" placeholder="Status (e.g. chilling)" maxlength="32" />
            <input id="setAvatarColor" placeholder="Avatar color (e.g. #4f9fff)" />
            <textarea id="setBio" placeholder="Bio" rows="3"></textarea>
            <button id="saveSettings" class="btn-primary">Save</button>
            <div id="settingsMsg" style="color:var(--muted); font-size:12px;"></div>
          </div>
        </div>
      </div>

      <div id="audioModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Audio Settings</div>
            <button id="closeAudio" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:grid; gap:10px;">
            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Microphone</span>
              <select id="micSelect"></select>
            </label>

            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Speaker / Output</span>
              <select id="spkSelect"></select>
              <div style="color:var(--muted); font-size:12px;">If this is empty, your browser may not support output device selection.</div>
            </label>

            <label style="display:grid; gap:6px;">
              <span style="color:var(--muted); font-size:12px;">Mic Gain</span>
              <input id="micGain" type="range" min="0" max="2" step="0.05" value="1">
              <div id="micGainVal" style="color:var(--muted); font-size:12px;">1.00x</div>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optEcho" type="checkbox" checked>
              <span>Echo cancellation</span>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optNoise" type="checkbox" checked>
              <span>Noise suppression</span>
            </label>

            <label style="display:flex; gap:10px; align-items:center;">
              <input id="optAgc" type="checkbox" checked>
              <span>Auto gain control</span>
            </label>

            <button id="applyAudio" class="btn-primary">Apply</button>
            <div id="audioMsg" style="color:var(--muted); font-size:12px;"></div>
          </div>
        </div>
      </div>

      <div id="roomsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20000;">
        <div style="max-width:520px; margin:8vh auto; background:var(--panel); border:1px solid rgba(255,255,255,0.05); border-radius:12px; padding:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Rooms</div>
            <button id="closeRooms" class="btn-small">Close</button>
          </div>

          <div style="margin-top:10px; display:flex; gap:8px;">
            <input id="newRoomName" placeholder="new room name" style="flex:1;" />
            <button id="createRoomBtn" class="btn-primary">Create</button>
          </div>

          <div id="roomsList" style="margin-top:12px; display:grid; gap:8px;"></div>
          <div id="roomsMsg" style="color:var(--muted); font-size:12px; margin-top:8px;"></div>
        </div>
      </div>
    </header>

    <!-- Main chat area -->
    <main class="chat-wrapper">
      <div id="status" class="status-line"></div>
      <div id="presenceLine" class="presenceLine"></div>
      <div id="typingLine" class="typingLine"></div>
      <div id="container" class="messages"></div>
    </main>

    <div id="videoStage" style="
      position:fixed; left:0; right:260px;
      top:var(--header-height); height:220px;
      display:none; gap:8px; padding:8px;
      background:rgba(0,0,0,0.15);
      z-index:34; overflow:auto;">
    </div>

    <!-- Pins panel toggled via View Pins -->
    <div id="pinsPanel" class="pins-panel" style="display:none;">
      <div class="pins-header">
        <div style="font-weight:600;">Pinned</div>
        <button id="closePins" class="btn-small">Close</button>
      </div>
      <div id="pinsContainer" class="pins-body"></div>
    </div>


    <!-- Reply preview small area above composer -->
    <div id="replyBox" class="reply-box" style="display:none;">
      Replying to: <span id="replyPreview"></span>
      <button id="cancelReply">Cancel</button>
    </div>

    <!-- Composer (pinned to bottom) -->
    <div id="composer" class="composer">
      <div class="composer-left">
        <input id="fileInput" type="file" accept="image/*" title="Attach file" />
        
      </div>
      <div class="composer-middle">
        <textarea id="inputText" placeholder="Type a message..." rows="2"></textarea>
      </div>
      <div class="composer-right">
        <button id="gifBtn" title="GIF">GIF</button>
        <button id="submitButton" class="btn-primary">Send</button>
      </div>
    </div>

    <!-- GIF picker (positioning unchanged) -->
    <div id="gifPicker" style="display:none; position:fixed;"></div>

    <div id="voiceAudioSinks" style="display:none;"></div>
  </div>


<script>

  let socket = null;
  let myId = null;
  let replyTo = null;
  const msgIndex = {}; //id

  let EMOJI_LIST = [];
  let EMOJI_ALIASES = {};

  const userDirectory = {}; //username -> profile
  
  let unreadCount = 0;
  let windowFocused = true;

  let hasMoreHistory = true;
  let nextCursor = null;
  let loadingOlder = false;

  let micAudioCtx = null;
  let micAnalyser = null;
  let micData = null;
  let micLoopHandle = null;

  let lastSentSpeaking = null;
  let lastSpeakingFlipAt = 0;


  const voice = {
    enabled: false,
    muted: false,
    localStream: null,
    pcs: new Map(),          // username -> RTCPeerConnection
    sinks: new Map(),        // username -> HTMLAudioElement
    users: new Set(),        // usernames currently in voice (from server snapshot + join/leave)
  };

  window.addEventListener('focus', () => { windowFocused = true; unreadCount = 0; document.title = 'Chat'});
  window.addEventListener('blur', () => { windowFocused = false; });

  async function fetchRoomMessagesPage(roomId, before=null, limit=50) {
    const token = getToken();
    const qs = new URLSearchParams();
    if (before) qs.set('before', before);
    qs.set('limit', String(limit));

    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/messages?` + qs.toString(), {
      headers: { token }
    });
    if (!res.ok) {
      const j = await res.json().catch(()=>({}));
      throw new Error(j.detail || `history fetch failed (${res.status})`);
    }
    return await res.json(); // {messages, has_more, next_cursor}
  }

  async function loadFavoriteMap() {
    favoriteMap = {};
    const token = getToken();
    if (!token) return;
    try {
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) return;
      const j = await res.json();
      (j.results || []).forEach(f => {
        const fid = f.id;

        if (f.gif_id) favoriteMap[String(f.gif_id)] = fid;

        if (f.url) favoriteMap[String(f.url)] = fid;

        const orig = f.metadata && f.metadata.original_gif_id;
        if (orig) favoriteMap[String(orig)] = fid;
      });
      console.log('[favorites] loaded', Object.keys(favoriteMap).length);
    } catch (e) {
      console.warn('[favorites] load failed', e);
    }
  }

  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  function getToken() {
    const t = localStorage.getItem('access_token');
    if (!t || t === 'null' || t === 'undefined' || t.length < 20) return null;
    return t;
  }

  function getBottomSafeY() {
    const composer = document.getElementById('composer');
    const replyBox = document.getElementById('replyBox');

    let bottom = window.innerHeight - 8;

    if (composer) {
      bottom = Math.min(bottom, composer.getBoundingClientRect().top - 10);
    }
    // if reply box is visible, keep picker above it too
    if (replyBox && replyBox.style.display !== 'none') {
      bottom = Math.min(bottom, replyBox.getBoundingClientRect().top - 10);
    }
    return bottom;
  }


  function getTopSafeY() {
    const header = document.getElementById('appHeader');
    const headerH = header && header.style.display !== 'none'
      ? header.getBoundingClientRect().height
      : 0;
    return Math.max(8, Math.round(headerH + 8));
  }

  function positionPanelUnderButton(panelEl, btnEl, preferredWidthEl=null) {
    if (!panelEl || !btnEl) return;

    panelEl.style.position = 'fixed';
    panelEl.style.display = 'block';

    // measure after display
    const btn = btnEl.getBoundingClientRect();
    const panelRect = panelEl.getBoundingClientRect();

    // width alignment: match GIF picker if desired
    if (preferredWidthEl) {
      const cs = window.getComputedStyle(preferredWidthEl);
      const w = preferredWidthEl.getBoundingClientRect().width;

      if (cs.display !== 'none' && w > 120) {
        panelEl.style.width = `${Math.round(w)}px`;
      } else {
        panelEl.style.width = '';
      }
    }

    // recompute after potential width change
    const rect = panelEl.getBoundingClientRect();

    // align right edge to button right edge (like dropdowns)
    let left = Math.round(btn.right - rect.width);
    left = clamp(left, 8, window.innerWidth - rect.width - 8);

    // place below button; if not enough room, flip above
    const belowTop = Math.round(btn.bottom + 8);
    const aboveTop = Math.round(btn.top - rect.height - 8);

    let top = belowTop;
    if (belowTop + rect.height > window.innerHeight - 8 && aboveTop >= 8) {
      top = aboveTop;
    }
    const bottomSafe = getBottomSafeY ? getBottomSafeY() : (window.innerHeight - 8);
    top = clamp(top, 8, bottomSafe - rect.height);

    panelEl.style.left = `${left}px`;
    panelEl.style.top = `${top}px`;
  }

  function prependMessages(container, wrapper, msgs) {
    if (!container || !wrapper || !msgs.length) return;

    // Record the current scroll offset from top-of-container content
    const prevScrollHeight = wrapper.scrollHeight;
    const prevScrollTop = wrapper.scrollTop;

    // Render in reverse so that final DOM order is oldest->newest at the top
    // IMPORTANT: API returns newest->oldest; we want older messages to appear above current ones
    const frag = document.createDocumentFragment();

    const toInsert = msgs.slice().reverse();
    toInsert.forEach(m => {
      if (m.deleted) return;
      msgIndex[m.id] = m;
      const node = renderMessage(m);
      frag.appendChild(node);
    });

    container.prepend(frag);

    // Keep the user at the same visible content position
    const newScrollHeight = wrapper.scrollHeight;
    wrapper.scrollTop = prevScrollTop + (newScrollHeight - prevScrollHeight);
  }

  function getVS(username) {
    const cur = voiceState.get(username);
    if (cur) return cur;
    const init = { in_voice: false, muted: false, speaking: false };
    voiceState.set(username, init);
    return init;
  }

  function setVS(username, patch) {
    const cur = getVS(username);
    Object.assign(cur, patch);
    voiceState.set(username, cur);
  }

  function sendVoiceState(patch) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "voice_state", ...patch }));
  }

  function startMicActivityMonitor() {
    stopMicActivityMonitor();

    if (!voice.enabled || !voice.localStream) return;

    micAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = micAudioCtx.createMediaStreamSource(voice.localStream);

    micAnalyser = micAudioCtx.createAnalyser();
    micAnalyser.fftSize = 1024;
    micAnalyser.smoothingTimeConstant = 0.8;

    src.connect(micAnalyser);

    micData = new Uint8Array(micAnalyser.fftSize);

    const THRESHOLD = 0.030;         // tweak as needed
    const MIN_FLIP_MS = 220;         // debounce flips
    const SEND_INTERVAL_MS = 250;    // throttle outbound state

    let lastSendAt = 0;

    function tick() {
      if (!micAnalyser || !micData) return;

      // If muted, force speaking false
      if (voice.muted) {
        maybeSend(false);
        micLoopHandle = requestAnimationFrame(tick);
        return;
      }

      micAnalyser.getByteTimeDomainData(micData);

      // Compute RMS in [0,1]
      let sum = 0;
      for (let i = 0; i < micData.length; i++) {
        const v = (micData[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / micData.length);

      const isSpeaking = rms >= THRESHOLD;
      maybeSend(isSpeaking);

      micLoopHandle = requestAnimationFrame(tick);
    }

    function maybeSend(isSpeaking) {
      const now = Date.now();

      // debounce flip
      if (lastSentSpeaking !== null && isSpeaking !== lastSentSpeaking) {
        if (now - lastSpeakingFlipAt < MIN_FLIP_MS) return;
        lastSpeakingFlipAt = now;
      }

      // throttle outbound sends
      if (now - lastSendAt < SEND_INTERVAL_MS) {
        // Still update local UI immediately (optional), but do not spam server
        setVS(myId, { speaking: isSpeaking });
        renderMembersSidebar();
        return;
      }

      if (lastSentSpeaking === null || isSpeaking !== lastSentSpeaking) {
        lastSendAt = now;
        lastSentSpeaking = isSpeaking;

        // update local immediately
        setVS(myId, { speaking: isSpeaking });
        renderMembersSidebar();

        // broadcast to room
        sendVoiceState({ speaking: isSpeaking });
      }
    }

    // mark initial state
    lastSentSpeaking = null;
    lastSpeakingFlipAt = 0;
    tick();
  }

  function stopMicActivityMonitor() {
    if (micLoopHandle) cancelAnimationFrame(micLoopHandle);
    micLoopHandle = null;

    try { micAnalyser?.disconnect(); } catch(e) {}
    micAnalyser = null;
    micData = null;

    try { micAudioCtx?.close(); } catch(e) {}
    micAudioCtx = null;

    lastSentSpeaking = null;
    lastSpeakingFlipAt = 0;
  }

  function supportsSetSinkId(el) {
    return !!(el && typeof el.setSinkId === 'function');
  }

  async function listDevices() {
    // You generally only get full labels after permission is granted once.
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === 'audioinput');
    const spks = devices.filter(d => d.kind === 'audiooutput');
    return { mics, spks };
  }

  function fillSelect(selectEl, items, selectedId) {
    selectEl.innerHTML = '';
    items.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `${d.kind} (${d.deviceId.slice(0,6)}...)`;
      if (selectedId && d.deviceId === selectedId) opt.selected = true;
      selectEl.appendChild(opt);
    });
  }



  function setPinsButtonState(isOpen) {
    const btn = document.getElementById('viewPinsBtn');
    if (!btn) return;
    btn.textContent = isOpen ? 'Hide Pins' : 'Pins';
  }

  function getGifProviderKeyFromResult(g) {
    return String(g.id || g.gif_id || g.url || '');
  }
  function getGifProviderKeyFromUrl(url) {
    return String(url || '');
  }

  function updateGifFavUI(gifKey) {
    // update gif picker thumbs
    document.querySelectorAll('[data-gif-id]').forEach(el => {
      if (el.dataset.gifId !== gifKey) return;
      const btn = el.querySelector('.fav-btn');
      if (!btn) return;
      const favId = favoriteMap[gifKey];
      btn.textContent = favId ? '♥' : '♡';
      btn.title = favId ? 'Unfavorite' : 'Favorite';
    });

    // update chat messages that show this gif
    Object.values(msgIndex).forEach(m => {
      const content = (m.content || '').toString();
      const key = getGifProviderKeyFromUrl(content);
      if (key !== gifKey) return;
      const el = document.getElementById('msg-' + m.id);
      if (!el) return;
      const favBtn = el.querySelector('.gif-fav-btn');
      if (!favBtn) return;
      const favId = favoriteMap[gifKey];
      favBtn.textContent = favId ? '♥' : '♡';
      favBtn.title = favId ? 'Unfavorite' : 'Favorite';
    });
  } 

  function removeFavoriteEntriesById(fid) {
    const sid = String(fid);
    Object.keys(favoriteMap).forEach(k => {
      if (String(favoriteMap[k]) === sid) delete favoriteMap[k];
    });
  }


 // cache-busting + diagnostics
  fetch('/static/emojis.json?ts=' + Date.now(), {cache: 'no-store'})
    .then(async res => {
      console.log('[emoji] fetch status', res.status, res.headers.get('cache-control'));
      if (!res.ok) throw new Error('Failed to fetch emojis.json: ' + res.status);
      const data = await res.json();
      console.log('[emoji] raw data length', Array.isArray(data) ? data.length : 'not-array', data.slice ? data.slice(0,5) : null);
      EMOJI_LIST = data.map(item => item.char).filter(Boolean);
      EMOJI_ALIASES = {};
      data.forEach(item => {
        const ch = item.char;
        (item.aliases || []).forEach(a => {
          EMOJI_ALIASES[a.toLowerCase()] = ch;
        });
      });
      console.log('[emoji] processed', EMOJI_LIST.length, 'chars,', Object.keys(EMOJI_ALIASES).length, 'aliases');
    })
    .catch(err => {
      console.warn('Could not load emojis.json:', err);
    });


  let favoriteMap = {}; // gif_provider_id -> favorite_row_id

  window._referencedMsgId = null;

  function clearReferencedHighlight() {
    if (window._referencedMsgId) {
      const prev = document.getElementById('msg-' + window._referencedMsgId);
      if (prev) prev.classList.remove('referenced');
      window._referencedMsgId = null;
    }
  }

  function highlightReferencedMsg(id) {
    clearReferencedHighlight();
    const el = document.getElementById('msg-' + id);
    if (el) {
      el.classList.add('referenced');
      window._referencedMsgId = id;
    }
  }
  
  function isContainerNearBottom(wrapperEl, threshold = 60) {
    // threshold in px
    return (wrapperEl.scrollHeight - wrapperEl.scrollTop - wrapperEl.clientHeight) <= threshold;
  }

  function scrollWrapperToBottom(wrapperEl) {
    wrapperEl.scrollTop = wrapperEl.scrollHeight;
  }

  function ensureEndSpacer(container){

    if (!container) return;
    const last = container.lastElementChild;
    if (!last || !last.classList || !last.classList.contains('messages-end-spacer')) {
      const spacer = document.createElement('div');
      spacer.className = 'messages-end-spacer';
      container.appendChild(spacer);
    }
  }

  function showAppUI() {
    const authBox = document.getElementById('authBox');
    const chatUI = document.getElementById('chatUI');
    const header = document.getElementById('appHeader');
    const logoutBtn = document.getElementById('logoutBtn');

    if (authBox) authBox.style.display = 'none';
    if (chatUI) chatUI.style.display = 'block';
    if (header) header.style.display = 'flex';
    if (logoutBtn) logoutBtn.style.display = 'inline-block';
  }

  function showAuthUI() {
    const authBox = document.getElementById('authBox');
    const chatUI = document.getElementById('chatUI');
    const header = document.getElementById('appHeader');
    const logoutBtn = document.getElementById('logoutBtn')

    if (authBox) authBox.style.display = 'block';
    if (chatUI) chatUI.style.display = 'none';
    if (header) header.style.display = 'none';
    if (logoutBtn) logoutBtn.style.display = 'none';
  }

  function attachInfiniteScroll() {
    const wrapper = document.querySelector('.chat-wrapper');
    const container = document.getElementById('container');
    if (!wrapper || !container) return;

    wrapper.addEventListener('scroll', async () => {
      if (loadingOlder || !hasMoreHistory) return;
      if (wrapper.scrollTop > 60) return; // only when near top

      const roomId = localStorage.getItem('room_id');
      if (!roomId || !nextCursor) return;

      loadingOlder = true;
      try {
        const page = await fetchRoomMessagesPage(roomId, nextCursor, 50);
        const msgs = page.messages || [];
        hasMoreHistory = !!page.has_more;
        nextCursor = page.next_cursor || nextCursor;

        prependMessages(container, wrapper, msgs);
      } catch (e) {
        console.warn('load older failed', e);
      } finally {
        loadingOlder = false;
      }
    });
  }

  function showMessageElement(el) {
    const container = document.getElementById('container');
    if (!container) {
      document.body.appendChild(el);
      return;
    }

    const wrapper = container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper') || container;
    const wasNearBottom = isContainerNearBottom(wrapper, 50);

    // remove previous spacer before appending so we always append messages before spacer
    const existingSpacer = container.querySelector('.messages-end-spacer');
    if (existingSpacer) existingSpacer.remove();

    container.appendChild(el);
    // re-add spacer at the end
    ensureEndSpacer(container);

    if (wasNearBottom) {
      setTimeout(() => scrollWrapperToBottom(wrapper), 8);
    }
  }

  function shouldInitiateOffer(me, other) {
    // Deterministic rule prevents glare:
    // only the lexicographically smaller username creates the offer.
    return String(me) < String(other);
  }

  function getIceServers() {
    // STUN is enough for local + many networks; TURN can be added later.
    return [
      { urls: "stun:stun.l.google.com:19302" }
    ];
  }

  function ensureAudioSink(username) {
    const holder = document.getElementById("voiceAudioSinks");
    holder.style.display = "block";

    let el = voice.sinks.get(username);
    if (el) return el;

    el = document.createElement("audio");
    el.autoplay = true;
    el.playsInline = true;
    el.dataset.user = username;
    holder.appendChild(el);

    voice.sinks.set(username, el);
    return el;
  }

  function removeAudioSink(username) {
    const el = voice.sinks.get(username);
    if (el) {
      try { el.remove(); } catch(e) {}
      voice.sinks.delete(username);
    }
  }

  function closePeer(username) {
    const pc = voice.pcs.get(username);
    if (pc) {
      try { pc.onicecandidate = null; pc.ontrack = null; } catch(e) {}
      try { pc.close(); } catch(e) {}
      voice.pcs.delete(username);
    }
    removeAudioSink(username);
  }

  function sendVoiceSignal(to, data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "voice_signal", to, data }));
  }

  function requestRenegotiate(peerUsername) {
    sendVoiceSignal(peerUsername, { kind: "renegotiate" });
  }


  async function ensurePeerConnection(peerUsername) {
    if (voice.pcs.has(peerUsername)) return voice.pcs.get(peerUsername);

    const pc = new RTCPeerConnection({ iceServers: getIceServers() });

    // Add our mic tracks
    if (voice.localStream) {
      voice.localStream.getTracks().forEach(t => pc.addTrack(t, voice.localStream));
    }

    // If camera is already enabled, add the video track to this new peer connection too
    if (video.enabled && video.localStream) {
      video.localStream.getTracks().forEach(t => pc.addTrack(t, video.localStream));
    }


    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        sendVoiceSignal(peerUsername, { kind: "ice", candidate: ev.candidate });
      }
    };

    pc.ontrack = (ev) => {
      const [stream] = ev.streams;
      if (!stream) return;

      if (ev.track.kind === 'audio') {
        const sink = ensureAudioSink(peerUsername);
        sink.srcObject = stream;
        // apply chosen output device if supported
        const spkId = localStorage.getItem('spk_device_id') || '';
        if (spkId && supportsSetSinkId(sink)) {
          sink.setSinkId(spkId).catch(()=>{});
        }
      }

      if (ev.track.kind === 'video') {
        const tile = ensureVideoTile(peerUsername, false);
        if (tile) {
          tile.srcObject = stream;
          showVideoOverlay(peerUsername, false);

          // If remote stops camera, the track often ends or mutes
          ev.track.addEventListener('ended', () => {
            try { tile.srcObject = null; } catch(e) {}
            showVideoOverlay(peerUsername, true);
          });
          ev.track.addEventListener('mute', () => {
            showVideoOverlay(peerUsername, true);
          });
          ev.track.addEventListener('unmute', () => {
            showVideoOverlay(peerUsername, false);
          });
        }
      }
    };


    pc.onconnectionstatechange = () => {
      const st = pc.connectionState;
      if (st === "failed" || st === "closed" || st === "disconnected") {
        // do not aggressively tear down on transient "disconnected" if you want resilience;
        // for MVP, tear down on failed/closed:
        if (st === "failed" || st === "closed") {
          closePeer(peerUsername);
        }
      }
    };

    voice.pcs.set(peerUsername, pc);
    return pc;
  }

  async function renegotiateWithAllPeers() {
    if (!voice.enabled) return;

    for (const u of voice.users) {
      if (!u || u === myId) continue;

      // If I'm the deterministic offerer, I can create the offer directly.
      if (shouldInitiateOffer(myId, u)) {
        try { await createAndSendOffer(u); } catch (e) { console.warn('renegotiate offer failed', u, e); }
      } else {
        // I'm NOT the offerer for this pair; ask the offerer to renegotiate.
        requestRenegotiate(u);
      }
    }
  }

  async function startCamera() {
    if (video.enabled) return;
    if (!voice.enabled) {
      alert('Join Voice first (audio call). Then enable Camera.');
      return;
    }

    const attempts = [
      { video: { width: 640, height: 360, frameRate: 24 } },
      { video: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { ideal: 24 } } },
      { video: true }
    ];

    let stream = null;
    let lastErr = null;

    for (const constraints of attempts) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        break;
      } catch (e) {
        lastErr = e;
        console.warn('[camera] getUserMedia failed with', constraints, e.name, e.message);
      }
    }

    if (!stream) {
      const e = lastErr || new Error('Unknown camera error');
      alert(`Camera failed: ${e.name}\n${e.message}\n\nCommon fixes:\n- Close other apps using camera\n- Allow camera permission for this site\n- Try http://localhost:8000`);
      throw e;
    }

    video.localStream = stream;
    video.enabled = true;

    sendVoiceState({ video: true });

    const localTile = ensureVideoTile(myId, true);
    if (localTile) {
      localTile.srcObject = stream;
      showVideoOverlay(myId, false);
    }

    const vtrack = stream.getVideoTracks()[0];

    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) await sender.replaceTrack(vtrack);
      else pc.addTrack(vtrack, stream);
    }

    document.getElementById('cameraBtn').style.display = 'none';
    document.getElementById('camOffBtn').style.display = 'inline-block';

    await renegotiateWithAllPeers();
  }


  function setStageVisible(on) {
    const stage = document.getElementById('videoStage');
    if (!stage) return;

    if (on) {
      document.documentElement.style.setProperty('--stage-height', '220px');
      stage.style.display = 'flex';
    } else {
      document.documentElement.style.setProperty('--stage-height', '0px');
      stage.style.display = 'none';
    }
  }


  function stopCamera() {
    if (!video.enabled) return;

    // stop local track
    if (video.localStream) {
      video.localStream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
      video.localStream = null;
    }

    // remove video sender tracks from PCs
    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        try { pc.removeTrack(sender); } catch(e) {}
      }
    }

    const localTile = ensureVideoTile(myId, true);
    if (localTile) {
      try { localTile.srcObject = null; } catch(e){}
      showVideoOverlay(myId, true);
    }

    video.enabled = false;

    sendVoiceState({ video: false });

    document.getElementById('cameraBtn').style.display = 'inline-block';
    document.getElementById('camOffBtn').style.display = 'none';

    // Renegotiate to remove video from SDP
    renegotiateWithAllPeers().catch(()=>{});
  }


  async function createAndSendOffer(peerUsername) {
    const pc = await ensurePeerConnection(peerUsername);
    const offer = await pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: true
    });
    await pc.setLocalDescription(offer);
    sendVoiceSignal(peerUsername, { kind: "offer", sdp: pc.localDescription });
  }

  async function handleIncomingOffer(from, sdp) {
    const pc = await ensurePeerConnection(from);
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));

    // flush pending ICE
    const arr = pendingIce.get(from) || [];
    pendingIce.delete(from);
    for (const c of arr) {
      try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {}
    }

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendVoiceSignal(from, { kind: "answer", sdp: pc.localDescription });
    }

    async function handleIncomingAnswer(from, sdp) {
      const pc = await ensurePeerConnection(from);
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    }

    async function handleIncomingIce(from, candidate) {
      const pc = await ensurePeerConnection(from);

      if (!pc.remoteDescription) {
        const arr = pendingIce.get(from) || [];
        arr.push(candidate);
        pendingIce.set(from, arr);
        return;
      }
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    }

  function updateVoiceButtons() {
    const voiceBtn = document.getElementById("voiceBtn");
    const muteBtn = document.getElementById("muteBtn");
    if (!voiceBtn || !muteBtn) return;

    voiceBtn.textContent = voice.enabled ? "Leave Voice" : "Voice";
    muteBtn.style.display = voice.enabled ? "inline-block" : "none";
    muteBtn.textContent = voice.muted ? "Unmute" : "Mute";
  }

  async function joinVoice() {
    if (voice.enabled) return;

    const micDeviceId = localStorage.getItem('mic_device_id') || '';
    const echo = (localStorage.getItem('opt_echo') ?? 'true') === 'true';
    const noise = (localStorage.getItem('opt_noise') ?? 'true') === 'true';
    const agc  = (localStorage.getItem('opt_agc') ?? 'true') === 'true';
    const gain = parseFloat(localStorage.getItem('mic_gain') || '1');

    const outAudio = await buildOutgoingAudioStream({ micDeviceId, echo, noise, agc, gain });

    // voice.localStream should be the stream you add tracks from
    voice.localStream = outAudio;

    voice.enabled = true;
    voice.muted = false;
    updateVoiceButtons();

    const myTile = ensureVideoTile(myId, true);
    if (myTile) {
      try { myTile.srcObject = null; } catch(e) {}
      showVideoOverlay(myId, true); // show placeholder avatar
    }


    setVS(myId, { in_voice: true, muted: false, speaking: false });
    sendVoiceState({ muted: false, speaking: false });

    startMicActivityMonitor();
    renderMembersSidebar();

    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "voice_join" }));
    }
  }


  async function buildOutgoingAudioStream({ micDeviceId, echo, noise, agc, gain }) {
    // Stop existing raw stream tracks if we created them here
    if (audioGraph.rawStream) {
      audioGraph.rawStream.getTracks().forEach(t => { try{ t.stop(); } catch(e){} });
    }
    teardownAudioGraph();

    const constraints = {
      audio: {
        deviceId: micDeviceId ? { exact: micDeviceId } : undefined,
        echoCancellation: !!echo,
        noiseSuppression: !!noise,
        autoGainControl: !!agc
      }
    };

    const raw = await navigator.mediaDevices.getUserMedia(constraints);

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const src = ctx.createMediaStreamSource(raw);
    const gainNode = ctx.createGain();
    gainNode.gain.value = (typeof gain === 'number' ? gain : 1);

    const dest = ctx.createMediaStreamDestination();
    src.connect(gainNode);
    gainNode.connect(dest);

    audioGraph = { ctx, src, gainNode, dest, rawStream: raw, outStream: dest.stream };

    return dest.stream;
  }

  async function replaceOutgoingAudioTrackOnPeers(newAudioTrack) {
    for (const [username, pc] of voice.pcs.entries()) {
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
      if (sender) {
        await sender.replaceTrack(newAudioTrack);
      } else {
        // if connection existed but had no sender yet
        pc.addTrack(newAudioTrack, voice.localStream);
      }
    }
  }

  function leaveVoice() {
    if (!voice.enabled) return;

    try { stopCamera(); } catch(e) {}

    // inform room
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "voice_leave" }));
    }

    // close peers
    Array.from(voice.pcs.keys()).forEach(u => closePeer(u));
    voice.users.clear();

    // stop mic
    if (voice.localStream) {
      voice.localStream.getTracks().forEach(t => { try { t.stop(); } catch(e) {} });
      voice.localStream = null;
    }

    // stop speaking monitor and clear local UI state
    stopMicActivityMonitor();
    setVS(myId, { in_voice: false, muted: false, speaking: false });
    sendVoiceState({ muted: false, speaking: false });
    renderMembersSidebar();


    voice.enabled = false;
    voice.muted = false;
    updateVoiceButtons();

    const holder = document.getElementById("voiceAudioSinks");
    if (holder) holder.style.display = "none";

    for (const u of Array.from(video.tiles.keys())) {
      removeVideoTile(u);
    }
    video.tiles.clear();
    video.overlays.clear();
    setStageVisible(false);
  }

  function toggleMute() {
    if (!voice.enabled || !voice.localStream) return;
    voice.muted = !voice.muted;
    voice.localStream.getAudioTracks().forEach(t => t.enabled = !voice.muted);
    updateVoiceButtons();

    // update local and broadcast
    setVS(myId, { muted: voice.muted, speaking: false });
    sendVoiceState({ muted: voice.muted, speaking: false });
    renderMembersSidebar();
  }

  function renderMessage(msg, isLocalEcho=false, prevMsg=null) {
  // if message flagged deleted, skip rendering (safety)
  if (msg.deleted) return document.createElement('div');

  msgIndex[msg.id] = msg;

  const wrapper = document.createElement('div');
  wrapper.className = 'message';
  wrapper.id = 'msg-' + msg.id;

  // avatar
  const avatar = document.createElement('div');
  avatar.className = 'avatar';
  avatar.textContent = (msg.author && msg.author[0]) ? msg.author[0].toUpperCase() : '?';

  // body (meta + content)
  const body = document.createElement('div');
  body.className = 'message-body';

  const meta = document.createElement('div');
  meta.className = 'meta';
  const nameSpan = document.createElement('span');
  nameSpan.className = 'name';
  nameSpan.textContent = msg.author;
  const timeSpan = document.createElement('span');
  timeSpan.className = 'time';
  try { timeSpan.textContent = new Date(msg.timestamp).toLocaleString(); } catch(e){ timeSpan.textContent = ''; }
  meta.appendChild(nameSpan);
  meta.appendChild(timeSpan);
  if (msg.edited_at) {
    const editedSpan = document.createElement('span');
    editedSpan.className = 'edited';
    editedSpan.textContent = '(edited)';
    meta.appendChild(editedSpan);
  }
  body.appendChild(meta);

  const showTime = shouldShowTimestamp(prevMsg, msg, true);
  if (showTime) {
    try { timeSpan.textContent = new Date(msg.timestamp).toLocaleString(); } catch(e){ timeSpan.textContent=''; } 
    } else {
      timeSpan.textContent = '';
    }

  // --- inline reply preview (clickable) ---
  if (msg.reply_to) {
    const qr = document.createElement('div');
    qr.className = 'inline-reply-preview';
    qr.style.background = '#0b0c0e';
    qr.style.padding = '6px';
    qr.style.borderLeft = '3px solid rgba(255,255,255,0.03)';
    qr.style.borderRadius = '6px';
    qr.style.marginBottom = '6px';
    qr.style.color = 'var(--muted)';
    qr.style.fontSize = '13px';
    qr.style.cursor = 'pointer';
    // show short preview from local cache if available, else placeholder
    const quoted = msgIndex[msg.reply_to];
    qr.textContent = quoted ? ((quoted.deleted ? '(original deleted)' : (String(quoted.content || '').slice(0,120)))) : '(quoted message)';
    // click -> scroll to referenced message
    qr.onclick = (ev) => {
      ev.stopPropagation();
      const target = document.getElementById('msg-' + msg.reply_to);
      const wrapper = document.querySelector('.chat-wrapper');
      if (target && wrapper) {
        // smooth scroll target into center of wrapper
        const targetTop = target.offsetTop;
        const centerOffset = Math.round((wrapper.clientHeight / 2) - (target.clientHeight / 2));
        wrapper.scrollTo({ top: Math.max(0, targetTop - centerOffset), behavior: 'smooth' });
        // briefly highlight to give feedback
        target.classList.add('referenced');
        setTimeout(()=> target.classList.remove('referenced'), 1400);
      }
    };
    body.appendChild(qr);
  }


  const content = document.createElement('div');
  content.className = 'content';

  const text = (msg.content || "").toString();
  if (isImageUrl(text)) {
    const img = document.createElement('img');
    img.src = text;
    img.style.maxWidth = '300px';
    img.style.borderRadius = '6px';
    content.appendChild(img);

    // GIF favorite button (if you have favorites)
    const gifKey = getGifKeyFromUrl(text);
    const favBtn = document.createElement('button');
    favBtn.className = 'gif-fav-btn';
    const favId = favoriteMap[gifKey];
    favBtn.textContent = favId ? '♥' : '♡';
    favBtn.title = favId ? 'Unfavorite' : 'Favorite';
    favBtn.style.marginLeft = '8px';
    favBtn.onclick = async (e) => {
      e.stopPropagation();
      const token = getToken();
      if (!token) { alert('Log in to favorite GIFs'); return; }
      if (favoriteMap[gifKey]) {
        const fid = favoriteMap[gifKey];
        const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), { method: 'DELETE', headers: { token }});
        if (res.ok) { 
          removeFavoriteEntriesById(fid); 
          updateGifFavUI(gifKey); 
          favBtn.textContent='♡'; 
        }
      } else {
        const payload = { gif_id: gifKey, url: text, preview: text, title: '' };
        const res = await fetch('/gif/favorite', { method:'POST', headers: {'Content-Type':'application/json', token}, body: JSON.stringify(payload) });

        if (res.ok) {
          const j = await res.json().catch(()=>({}));
          if (j.id) {
            favoriteMap[String(gifKey)] = j.id;

            if (j.gif_id) favoriteMap[String(j.gif_id)] = j.id;

            if (j.original_gif_id) favoriteMap[String(j.original_gif_id)] = j.id;
          }
          favBtn.textContent='♥';
          updateGifFavUI(gifKey);
        }
      }
    };
    content.appendChild(favBtn);

  } else if (isVideoUrl(text)) {
    const vid = document.createElement('video');
    vid.src = text;
    vid.controls = true;
    vid.style.maxWidth = '400px';
    content.appendChild(vid);
  } else {
    const html = marked.parse(text);
    content.innerHTML = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
  }

  body.appendChild(content);

  // reactions area
  const reactionsBar = document.createElement('div');
  reactionsBar.className = 'reactions';
  if (msg.reactions && typeof msg.reactions === 'object') {
    Object.entries(msg.reactions).forEach(([emoji, users]) => {
      const rbtn = document.createElement('button');
      rbtn.textContent = `${emoji} ${Array.isArray(users) ? users.length : 0}`;
      rbtn.onclick = () => { if (!socket || socket.readyState !== WebSocket.OPEN) return; socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji })); };
      reactionsBar.appendChild(rbtn);
    });
  }

  const addReactBtn = document.createElement('button');
  addReactBtn.textContent = '+';
  addReactBtn.title = 'Add reaction';
  addReactBtn.onclick = (ev) => {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    openEmojiPicker(addReactBtn, (emoji) => { socket.send(JSON.stringify({ type: 'react', id: msg.id, emoji })); });
    ev.stopPropagation?.();
    };
    reactionsBar.appendChild(addReactBtn);
    body.appendChild(reactionsBar);

    // actions (pin/copy/reply/delete/edit) - keep small and unobtrusive
    const actions = document.createElement('div');
    actions.className = 'msg-actions';
    actions.style.marginTop = '6px';

    const pinBtn = document.createElement('button');
    pinBtn.textContent = msg.pinned ? 'Unpin' : 'Pin';
    pinBtn.onclick = () => {
      if (!socket || socket.readyState !== WebSocket.OPEN) return;
      const pinFlag = !msg.pinned;
      socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: pinFlag }));
    };
    actions.appendChild(pinBtn);

    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(msg.content || ''); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',900); } catch(e){ alert('Copy failed: '+e); }
    };
    actions.appendChild(copyBtn);

    const replyBtn = document.createElement('button');
    replyBtn.textContent = 'Reply';
    replyBtn.onclick = () => startReply(msg.id);
    actions.appendChild(replyBtn);

    if (msg.author === myId) {
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.onclick = () => { socket.send(JSON.stringify({ type: 'delete', id: msg.id })); };
      actions.appendChild(delBtn);

      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditUI(msg.id);
      actions.appendChild(editBtn);
    }

    body.appendChild(actions);

    // --- contextual menu (ellipsis button + menu on click / right-click) ---
    // create ellipsis button (will be visible because of CSS)
    const menuBtn = document.createElement('button');
    menuBtn.className = 'msg-menu-btn';
    menuBtn.textContent = '⋯';
    menuBtn.title = 'Actions';

    // helper to close existing menu
    function closeContextMenu() {
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();
      document.removeEventListener('click', closeContextMenu);
    }

    // make the menu DOM and attach actions
    function openContextMenuAt(x, y) {
      closeContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';

      const addItem = (label, fn) => {
        const b = document.createElement('button');
        b.textContent = label;
        b.onclick = (ev) => { ev.stopPropagation(); fn(); closeContextMenu(); };
        menu.appendChild(b);
      };

      addItem(msg.pinned ? 'Unpin' : 'Pin', () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        socket.send(JSON.stringify({ type: 'pin', id: msg.id, pin: !msg.pinned }));
      });

      addItem('Copy', () => {
        try { navigator.clipboard.writeText(msg.content || ''); } catch(e){ console.warn('copy failed', e); }
      });

      addItem('Reply', () => startReply(msg.id) );

      if (msg.author === myId) {
        addItem('Edit', () => openEditUI(msg.id));
        addItem('Delete', () => { if (!socket) return; socket.send(JSON.stringify({ type:'delete', id: msg.id })); });
      }

      // quick react row
      const reactRow = document.createElement('div');
      reactRow.style.display = 'flex';
      reactRow.style.gap = '6px';
      reactRow.style.marginTop = '6px';
      ['👍','❤️','😂','🔥','😮'].forEach(ch => {
        const rb = document.createElement('button');
        rb.textContent = ch;
        rb.onclick = (ev) => { ev.stopPropagation(); if (!socket) return; socket.send(JSON.stringify({ type:'react', id: msg.id, emoji: ch })); closeContextMenu(); };
        reactRow.appendChild(rb);
      });
      menu.appendChild(reactRow);

      document.body.appendChild(menu);

      // clamp position so menu stays on-screen
      const rect = menu.getBoundingClientRect();
      let left = Math.max(8, Math.min(window.innerWidth - rect.width - 8, x));
      let top = Math.max(8, Math.min(window.innerHeight - rect.height - 8, y));
      menu.style.left = left + 'px';
      menu.style.top = top + 'px';

      setTimeout(()=> document.addEventListener('click', closeContextMenu));
    }

    // show menu on ellipsis click
    menuBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const r = menuBtn.getBoundingClientRect();
      openContextMenuAt(r.left, r.bottom + 6);
    });

    // show menu on right-click
    wrapper.addEventListener('contextmenu', (ev) => {
      ev.preventDefault();
      openContextMenuAt(ev.clientX, ev.clientY);
    });

    // attach the ellipsis button to wrapper (CSS shows it on hover)
    wrapper.appendChild(menuBtn);


    wrapper.appendChild(avatar);
    wrapper.appendChild(body);
    return wrapper;
  }

  let voiceUIWired = false;

  function setupVoiceUI() {
    if (voiceUIWired) return;
    voiceUIWired = true;

    const voiceBtn = document.getElementById("voiceBtn");
    const muteBtn  = document.getElementById("muteBtn");
    if (!voiceBtn || !muteBtn) return;

    voiceBtn.addEventListener("click", async () => {
      console.log("[voice] click; wsState=", socket?.readyState, "secure=", window.isSecureContext);

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert("Not connected yet. Click Connect first (or wait for connection).");
        return;
      }

      try {
        if (!voice.enabled) await joinVoice();
        else leaveVoice();
      } catch (e) {
        console.error("[voice] join/leave failed", e);
        alert("Voice failed to start. Check mic permissions and HTTPS/localhost.");
      }
    });

    muteBtn.addEventListener("click", () => toggleMute());
  }

  let audioGraph = {
    ctx: null,
    gainNode: null,
    src: null,
    dest: null,
    rawStream: null,
    outStream: null
  };

  function teardownAudioGraph() {
    try { audioGraph.src?.disconnect(); } catch(e){}
    try { audioGraph.gainNode?.disconnect(); } catch(e){}
    try { audioGraph.ctx?.close(); } catch(e){}
    audioGraph = { ctx:null, gainNode:null, src:null, dest:null, rawStream:null, outStream:null };
  }

  const video = {
    enabled: false,
    localStream: null,   // just video stream (track)
    tiles: new Map(),     // username -> HTMLVideoElement
    overlays: new Map()
  };

  function ensureVideoTile(username, isLocal=false) {
    if (!voice.enabled) return null;

    setStageVisible(true);
    const stage = document.getElementById('videoStage');

    let el = video.tiles.get(username);
    if (el) return el;

    // tile box
    const box = document.createElement('div');
    box.style.position = 'relative';
    box.style.width = '240px';
    box.style.height = '160px';
    box.style.borderRadius = '10px';
    box.style.overflow = 'hidden';
    box.style.background = '#000';

    // video element
    el = document.createElement('video');
    el.autoplay = true;
    el.playsInline = true;
    el.muted = !!isLocal;
    el.style.width = '100%';
    el.style.height = '100%';
    el.style.objectFit = 'cover';
    el.style.display = 'block';

    // overlay placeholder (shown when no video stream)
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.inset = '0';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.background = '#0b0c0e';

    // avatar circle w/ initial + optional color
    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.style.width = '64px';
    avatar.style.height = '64px';
    avatar.style.fontSize = '22px';
    avatar.style.borderRadius = '50%';
    avatar.style.display = 'flex';
    avatar.style.alignItems = 'center';
    avatar.style.justifyContent = 'center';

    const prof = userDirectory[username] || {};
    const shownName = prof.display_name || username;
    avatar.textContent = shownName ? shownName[0].toUpperCase() : '?';
    if (prof.avatar_color) avatar.style.background = prof.avatar_color;

    overlay.appendChild(avatar);

    box.appendChild(el);
    box.appendChild(overlay);

    const wrap = document.createElement('div');
    wrap.style.display = 'grid';
    wrap.style.gap = '6px';

    const label = document.createElement('div');
    label.textContent = username;
    label.style.color = 'var(--muted)';
    label.style.fontSize = '12px';

    wrap.appendChild(box);
    wrap.appendChild(label);
    stage.appendChild(wrap);

    video.tiles.set(username, el);
    video.overlays.set(username, overlay);

    // start with overlay visible
    overlay.style.display = 'flex';

    return el;
  }

  function showVideoOverlay(username, show) {
    const ov = video.overlays.get(username);
    if (!ov) return;
    ov.style.display = show ? 'flex' : 'none';
  }

  function removeVideoTile(username) {
    const el = video.tiles.get(username);
    if (!el) return;
    const wrap = el.parentElement;
    try { wrap?.remove(); } catch(e){}
    video.tiles.delete(username);

    // hide stage if no tiles
    const stage = document.getElementById('videoStage');
    if (stage && video.tiles.size === 0) setStageVisible(false);
  }

  const onlineUsers = new Set();

  const typingUsers = new Set();
  const typingTimeouts = new Map(); // username -> timer

  const pendingIce = new Map(); // peer -> [candidates]
  const voiceState = new Map();

  function renderPresence() {
    const el = document.getElementById("presenceLine");
    if (!el) return;
    const arr = Array.from(onlineUsers).sort();
    el.textContent = arr.length ? ("Online: " + arr.join(", ")) : "No one online";
  }

  function renderTyping() {
    const el = document.getElementById("typingLine");
    if (!el) return;
    const arr = Array.from(typingUsers).sort();
    if (!arr.length) { el.textContent = ""; return; }

    el.innerHTML = arr.map(u => `<div>#{u} is typing...</div>`).join('')
  }

  function setUserTyping(user, isTyping) {
    if (!user) return;

    if (isTyping) {
      typingUsers.add(user);
      renderTyping();

      if (typingTimeouts.has(user)) clearTimeout(typingTimeouts.get(user));
      typingTimeouts.set(user, setTimeout(() => {
        typingUsers.delete(user);
        typingTimeouts.delete(user);
        renderTyping();
      }, 2500));
    } else {
      typingUsers.delete(user);
      if (typingTimeouts.has(user)) clearTimeout(typingTimeouts.get(user));
      typingTimeouts.delete(user);
      renderTyping();
    }
  }

  function getInviteCodeFromUrl() {
    const u = new URL(window.location.href);
    return u.searchParams.get('invite');
  }

  async function acceptInviteIfPresent() {
    const code = getInviteCodeFromUrl() || localStorage.getItem('pending_invite');
    if (!code) return null;

    const token = getToken();
    if (!token) {
      localStorage.setItem('pending_invite', code);
      return null;
    }

    const res = await fetch(`/invites/${encodeURIComponent(code)}/join`, {
      method: 'POST',
      headers: { token }
    });
    if (!res.ok) return null;

    const j = await res.json();
    if (j.room_id) {
      localStorage.setItem('room_id', j.room_id);
      localStorage.removeItem('pending_invite');

      // clean URL
      const url = new URL(window.location.href);
      url.searchParams.delete('invite');
      window.history.replaceState({}, '', url.toString());
      return j.room_id;
    }
    return null;
  }


  // on page load, try auto-login if token + username exist
  window.addEventListener('DOMContentLoaded', () => {
    setupVoiceUI();

    const token = getToken();
    const user = localStorage.getItem('username');

    if (token && user) {
      myId = user;            // <- ensure myId is set for connectSocket
      showAppUI();
      connectSocket();        // will show chatUI on successful WS open
    } else {
      showAuthUI();
    }
  });

  // delegated handler for edit buttons (works even if messages are rendered later)
  document.getElementById('container').addEventListener('click', (ev) => {
    const target = ev.target;
    if (!target) return;
    if (target.classList && target.classList.contains('edit-btn')) {
      const msgId = target.dataset.msgId;
      if (msgId) openEditUI(msgId);
    }
  });

  // openEditUI: top-level (global) edit UI — supports replacing content (text or media URL).
  function openEditUI(messageId) {
    const el = document.getElementById('msg-' + messageId);
    if (!el) return;
    const contentEl = el.querySelector('.content');
    if (!contentEl) return;

    // create editor UI (textarea + optional file input + Save/Cancel)
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.rows = 3;
    textarea.value = (msgIndex[messageId] && msgIndex[messageId].content) || '';

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'block';
    fileInput.style.marginTop = '6px';

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.marginLeft = '6px';

    // replace content element with editor
    contentEl.innerHTML = '';
    contentEl.appendChild(textarea);
    contentEl.appendChild(fileInput);
    contentEl.appendChild(saveBtn);
    contentEl.appendChild(cancelBtn);

    saveBtn.onclick = async () => {
      const newText = textarea.value.trim();

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert('Not connected');
        return;
      }

      // if a file is attached, upload it and use resulting URL as the new content
      const file = fileInput.files && fileInput.files[0];
      let finalContent = newText;
      if (file) {
        const fd = new FormData();
        fd.append('file', file);
        const token = getToken();
        if (!token) { alert('Log in to upload files'); return; }

        const up = await fetch('/upload', {
          method: 'POST',
          headers: { token },
          body: fd
        });

        if (!up.ok) {
          const j = await up.json().catch(()=>({}));
          alert('File upload failed ' + (j.detail || up.status));
          return;
        }
        const upj = await up.json().catch(()=>({}));
        finalContent = upj.url || finalContent;
      }

      // send edit request over websocket
      socket.send(JSON.stringify({ type: 'edit', id: messageId, content: finalContent }));

      // optimistic update
      msgIndex[messageId].content = finalContent;
      msgIndex[messageId].edited_at = new Date().toISOString();
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };

    cancelBtn.onclick = () => {
      // restore original view
      const newNode = renderMessage(msgIndex[messageId]);
      el.replaceWith(newNode);
    };
  }


  function startReply(messageId) {
    replyTo = messageId;

    const preview = document.getElementById('replyPreview');
    const msg = msgIndex[messageId];

    // set preview text (shortened)
    let previewText = '';
    if (msg) {
      if (msg.deleted) previewText = '(original deleted)';
      else previewText = (msg.content || '').toString().slice(0, 140);
    } else {
      previewText = '(loading...)';
    }
    if (preview) preview.textContent = previewText;

    // show pinned reply box above composer
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'flex';

    // highlight the referenced message visually
    highlightReferencedMsg(messageId);
  }


  //Gif Render
  document.getElementById('gifBtn').onclick = async function openGifPicker() {
    const gifPicker = document.getElementById('gifPicker');
    const gifBtn = document.getElementById('gifBtn');
    if (!gifPicker || !gifBtn) return;

    // toggle
    if (gifPicker.style.display === 'block') { gifPicker.style.display = 'none'; return; }

    // build the picker content (same as before)
    gifPicker.innerHTML = `
      <div class="picker-header">
        <button id="gifTrendingBtn" class="btn-small">Trending</button>
        <button id="gifSearchBtn" class="btn-small">Search</button>
        <button id="gifFavsBtn" class="btn-small">Favorites</button>
        <input id="gifSearchInput" placeholder="Search GIFs..." style="flex:1; min-width:120px;" />
      </div>
      <div id="gifGrid"></div>
    `;
    

    // position above the gifBtn, anchored to composer
    // position above the gifBtn, anchored to the composer and fixed to viewport
    gifPicker.style.position = 'fixed'; // important — keeps it visible and not extending page
    gifPicker.style.display = 'block';
    
    requestAnimationFrame(() => {
      const btnRect = gifBtn.getBoundingClientRect();

      // match width to pins panel if available
      const pinsPanel = document.getElementById('pinsPanel');
      if (pinsPanel && pinsPanel.style.display === 'block') {
        const pw = pinsPanel.getBoundingClientRect().width;
        if (pw > 200) gifPicker.style.width = `${Math.round(pw)}px`;
      } else {
        gifPicker.style.width = ''; // fall back to CSS width
      }

      const header = gifPicker.querySelector('.picker-header');
      const headerH = header ? header.getBoundingClientRect().height : 44;

      const topSafe = getTopSafeY();
      const bottomSafe = getBottomSafeY();

      const spaceAbove = btnRect.top - topSafe - 10;
      const spaceBelow = bottomSafe - btnRect.bottom - 10;

      const placeAbove = spaceAbove >= 240 || spaceAbove >= spaceBelow;

      // Pick a hard height so it can't grow later as images load
      const available = placeAbove ? spaceAbove : spaceBelow;
      const pickerH = Math.max(240, Math.floor(Math.min(window.innerHeight * 0.60, available)));

      gifPicker.style.height = `${pickerH}px`;

      const grid = gifPicker.querySelector('#gifGrid');
      if (grid) {
        const gridH = Math.max(180, pickerH - headerH);
        grid.style.height = `${gridH}px`;   // <- height, not maxHeight
      }

      // measure AFTER setting height
      const rect = gifPicker.getBoundingClientRect();

      // RIGHT-ALIGN to button (dropdown style)
      let left = Math.round(btnRect.right - rect.width);
      left = clamp(left, 8, window.innerWidth - rect.width - 8);

      let top = placeAbove
        ? Math.round(btnRect.top - rect.height - 10)
        : Math.round(btnRect.bottom + 10);

      top = clamp(top, topSafe, bottomSafe - rect.height);

      gifPicker.style.left = `${left}px`;
      gifPicker.style.top = `${top}px`;
    });




    const grid = document.getElementById('gifGrid');
    const searchInp = document.getElementById('gifSearchInput');

    async function ensureFavs(){ await loadFavoriteMap(); }

    document.getElementById('gifTrendingBtn').onclick = async () => {
      grid.innerHTML = 'Loading...';
      await ensureFavs();
      const res = await fetch('/gif/trending?limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifSearchBtn').onclick = async () => {
      const q = (searchInp && searchInp.value || '').trim();
      grid.innerHTML = 'Searching...';
      await ensureFavs();
      const res = await fetch('/gif/search?q=' + encodeURIComponent(q || '') + '&limit=24');
      const j = await res.json();
      renderGifGrid(j.results || [], grid);
    };

    document.getElementById('gifFavsBtn').onclick = async () => {
      grid.innerHTML = 'Loading favorites...';
      const token = getToken();
      if (!token) { grid.innerHTML = 'Log in to view favorites.'; return; }
      await ensureFavs();
      const res = await fetch('/gif/favorites', { headers: { 'token': token }});
      if (!res.ok) { grid.innerHTML = 'Failed to load favorites'; return; }
      const j = await res.json();
      const arr = (j.results || []).map(f => ({ id: f.gif_id, url: f.url, preview: f.preview, title: f.title }));
      renderGifGrid(arr, grid);
    };

    // debounce typing
    let t;
    searchInp.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(()=> document.getElementById('gifSearchBtn').click(), 300);
    });

    // initial load trending
    document.getElementById('gifTrendingBtn').click();

    // hide if user clicks anywhere else
    setTimeout(()=> window.addEventListener('click', function outside(e){
      if (!gifPicker.contains(e.target) && e.target !== gifBtn) {
        gifPicker.style.display = 'none';
        window.removeEventListener('click', outside);
      }
    }));
  };

  
  document.getElementById('inviteBtn').onclick = async () => {
    const roomId = localStorage.getItem('room_id');
    const token = getToken();

    if (!token) { alert('Log in first'); return; }
    if (!roomId) { alert('No room selected'); return; }

    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/invite`, {
      method: 'POST',
      headers: { token }
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      alert(j.detail || `Invite failed (${res.status})`);
      return;
    }

    const link = `${window.location.origin}${j.invite_path}`;

    // Copy-to-clipboard best effort
    try { await navigator.clipboard.writeText(link); } catch (e) {}

    alert('Invite link copied:\n' + link);
  };


  function getGifKeyFromResult(g) {
    return String(g.id || g.gif_id ||  g.gifId || g.url || '');
  }

  function getGifKeyFromUrl(url) {
    return String(url || '')
  }

  function renderGifGrid(results, grid){
    grid.innerHTML = '';
    const token = getToken();

    results.forEach(g => {
      const url = g.url;
      const gifKey = String(g.url || '');

      const wrapper = document.createElement('div');
      wrapper.style.position = 'relative';
      wrapper.style.margin = '6px';
      wrapper.dataset.gifId = gifKey;

      const thumb = document.createElement('img');
      thumb.src = g.preview || g.url;
      thumb.style.width = '120px';
      thumb.style.cursor = 'pointer';
      thumb.title = g.title || '';
      thumb.onclick = () => {
        if (!socket || socket.readyState !== WebSocket.OPEN) { alert('Not connected'); return; }
        socket.send(JSON.stringify({ 
          type:"message", 
          content: g.url, 
          gif: { provider: "giphy", id: g.id, url: g.url, preview: g.preview, title: g.title } 
        }));
        document.getElementById('gifPicker').style.display = 'none';
      };
      wrapper.appendChild(thumb);

      // favorite button (top-right)
      const favBtn = document.createElement('button');
      favBtn.className = 'fav-btn';
      const favRowId = favoriteMap[gifKey];
      favBtn.textContent = favRowId ? '♥' : '♡';
      favBtn.title = favRowId ? 'Unfavorite' : 'Favorite';
      favBtn.style.position = 'absolute';
      favBtn.style.top = '4px';
      favBtn.style.right = '4px';
      favBtn.style.padding = '4px';
      favBtn.style.fontSize = '12px';

      favBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!token) { alert('Log in to favorite GIFs'); return; }

        if (favoriteMap[gifKey]) {
          // unfavorite
          const fid = favoriteMap[gifKey];
          const res = await fetch('/gif/favorite?id=' + encodeURIComponent(fid), {
            method: 'DELETE',
            headers: {'token': token}
          });
          if (res.ok) {
            removeFavoriteEntriesById(fid);
            favBtn.textContent = '♡';
            favBtn.title = 'Favorite';
            updateGifFavUI(gifKey);
          } else {
            alert('Failed to remove favorite');
          }
        } else {
          // add favorite
          const payload = {
            gif_id: g.id,
            url: g.url,
            preview: g.preview,
            title: g.title,
            metadata: { provider_id: g.id }
          };
          const res = await fetch('/gif/favorite', {
            method: 'POST',
            headers: {'Content-Type':'application/json', 'token': token},
            body: JSON.stringify(payload)
          });
          if (res.ok) {
            const j = await res.json().catch(()=>({}));
            if (j.id) {
              favoriteMap[String(gifKey)] = j.id;
              if (j.gif_id) favoriteMap[String(j.gif_id)] = j.id
              if (j.original_gif_id) favoriteMap[String(j.original_gif_id)] = j.id;
            }
              favBtn.textContent = '♥';
              favBtn.title = 'Unfavorite';
              updateGifFavUI(gifKey);
          } else {
            const j = await res.json().catch(()=>({}));
            alert('Favorite failed: ' + (j.detail || JSON.stringify(j)));
          }
        }
      };

      wrapper.appendChild(favBtn);
      grid.appendChild(wrapper);
    });
  }


  //Debounce Helper
  function debounce(fn, wait){
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), wait); };
  }

  //Favorite Gifs
  function getLocalFavs(){ try{return JSON.parse(localStorage.getItem('gif_favs')||'[]');}catch(e){return []}}
  function addLocalFav(g){ const arr=getLocalFavs(); if(!arr.find(x=>x.id===g.id)) arr.push(g); localStorage.setItem('gif_favs', JSON.stringify(arr)); }
  function removeLocalFav(id){ let arr=getLocalFavs(); arr=arr.filter(x=>x.id!==id); localStorage.setItem('gif_favs', JSON.stringify(arr)); }

  //Reactions
  function openEmojiPicker(anchorEl, onChoose) {
    closeEmojiPicker();
    if (!anchorEl) return;

    const picker = document.createElement('div');
    picker.id = 'emoji-picker';
    picker.style.position = 'absolute';
    picker.style.background = '#fff';
    picker.style.border = '1px solid #ccc';
    picker.style.padding = '6px';
    picker.style.boxShadow = '0 6px 12px rgba(0,0,0,0.12)';
    picker.style.zIndex = 9999;
    picker.style.maxWidth = '360px';
    picker.style.maxHeight = '260px';
    picker.style.overflow = 'auto';

    const input = document.createElement('input');
    input.placeholder = 'Search emoji...';
    input.style.width = '100%';
    input.style.boxSizing = 'border-box';
    input.style.marginBottom = '6px';
    picker.appendChild(input);

    const grid = document.createElement('div');
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '6px';
    picker.appendChild(grid);

    function renderGrid(filter='') {
      grid.innerHTML = '';
      const q = (filter || '').toLowerCase().trim();
      const candidates = EMOJI_LIST.filter(ch => {
        if (!q) return true;
        if (ch.includes(q)) return true;
        return Object.keys(EMOJI_ALIASES).some(a => (EMOJI_ALIASES[a] === ch) && a.includes(q));
      }).slice(0, 120);
      candidates.forEach(ch => {
        const b = document.createElement('button');
        b.textContent = ch;
        b.style.fontSize = '18px';
        b.style.padding = '4px';
        b.style.cursor = 'pointer';
        b.onclick = () => { 
          console.log('[emoji-picker] chosen', ch);
          onChoose(ch); 
          closeEmojiPicker(); 
        };
        grid.appendChild(b);
      });
    }

    // wire input
    input.addEventListener('input', e => renderGrid(e.target.value));
    renderGrid();

    document.body.appendChild(picker);

    // position relative to anchorEl (best-effort)
    try {
      const r = anchorEl.getBoundingClientRect();
      picker.style.left = `${Math.max(4, r.left)}px`;
      picker.style.top = `${r.bottom + window.scrollY + 6}px`;
    } catch (e) {
      /* ignore positioning errors */
    }

    // outside-click removal
    setTimeout(()=> window.addEventListener('click', outsideClick));
    function outsideClick(e) {
      if (!picker.contains(e.target) && e.target !== anchorEl) closeEmojiPicker();
    }
    picker._outsideFn = outsideClick;
  }

  function closeEmojiPicker() {
    const p = document.getElementById('emoji-picker');
    if (p) {
      window.removeEventListener('click', p._outsideFn);
      p.remove();
    }
  }

  function replaceAliasesInText(text) {
    return text.replace(/:([a-zA-Z0-9_+-]+):/g, (m, alias) => {
      const ch = EMOJI_ALIASES[alias.toLowerCase()];
      return ch || m;
    });
  }


  function isImageUrl(url){
    return /\.(png|jpe?g|gif|webp)$/i.test(url);
  }

  function isVideoUrl(url) {
    if (!url) return false;
    return /\.(mp4|webm|ogg)$/i.test(url);
  }

  document.getElementById('cancelReply').onclick = () => {
    replyTo = null;
    const rb = document.getElementById('replyBox');
    if (rb) rb.style.display = 'none';
    const preview = document.getElementById('replyPreview');
    if (preview) preview.textContent = '';
    clearReferencedHighlight();
  };


  // REGISTER: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authRegister').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/register', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({username: u, password: p})
      });
      const j = await res.json();
      console.log('register result', res.status, j);

      if (res.ok && j.access_token) {
        localStorage.setItem('access_token', j.access_token);
        localStorage.setItem('username', j.username);
        document.getElementById('authStatus').textContent = `Registered & logged in as ${j.username}`;
        // hide auth UI
        const authBox = document.getElementById('authBox');
        if (authBox) authBox.style.display = 'none';
        // auto-connect
        try { await connectSocket(); } catch(e){ console.error('auto-connect failed', e); }
      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Register failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Register error — check server logs');
    }
  };

  // LOGIN: send JSON, store token/username, hide auth UI and auto-connect
  document.getElementById('authLogin').onclick = async () => {
    const u = document.getElementById('authUser').value.trim();
    const p = document.getElementById('authPass').value;
    if (!u || !p) return alert('enter username & password');

    try {
      const res = await fetch('/auth/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ username: u, password: p })
      });
    const j = await res.json();
    console.log('login response', res.status, j);

    if (res.ok && j.access_token) {
      localStorage.setItem('access_token', j.access_token);
      localStorage.setItem('username', j.username);
      myId = j.username;
      showAppUI();

      document.getElementById('authStatus').textContent = `Logged in as ${j.username}`;

      // auto-connect
      try { 
        await connectSocket(); 
      } catch(e){ 
        console.error('auto-connect failed', e); 
        document.getElementById('authStatus').textContent = 'Login ok but failed to connect: ' + e;
        }

      } else {
        const err = (j && (j.detail || j.error)) ? (typeof j.detail === 'string' ? j.detail : JSON.stringify(j.detail)) : JSON.stringify(j);
        document.getElementById('authStatus').textContent = 'Login failed: ' + err;
      }
    } catch (e) {
      console.error(e);
      alert('Login error — check server logs');
    }
  };
  
function resetChatUI(){
  //Clear DOM
  document.getElementById('container').innerHTML = '';
  document.getElementById('pinsContainer').innerHTML = '';
  closePinsPanel();
  document.getElementById('viewPinsBtn').textContent = 'Pins';

  // Clear client state
  for (const k in msgIndex) delete msgIndex[k];
  replyTo = null;

  // Clear input
  const input = document.getElementById('inputText');
  if (input) input.value = '';

  // Hide reply box
  document.getElementById('replyBox').style.display = 'none';
  document.getElementById('replyPreview').textContent = '';

  onlineUsers.clear();
  typingUsers.clear();
  renderPresence();
  renderTyping();
}



// centralized connect function
async function connectSocket() {
  const token = getToken()
  const storedUsername = localStorage.getItem('username');
  myId = storedUsername || myId;

  console.log('[connectSocket] token?', !!token, 'myId:', myId);
  console.log('[connectSocket] page protocol:', window.location.protocol, 'host:', window.location.host);

  if (!token || !myId) { showAuthUI(); return}

  const me = await fetchMe();
  if (!me) { showAuthUI(); return;}

  // if already connected, do nothing (or optionally re-open)
  if (socket && socket.readyState === WebSocket.OPEN) {
    showAppUI();
    document.getElementById('connectBtn').disabled = true;

    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) logoutBtn.style.display = 'inline-block';

    return;
  }


  document.getElementById('chatUI').style.display = 'block';
  document.getElementById('status').textContent = 'Connecting...'

  let roomId;

  try {
    const invitedRoom = await acceptInviteIfPresent();
    if (invitedRoom) {
      roomId = invitedRoom;
    } else {
      roomId = await ensureDefaultRoom();
    }
    roomMembers = await fetchRoomMembers(roomId);
    renderMembersSidebar();

  } catch (e) {
    console.error('[connectSocket] ensureDefaultRoom failed', e);
    document.getElementById('status').textContent = 'Failed to load rooms. See console.';
    // revert so user isn't stuck
    document.getElementById('chatUI').style.display = 'none';
    document.getElementById('authBox').style.display = 'block';
    throw e;
  }

  // build ws url relative to current page so it works on Render / localhost / prod
  const isSecure = (window.location.protocol === 'https:');
  const wsProto = isSecure ? 'wss' : 'ws';
  const host = window.location.host; // includes port if any

  const wsUrl = `${wsProto}://${host}/ws?token=${encodeURIComponent(token)}&room_id=${encodeURIComponent(roomId)}`;

  console.log('[connectSocket] opening', wsUrl);
  document.getElementById('status').textContent = 'Connecting...';
  socket = new WebSocket(wsUrl);

  // hydrate header from /me so display_name + avatar_color apply immediately
  try {
    if (me) {
      const shownName = me.display_name || me.username || myId;
      const headerUserEl = document.getElementById('headerUsername');
      const headerAvatarEl = document.getElementById('headerAvatar');

      if (headerUserEl) headerUserEl.textContent = shownName;
      if (headerAvatarEl) {
        headerAvatarEl.textContent = shownName ? shownName[0].toUpperCase() : '?';
        if (me.avatar_color) headerAvatarEl.style.background = me.avatar_color;
      }
    }
  } catch(e) {
    console.warn('fetchMe failed on connect', e);
  }

  socket.addEventListener('open', () => {

    ensureNotificationPermission();

    document.getElementById('appHeader').style.display = 'flex';
    document.getElementById('headerAvatar').style.display = 'flex';
    document.getElementById('status').textContent = 'Connected as ' + myId;

    // load favorite gifs
    loadFavoriteMap().then(() => {
      Object.values(msgIndex).forEach(m => {
        const key = getGifProviderKeyFromUrl(m.content || '');
        if (key) updateGifFavUI(key);
      });
    });

    // Show chat UI
    document.getElementById('chatUI').style.display = 'block';
    document.getElementById('status')

    // Hide auth UI
    document.getElementById('authBox').style.display = 'none';

    // Show logout
    document.getElementById('logoutBtn').style.display = 'inline-block';

    // Disable connect
    document.getElementById('connectBtn').disabled = true;

    // Voice UI
    setupVoiceUI();
    document.getElementById("voiceBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    updateVoiceButtons();


    attachInfiniteScroll();
  });

  socket.addEventListener('error', (ev) => {
    console.error('[WS] error', ev);
    document.getElementById('status').textContent = 'WS error (see console)';
  });

  socket.addEventListener('close', (ev) => {
    try { leaveVoice(); } catch(e) {}
    console.log('[WS] closed code=', ev.code, 'reason=', ev.reason, 'wasClean=', ev.wasClean);
    document.getElementById('status').textContent = `Disconnected (code ${ev.code})`;

    // if we never successfully connected, show auth UI again
    if (ev.code === 1008 || ev.code === 1006) {
      document.getElementById('chatUI').style.display = 'none';
      document.getElementById('authBox').style.display = 'block';
      document.getElementById('connectBtn').disabled = false;
    }

    if (ev.code === 1008) alert('Connection closed due to auth/policy (1008). Token may be invalid / expired.');
    document.getElementById("voiceBtn").disabled = true;
    document.getElementById("muteBtn").disabled = true;
  });

  socket.addEventListener('message', async (ev) => {
    // server sends JSON payloads
    console.log('WS incoming payload:', ev.data);

    let payload;
    try {
      payload = JSON.parse(ev.data);
    } catch (e) {
      console.warn('Non-JSON message', ev.data);
      return;
    }

    if (payload.type === 'history') {
      const msgs = payload.messages || [];
      const container = document.getElementById('container');
      const wrapper = document.querySelector('.chat-wrapper');

      container.innerHTML = ''; // clear
      msgs.forEach((m, i) => {
        const prev = i > 0 ? msgs[i-1] : null;
        const node = renderMessage(m, false, prev);
        showMessageElement(node);
      });

      const oldest = msgs.length ? msgs[0] : null;
      nextCursor = oldest ? oldest.timestamp : null;
      hasMoreHistory = true;

      ensureEndSpacer(container);
      return;
    }

    if (payload.type === "presence_snapshot") {
      onlineUsers.clear();
      (payload.online || []).forEach(u => onlineUsers.add(u));
      renderPresence();
      renderMembersSidebar();
      return;
    }

    if (payload.type === "presence") {
      if (payload.status === "online") onlineUsers.add(payload.user);
      else {
        onlineUsers.delete(payload.user);
        typingUsers.delete(payload.user);
      }
      renderPresence();
      renderTyping()
      renderMembersSidebar();
      return;
    }

    if (payload.type === "typing") {
      setUserTyping(payload.user, !!payload.is_typing);
      return;
    }



    if (payload.type === 'message') {

      if (!windowFocused) {
        unreadCount++;
        document.title = `(${unreadCount}) Chat`;
      }

      if (!windowFocused && 'Notification' in window && Notification.permission === 'granted') {
        const profile = userDirectory[payload.author] || {};
        const name = profile.display_name || payload.author;
        new Notification(name, { body: (payload.content || '').toString().slice(0, 120) });
      }

      const node = renderMessage(payload);
      showMessageElement(node);
      return;
    }

    if (payload.type === 'delete') {
      const id = payload.id;
      const el = document.getElementById('msg-' + id);
      if (el) el.remove();          // remove from DOM so text shifts up
      if (msgIndex[id]) delete msgIndex[id];  // remove from index
      return;
    }

    if (payload.type === 'pin') {
      const id = payload.id;
      const msg = msgIndex[id];
      if (msg) {
        msg.pinned = payload.pinned;
        msg.pinned_by = payload.pinned_by || null;
        msg.pinned_at = payload.pinned_at || null;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      const pinsPanel = document.getElementById('pinsPanel');
      if (pinsPanel && pinsPanel.style.display === 'block') buildPinsUI();
      return;
    }

    if (payload.type === 'edit') {
      const id = payload.id;
      const content = payload.content;
      const edited_at = payload.edited_at;
      const msg = msgIndex[id];
      if (msg) {
        msg.content = content;
        msg.edited_at = edited_at;
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'react') {
      const id = payload.id;
      const emoji = payload.emoji;
      const users = payload.users || [];
      const msg = msgIndex[id];
      if (msg) {
        msg.reactions = msg.reactions || {};
        if (!Array.isArray(users) || users.length === 0) {
          delete msg.reactions[emoji];
        } else {
          msg.reactions[emoji] = users;
        }
        const el = document.getElementById('msg-' + id);
        if (el) {
          const newNode = renderMessage(msg);
          el.replaceWith(newNode);
        }
      }
      return;
    }

    if (payload.type === 'error') {
      alert('Server error: ' + (payload.error || 'unknown'));
      return;
    }

    if (payload.type === 'notice') {
      const n = document.createElement('div');
      n.textContent = payload.text;
      showMessageElement(n);
    }

    if (payload.type === "user_directory") {
      Object.assign(userDirectory, payload.users || {});
      renderPresence(); // optional
      return;
    }

    if (payload.type === "voice_snapshot") {
      // reset in_voice for everyone in this room
      // (keep muted/speaking as last known if you want; this resets in_voice accurately)
      roomMembers.forEach(m => {
        if (m.username) setVS(m.username, { in_voice: false });
      });

      voice.users.clear();
      (payload.users || []).forEach(u => {
        voice.users.add(u);
        setVS(u, { in_voice: true });
      });

      // If server includes states (recommended below), hydrate them:
      if (payload.states && typeof payload.states === 'object') {
        Object.entries(payload.states).forEach(([u, st]) => {
          if (!u || !st) return;
          setVS(u, {
            in_voice: true,
            muted: !!st.muted,
            speaking: !!st.speaking
          });
        });
      }

      renderMembersSidebar();

      // existing connect logic:
      if (voice.enabled) {
        ensureVideoTile(myId, true);
        showVideoOverlay(myId, !video.enabled);
        voice.users.forEach(async (u) => {
          if (!u || u === myId) return;
          ensureVideoTile(u, u === myId)
          if (shouldInitiateOffer(myId, u)) {
            try { await createAndSendOffer(u); } catch(e) { console.warn("[voice] offer failed", u, e); }
          } else {
            await ensurePeerConnection(u);
          }
        });
      }
      return;
    }

    if (payload.type === "voice_join") {
      const u = payload.user;
      if (u) {
        voice.users.add(u);
        setVS(u, { in_voice: true, muted: false, speaking: false });
      }
      renderMembersSidebar();

      if (voice.enabled && u && u !== myId) {
        ensureVideoTile(u, u === myId)
        if (shouldInitiateOffer(myId, u)) {
          try { await createAndSendOffer(u); } catch(e) { console.warn("[voice] offer failed", u, e); }
        } else {
          await ensurePeerConnection(u);
        }
      }
      return;
    }

    if (payload.type === "voice_leave") {
      const u = payload.user;
      if (u) {
        voice.users.delete(u);
        setVS(u, { in_voice: false, muted: false, speaking: false });
        closePeer(u);
        removeVideoTile(u);
      }
      renderMembersSidebar();
      return;
    }


    if (payload.type === "voice_signal") {
      const from = payload.from;
      const data = payload.data || {};
      if (!voice.enabled) return;
      if (!from || from === myId) return;

      try {
        if (data.kind === "offer") await handleIncomingOffer(from, data.sdp);
        else if (data.kind === "answer") await handleIncomingAnswer(from, data.sdp);
        else if (data.kind === "ice") await handleIncomingIce(from, data.candidate);
        else if (data.kind === "renegotiate") {
          // Only the deterministic offerer should respond by making an offer
          if (shouldInitiateOffer(myId, from)) {
            await createAndSendOffer(from);
          }
        }
      } catch (e) {
        console.warn("[voice] signal handling failed", from, data.kind, e);
      }
      return;
    }

    if (payload.type === "voice_state") {
      const u = payload.user;
      if (!u) return;

      // speaking is ephemeral; optionally auto-expire after ~1s
      const patch = {};
      if (typeof payload.muted === 'boolean') patch.muted = payload.muted;
      if (typeof payload.speaking === 'boolean') patch.speaking = payload.speaking;

      setVS(u, patch);
      renderMembersSidebar();

      // optional: auto-expire speaking to avoid “stuck speaking” if packets drop
      if (patch.speaking) {
        const expected = Date.now();
        setTimeout(() => {
          const cur = getVS(u);
          // only clear if still speaking (no later update happened)
          if (cur.speaking) {
            setVS(u, { speaking: false });
            renderMembersSidebar();
          }
        }, 1200);
      }

      return;
    }
  });
}

  async function fetchMe() {
    const token = getToken();
    if (!token) {
      localStorage.removeItem('access_token');
      localStorage.removeItem('username');
      showAuthUI();
      throw new Error('Missing/invalid token; please log in again.');
    }
    const res = await fetch('/me', { headers: { token } });
    if (!res.ok) return null;
    return await res.json();
  }

  async function saveMe(patch) {
    const token = getToken();
    const res = await fetch('/me', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', token },
      body: JSON.stringify(patch)
    });
    const j = await res.json().catch(()=>({}));
    if (!res.ok) throw new Error(j.detail || 'save failed');
    return j;
  }

  async function ensureNotificationPermission() {
    if (!('Notification' in window)) return;
    if (Notification.permission === 'default') {
      try { await Notification.requestPermission(); } catch(e){}
    }
  }

  async function fetchRooms() {
    const token = getToken();
    const res = await fetch('/rooms', { headers: { token } });
    const j = await res.json().catch(() => ({}));

    if (res.status === 401) {
      // token invalid/stale — hard reset client auth state
      localStorage.removeItem('access_token');
      localStorage.removeItem('username');
      localStorage.removeItem('room_id');
      showAuthUI();
      throw new Error(j.detail || 'invalid token');
    }

    if (!res.ok) throw new Error(j.detail || `rooms fetch failed (${res.status})`);
    return j.results || [];
  }

  async function fetchRoomMembers(roomId) {
    const token = getToken();
    const res = await fetch(`/rooms/${encodeURIComponent(roomId)}/members`, { headers: { token }});
    if (!res.ok) return [];
    const j = await res.json();
    return j.results || [];
  }

  function renderMembersSidebar() {
    const sb = document.getElementById('membersSidebar');
    const list = document.getElementById('membersList');
    if (!sb || !list) return;

    sb.style.display = 'block';
    list.innerHTML = '';

    const membersSorted = roomMembers.slice().sort((a,b) => (a.username||'').localeCompare(b.username||''));

    membersSorted.forEach(m => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '8px';

      const dot = document.createElement('div');
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.background = onlineUsers.has(m.username) ? '#3ddc84' : 'rgba(255,255,255,0.15)';

      const name = document.createElement('div');
      name.style.flex = '1';
      name.style.minWidth = '0';
      name.style.overflow = 'hidden';
      name.style.textOverflow = 'ellipsis';
      name.style.whiteSpace = 'nowrap';
      name.textContent = m.display_name || m.username;

      row.appendChild(dot);
      row.appendChild(name);

      // --- voice badges ---
      const badges = document.createElement('div');
      badges.className = 'member-badges';

      const vs = getVS(m.username);

      // in-voice badge (server-driven via snapshot/join/leave)
      if (vs.in_voice) {
        const b = document.createElement('span');
        b.className = 'badge badge-voice';
        b.textContent = 'Voice';
        badges.appendChild(b);
      }

      // muted badge
      if (vs.in_voice && vs.muted) {
        const b = document.createElement('span');
        b.className = 'badge badge-muted';
        b.textContent = 'Muted';
        badges.appendChild(b);
      }

      // speaking badge (only if in voice and not muted)
      if (vs.in_voice && !vs.muted && vs.speaking) {
        const b = document.createElement('span');
        b.className = 'badge badge-speaking';
        b.textContent = 'Speaking';
        badges.appendChild(b);
      }

      row.appendChild(badges);
      list.appendChild(row);
    });
  }

  async function ensureDefaultRoom() {
    let rid = localStorage.getItem('room_id');

    const rooms = await fetchRooms();

        
    if (rid) {
      const ok = rooms.some(r => String(r.id) === String(rid));
      if (ok) return rid;

      localStorage.removeItem('room_id');
      rid = null;
    }

    // pick "general" if present, else first, else create it
    let general = rooms.find(r => (r.name || '').toLowerCase() === 'general');
    if (!general && rooms.length) general = rooms[0];

    if (!general) {
      const token = getToken();
      const cr = await fetch('/rooms', {
        method: 'POST',
        headers: { 'Content-Type':'application/json', token },
        body: JSON.stringify({ name: 'general' })
      });
      const cj = await cr.json();
      rid = cj.id;
    } else {
      rid = general.id;
    }

    localStorage.setItem('room_id', rid);
    return rid;
  }

  async function switchRoom(newRoomId) {
    if (!newRoomId) return;
    localStorage.setItem('room_id', newRoomId);

    // disconnect existing WS
    if (socket) { try { socket.close(); } catch(e){} socket = null; }

    // reset UI
    resetChatUI();

    // reconnect
    await connectSocket();

    roomMembers = await fetchRoomMembers(newRoomId);
    renderMembersSidebar();
  }

  function minuteKey(isoTs) {
    const d = new Date(isoTs);
    if (Number.isNaN(d.getTime())) return null;
    return `${d.getFullYear()}-${d.getMonth()}-${d.getDate()} ${d.getHours()}:${d.getMinutes()}`;
  }

  // Show time only if it differs from the previous rendered message.
  // If alsoSameAuthor=true, we only hide when both minute and author match.
  function shouldShowTimestamp(prevMsg, curMsg, alsoSameAuthor=true) {
    if (!prevMsg) return true;
    const a = minuteKey(prevMsg.timestamp);
    const b = minuteKey(curMsg.timestamp);
    if (!a || !b) return true;
    if (a !== b) return true;
    if (alsoSameAuthor && prevMsg.author !== curMsg.author) return true;
    return false;
  }



  // send on Enter (Shift+Enter for newline) — attach once on initial load
  (function attachEnterSend() {
    const inputEl = document.getElementById('inputText');
    
    if (!inputEl) return;
    inputEl.addEventListener('keydown', (e) => {
      // Enter without Shift -> send
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('submitButton').click();
      }
    });
  })();

  let typingTimer = null;
  let typingState = false;

  function sendTyping(isTyping) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: "typing", is_typing: isTyping }))
  }

  const inputEl = document.getElementById('inputText');
  inputEl.addEventListener('input', () => {
    if (!typingState) {
      typingState = true;
      sendTyping(true);
    }
    clearTimeout(typingTimer);
    typingTimer = setTimeout(() => {
      typingState = false;
      sendTyping(false);
    }, 1200);
  });



  // minimal connect button behavior now calls connectSocket()
  document.getElementById('connectBtn').onclick = () => {
    connectSocket();
  };

  document.getElementById('roomsBtn').onclick = async () => {
    try {
      const rooms = await fetchRooms();
      const list = document.getElementById('roomsList');
      list.innerHTML = '';
      const current = localStorage.getItem('room_id');

      rooms.forEach(r => {
        const row = document.createElement('button');
        row.className = 'btn-small';
        row.textContent = (r.id === current) ? `✓ ${r.name}` : r.name;
        row.onclick = async () => {
          document.getElementById('roomsModal').style.display = 'none';
          await switchRoom(r.id);
        };
        list.appendChild(row);
      });

      document.getElementById('roomsModal').style.display = 'block';
    } catch (e) {
      alert('Failed to load rooms: ' + e);
    }
  };

  document.getElementById('closeRooms').onclick = () => {
    document.getElementById('roomsModal').style.display = 'none';
  };

  document.getElementById('createRoomBtn').onclick = async () => {
    const name = (document.getElementById('newRoomName').value || '').trim();
    if (!name) return;

    const token = getToken();
    const res = await fetch('/rooms', {
      method: 'POST',
      headers: { 'Content-Type':'application/json', token },
      body: JSON.stringify({ name })
    });
    const j = await res.json().catch(()=>({}));
    if (!res.ok) {
      document.getElementById('roomsMsg').textContent = 'Create failed: ' + (j.detail || res.status);
      return;
    }
    document.getElementById('roomsMsg').textContent = `Created: ${j.name}`;
    document.getElementById('newRoomName').value = '';
    // refresh list
    document.getElementById('roomsBtn').click();
  };


  document.getElementById('settingsBtn').onclick = async () => {
    const me = await fetchMe();
    if (!me) return alert('Failed to load profile');
    document.getElementById('setDisplayName').value = me.display_name || '';
    document.getElementById('setStatus').value = me.status || '';
    document.getElementById('setAvatarColor').value = me.avatar_color || '';
    document.getElementById('setBio').value = me.bio || '';
    document.getElementById('settingsModal').style.display = 'block';
  };

  document.getElementById('closeSettings').onclick = () => {
  document.getElementById('settingsModal').style.display = 'none';
  };

  document.getElementById('saveSettings').onclick = async () => {
    const patch = {
      display_name: document.getElementById('setDisplayName').value,
      status: document.getElementById('setStatus').value,
      avatar_color: document.getElementById('setAvatarColor').value,
      bio: document.getElementById('setBio').value
    };
    try {
      const me = await saveMe(patch);
      // update local cache so UI reflects immediately
      userDirectory[me.username] = {
        display_name: me.display_name,
        status: me.status,
        avatar_color: me.avatar_color
      };
      document.getElementById('settingsMsg').textContent = 'Saved.';
      // refresh header avatar/name instantly
      const headerUserEl = document.getElementById('headerUsername');
      if (headerUserEl) headerUserEl.textContent = (me.display_name || me.username);
      const headerAvatarEl = document.getElementById('headerAvatar');
      if (headerAvatarEl) {
        headerAvatarEl.textContent = (me.display_name || me.username)[0].toUpperCase();
        if (me.avatar_color) headerAvatarEl.style.background = me.avatar_color;
      }
    } catch (e) {
      document.getElementById('settingsMsg').textContent = String(e.message || e);
    }
  };

  document.getElementById('audioBtn').onclick = async () => {
    // Ensure we have permission at least once so labels appear.
    try {
      if (!voice.localStream) {
        await navigator.mediaDevices.getUserMedia({ audio: true });
      }
    } catch(e) {
      // user may decline; still show modal (device labels may be blank)
    }

    const savedMic = localStorage.getItem('mic_device_id') || '';
    const savedSpk = localStorage.getItem('spk_device_id') || '';
    const savedGain = parseFloat(localStorage.getItem('mic_gain') || '1');

    document.getElementById('micGain').value = String(savedGain);
    document.getElementById('micGainVal').textContent = `${savedGain.toFixed(2)}x`;

    const { mics, spks } = await listDevices();
    fillSelect(document.getElementById('micSelect'), mics, savedMic);
    fillSelect(document.getElementById('spkSelect'), spks, savedSpk);

    // Hide speaker select if unsupported
    const anySink = Array.from(voice.sinks.values())[0];
    if (!supportsSetSinkId(anySink)) {
      document.getElementById('spkSelect').innerHTML = '';
    }

    document.getElementById('audioModal').style.display = 'block';
  };

  document.getElementById('applyAudio').onclick = async () => {
    const micId = document.getElementById('micSelect').value || '';
    const spkId = document.getElementById('spkSelect').value || '';
    const gain  = parseFloat(document.getElementById('micGain').value || '1');
    const echo  = document.getElementById('optEcho').checked;
    const noise = document.getElementById('optNoise').checked;
    const agc   = document.getElementById('optAgc').checked;

    localStorage.setItem('mic_device_id', micId);
    localStorage.setItem('spk_device_id', spkId);
    localStorage.setItem('mic_gain', String(gain));
    localStorage.setItem('opt_echo', String(echo));
    localStorage.setItem('opt_noise', String(noise));
    localStorage.setItem('opt_agc', String(agc));

    try {
      // Rebuild outgoing audio stream and swap tracks live if in voice
      const out = await buildOutgoingAudioStream({ micDeviceId: micId, echo, noise, agc, gain });
      voice.localStream = out;

      if (voice.enabled) {
        const newTrack = out.getAudioTracks()[0];
        await replaceOutgoingAudioTrackOnPeers(newTrack);

        // honor mute state
        newTrack.enabled = !voice.muted;
      }

      // Apply speaker output selection to every remote audio element
      for (const el of voice.sinks.values()) {
        if (supportsSetSinkId(el) && spkId) {
          try { await el.setSinkId(spkId); } catch(e) {}
        }
      }

      document.getElementById('audioMsg').textContent = 'Applied.';
    } catch (e) {
      console.error(e);
      document.getElementById('audioMsg').textContent = 'Failed to apply audio settings. See console.';
    }
  };

  document.getElementById('closeAudio').onclick = () => {
    document.getElementById('audioModal').style.display = 'none';
  };

  document.getElementById('micGain').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('micGainVal').textContent = `${v.toFixed(2)}x`;
  });

  document.getElementById('cameraBtn').onclick = () => startCamera().catch(e => {
    console.error(e);
    alert('Camera failed. Check permissions and HTTPS.');
  });

  document.getElementById('camOffBtn').onclick = () => stopCamera();


  document.getElementById('submitButton').onclick = () => {
    const input = document.getElementById('inputText');
    const text = input.value.trim();
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      alert('Not connected');
      return;
    }
    if (!text && !replyTo) return;
    const raw = input.value.trim();
    const contentToSend = replaceAliasesInText(raw);
    socket.send(JSON.stringify({ type: 'message', content: contentToSend, reply_to: replyTo || null }));

    input.value = '';
    
    setTimeout(()=> {
      const container= document.getElementById('container');
      const wrapper = container ? (container.closest('.chat-wrapper') || document.querySelector('.chat-wrapper')) : null;
      if (wrapper) wrapper.scrollTop = wrapper.scrollHeight;
    }, 50);

    // reset reply UI
    replyTo = null;
    document.getElementById('replyBox').style.display = 'none';
    document.getElementById('replyPreview').textContent = '';

    typingState = false;
    sendTyping(false);
  };

  function buildPinsUI() {
    const pinsContainer = document.getElementById('pinsContainer');
    pinsContainer.innerHTML = '';

    const pinned = Object.values(msgIndex)
      .filter(m => m && m.pinned && !m.deleted)
      .sort((a, b) => {
        // newest pinned first
        const at = a.pinned_at ? Date.parse(a.pinned_at) : 0;
        const bt = b.pinned_at ? Date.parse(b.pinned_at) : 0;
        return bt - at;
      });

    if (!pinned.length) {
      const empty = document.createElement('div');
      empty.style.color = 'var(--muted)';
      empty.style.padding = '8px';
      empty.textContent = 'No pinned messages yet.';
      pinsContainer.appendChild(empty);
      return;
    }

    pinned.forEach(m => {
      const node = renderMessage(m);

      // Make the whole pin entry clickable → jump to message in main chat
      node.style.cursor = 'pointer';
      node.addEventListener('click', (ev) => {
        // don’t steal clicks meant for buttons inside the pin (fav/reaction/etc)
        const tag = (ev.target && ev.target.tagName || '').toLowerCase();
        if (tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'a') return;

        closePinsPanel();
        scrollToMessageId(m.id);
      });

      pinsContainer.appendChild(node);
    });
  }


  function openPinsPanel() {
    const pinsPanel = document.getElementById('pinsPanel');
    const pinsBtn = document.getElementById('viewPinsBtn');
    const gifPicker = document.getElementById('gifPicker');

    buildPinsUI();
    // position under Pins button; make width match gif picker when it's present
    positionPanelUnderButton(pinsPanel, pinsBtn, gifPicker);
    setPinsButtonState(true);

    // close on outside click
    setTimeout(() => {
      function outside(e){
        if (!pinsPanel.contains(e.target) && e.target !== pinsBtn) {
          closePinsPanel();
          window.removeEventListener('click', outside);
        }
      }
      window.addEventListener('click', outside);
      pinsPanel._outside = outside;
    }, 0);
  }

  function closePinsPanel() {
    const pinsPanel = document.getElementById('pinsPanel');
    if (pinsPanel) {
      pinsPanel.style.display = 'none';
      if (pinsPanel._outside) window.removeEventListener('click', pinsPanel._outside);
    }
    setPinsButtonState(false);
  }

  document.getElementById('viewPinsBtn').onclick = () => {
    const pinsPanel = document.getElementById('pinsPanel');
    const open = pinsPanel.style.display === 'block';
    if (open) closePinsPanel();
    else openPinsPanel();
  };

  document.getElementById('closePins').onclick = () => closePinsPanel();


  document.getElementById('fileInput').onchange = async (e) => {
    const file = e.target.files[0];
    if (!file || !socket) return;

    const token = getToken();
    if (!token) { alert('Log in to upload files'); return; }

    const formData = new FormData();
    formData.append("file", file);

    const res = await fetch("/upload", {
      method: "POST",
      headers: { token },
      body: formData
    });

    if (!res.ok) {
      const j = await res.json().catch(()=>({}));
      alert('Upload failed: ' + (j.detail || res.status));
      return;
    }

    const data = await res.json();

    socket.send(JSON.stringify({
      type: "message",
      content: data.url
    }));

    e.target.value = '';
  };

document.getElementById('logoutBtn').onclick = () => {
  if (socket) {
    try { leaveVoice(); } catch(e){}
    try { socket.close(); } catch(e){}
    socket = null;
  }

  localStorage.removeItem('access_token');
  localStorage.removeItem('username');

  // Reset UI + state
  resetChatUI();

  showAuthUI();
};
</script>
</body>
</html>